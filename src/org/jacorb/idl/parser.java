
//----------------------------------------------------
// The following code was generated by CUP v0.9e
// Thu Mar 29 14:06:39 CEST 2001
//----------------------------------------------------

package org.jacorb.idl;

import java_cup.runtime.*;
import java.util.*;

public class parser extends java_cup.runtime.lr_parser {

  /** constructor */
  public parser() {super();}

  /** production table */
  protected static final short _production_table[][] = {
        {0, 2},     {96, 0},     {9, 2},     {9, 1},     {11, 2}, 
        {11, 1},     {10, 2},     {10, 2},     {10, 2},     {10, 2}, 
        {10, 2},     {10, 2},     {12, 5},     {13, 6},     {13, 7}, 
        {13, 7},     {13, 2},     {13, 3},     {13, 3},     {14, 2}, 
        {14, 1},     {15, 2},     {15, 2},     {15, 2},     {15, 2}, 
        {15, 2},     {93, 2},     {93, 1},     {90, 3},     {90, 1}, 
        {16, 1},     {16, 2},     {16, 3},     {16, 1},     {17, 1}, 
        {17, 1},     {17, 1},     {17, 3},     {17, 2},     {18, 3}, 
        {19, 7},     {19, 6},     {20, 2},     {20, 1},     {21, 7}, 
        {21, 6},     {22, 3},     {22, 2},     {22, 5},     {22, 1}, 
        {7, 1},     {7, 1},     {23, 2},     {23, 1},     {24, 1}, 
        {24, 1},     {24, 6},     {24, 5},     {25, 4},     {25, 4}, 
        {26, 1},     {26, 3},     {27, 3},     {28, 5},     {29, 1}, 
        {29, 1},     {29, 1},     {29, 1},     {29, 1},     {29, 1}, 
        {29, 1},     {29, 1},     {30, 1},     {32, 1},     {32, 3}, 
        {33, 1},     {33, 3},     {34, 1},     {34, 3},     {35, 1}, 
        {35, 3},     {35, 3},     {36, 1},     {36, 3},     {36, 3}, 
        {37, 1},     {37, 3},     {37, 3},     {37, 3},     {38, 2}, 
        {38, 1},     {8, 1},     {8, 1},     {8, 1},     {39, 1}, 
        {39, 1},     {39, 3},     {75, 1},     {75, 3},     {75, 1}, 
        {75, 1},     {75, 1},     {75, 1},     {75, 1},     {76, 3}, 
        {76, 2},     {31, 1},     {40, 1},     {40, 1},     {40, 1}, 
        {40, 1},     {40, 1},     {46, 2},     {41, 2},     {42, 1}, 
        {42, 1},     {47, 1},     {47, 1},     {47, 1},     {58, 1}, 
        {58, 1},     {58, 1},     {58, 1},     {58, 1},     {58, 1}, 
        {58, 1},     {48, 1},     {48, 1},     {48, 1},     {49, 1}, 
        {49, 1},     {49, 1},     {92, 3},     {92, 1},     {78, 1}, 
        {78, 1},     {79, 1},     {60, 1},     {60, 1},     {61, 1}, 
        {62, 1},     {63, 1},     {59, 1},     {59, 1},     {59, 2}, 
        {59, 2},     {59, 1},     {59, 2},     {64, 1},     {65, 1}, 
        {66, 2},     {67, 1},     {67, 1},     {68, 1},     {69, 1}, 
        {70, 1},     {51, 5},     {86, 1},     {86, 2},     {77, 3}, 
        {53, 9},     {45, 1},     {45, 1},     {45, 1},     {45, 1}, 
        {45, 1},     {55, 1},     {55, 2},     {56, 3},     {87, 3}, 
        {87, 2},     {87, 4},     {87, 3},     {57, 2},     {50, 5}, 
        {94, 1},     {94, 3},     {54, 2},     {73, 6},     {73, 4}, 
        {72, 4},     {72, 4},     {72, 1},     {72, 1},     {74, 6}, 
        {80, 2},     {95, 1},     {95, 2},     {81, 3},     {85, 4}, 
        {85, 3},     {91, 1},     {91, 3},     {52, 4},     {52, 5}, 
        {84, 6},     {5, 1},     {5, 1},     {43, 1},     {43, 1}, 
        {71, 1},     {89, 3},     {89, 2},     {88, 3},     {88, 1}, 
        {82, 3},     {6, 1},     {6, 1},     {6, 1},     {83, 4}, 
        {83, 1},     {2, 4},     {2, 1},     {3, 1},     {3, 3}, 
        {44, 1},     {44, 1},     {44, 1},     {4, 0}  };

  /** access to production table */
  public short[][] production_table() {return _production_table;}

  /** parse action table */
  protected static final short[][] _action_table = {
    /*0*/{0,-219,2,-2,8,-2,10,-2,13,-2,14,-2,21,-2,23,-2,24,-2,31,-2,37,-2,42,-2,44,-2,46,-2,-1,0},
    /*1*/{2,29,8,26,10,8,13,27,14,10,21,28,23,19,24,13,31,22,37,12,42,23,44,25,46,16,-1,0},
    /*2*/{0,5,-1,0},
    /*3*/{0,-4,-1,0},
    /*4*/{0,-1,-1,0},
    /*5*/{50,383,-1,0},
    /*6*/{50,382,-1,0},
    /*7*/{46,376,-1,0},
    /*8*/{50,375,-1,0},
    /*9*/{78,370,-1,0},
    /*10*/{50,-111,-1,0},
    /*11*/{78,361,-1,0},
    /*12*/{78,189,-1,0},
    /*13*/{0,-6,2,29,8,26,10,8,13,27,14,10,21,28,23,19,24,13,31,22,37,12,42,23,44,25,46,16,61,-6,-1,0},
    /*14*/{50,-35,-1,0},
    /*15*/{78,326,-1,0},
    /*16*/{50,-37,-1,0},
    /*17*/{50,325,-1,0},
    /*18*/{78,321,-1,0},
    /*19*/{50,-112,-1,0},
    /*20*/{50,320,-1,0},
    /*21*/{21,314,-1,0},
    /*22*/{3,86,5,81,7,67,12,95,13,27,17,271,18,83,22,64,25,80,26,93,34,280,35,90,36,82,37,12,43,73,44,25,45,77,48,91,49,92,75,70,78,76,-1,0},
    /*23*/{50,307,-1,0},
    /*24*/{78,247,-1,0},
    /*25*/{5,81,7,67,12,95,17,242,18,83,22,64,25,80,26,93,35,90,36,82,43,73,48,91,49,92,75,70,78,76,-1,0},
    /*26*/{78,227,-1,0},
    /*27*/{78,222,-1,0},
    /*28*/{21,35,46,36,-1,0},
    /*29*/{50,-36,-1,0},
    /*30*/{50,-110,-1,0},
    /*31*/{50,-108,-1,0},
    /*32*/{50,-109,-1,0},
    /*33*/{0,-3,-1,0},
    /*34*/{78,211,-1,0},
    /*35*/{78,37,-1,0},
    /*36*/{38,40,50,-38,54,38,60,-219,-1,0},
    /*37*/{25,-219,41,205,75,-219,78,-219,-1,0},
    /*38*/{60,-50,-1,0},
    /*39*/{25,80,75,70,78,76,-1,0},
    /*40*/{60,42,-1,0},
    /*41*/{3,-219,4,45,5,-219,7,-219,8,26,12,-219,13,27,14,10,18,-219,22,-219,24,13,25,-219,26,-219,27,46,33,44,35,-219,36,-219,37,12,42,23,43,-219,44,25,45,-219,47,-219,48,-219,49,-219,61,50,75,-219,78,-219,-1,0},
    /*42*/{50,203,-1,0},
    /*43*/{4,200,-1,0},
    /*44*/{3,86,5,81,7,67,12,95,18,83,22,64,25,80,26,93,35,90,36,82,43,73,45,77,48,91,49,92,75,70,78,76,-1,0},
    /*45*/{3,-197,5,-197,7,-197,12,-197,18,-197,22,-197,25,-197,26,-197,35,-197,36,-197,43,-197,45,-197,47,-197,48,-197,49,-197,75,-197,78,-197,-1,0},
    /*46*/{3,86,5,81,7,67,12,95,18,83,22,64,25,80,26,93,35,90,36,82,43,73,45,77,47,94,48,91,49,92,75,70,78,76,-1,0},
    /*47*/{50,61,-1,0},
    /*48*/{3,-198,5,-198,7,-198,12,-198,18,-198,22,-198,25,-198,26,-198,35,-198,36,-198,43,-198,45,-198,47,-198,48,-198,49,-198,75,-198,78,-198,-1,0},
    /*49*/{50,-42,-1,0},
    /*50*/{50,60,-1,0},
    /*51*/{50,59,-1,0},
    /*52*/{50,58,-1,0},
    /*53*/{61,57,-1,0},
    /*54*/{3,-219,4,45,5,-219,7,-219,8,26,12,-219,13,27,14,10,18,-219,22,-219,24,13,25,-219,26,-219,27,46,33,44,35,-219,36,-219,37,12,42,23,43,-219,44,25,45,-219,47,-219,48,-219,49,-219,61,-44,75,-219,78,-219,-1,0},
    /*55*/{61,-43,-1,0},
    /*56*/{50,-41,-1,0},
    /*57*/{3,-24,4,-24,5,-24,7,-24,8,-24,12,-24,13,-24,14,-24,15,-24,18,-24,22,-24,24,-24,25,-24,26,-24,27,-24,29,-24,30,-24,33,-24,35,-24,36,-24,37,-24,42,-24,43,-24,44,-24,45,-24,47,-24,48,-24,49,-24,61,-24,75,-24,78,-24,-1,0},
    /*58*/{3,-26,4,-26,5,-26,7,-26,8,-26,12,-26,13,-26,14,-26,15,-26,18,-26,22,-26,24,-26,25,-26,26,-26,27,-26,29,-26,30,-26,33,-26,35,-26,36,-26,37,-26,42,-26,43,-26,44,-26,45,-26,47,-26,48,-26,49,-26,61,-26,75,-26,78,-26,-1,0},
    /*59*/{3,-23,4,-23,5,-23,7,-23,8,-23,12,-23,13,-23,14,-23,15,-23,18,-23,22,-23,24,-23,25,-23,26,-23,27,-23,29,-23,30,-23,33,-23,35,-23,36,-23,37,-23,42,-23,43,-23,44,-23,45,-23,47,-23,48,-23,49,-23,61,-23,75,-23,78,-23,-1,0},
    /*60*/{3,-25,4,-25,5,-25,7,-25,8,-25,12,-25,13,-25,14,-25,15,-25,18,-25,22,-25,24,-25,25,-25,26,-25,27,-25,29,-25,30,-25,33,-25,35,-25,36,-25,37,-25,42,-25,43,-25,44,-25,45,-25,47,-25,48,-25,49,-25,61,-25,75,-25,78,-25,-1,0},
    /*61*/{50,-124,51,-124,65,-124,78,-124,-1,0},
    /*62*/{78,-217,-1,0},
    /*63*/{22,194,50,-150,51,-150,59,-150,65,-150,78,-150,-1,0},
    /*64*/{50,-122,51,-122,65,-122,78,-122,-1,0},
    /*65*/{75,151,78,-218,-1,0},
    /*66*/{50,-152,51,-152,59,-152,65,-152,78,-152,-1,0},
    /*67*/{78,160,-1,0},
    /*68*/{50,-147,51,-147,59,-147,65,-147,78,-147,-1,0},
    /*69*/{78,159,-1,0},
    /*70*/{78,-199,-1,0},
    /*71*/{78,-216,-1,0},
    /*72*/{22,64,35,90,-1,0},
    /*73*/{50,-121,51,-121,65,-121,78,-121,-1,0},
    /*74*/{78,-200,-1,0},
    /*75*/{38,-31,50,-31,51,-31,52,-31,54,-31,56,-31,57,-31,59,-31,60,-31,63,-31,65,-31,69,-31,70,-31,71,-31,72,-31,73,-31,75,-31,76,-31,77,-31,78,-31,-1,0},
    /*76*/{50,-126,51,-126,65,-126,78,-126,-1,0},
    /*77*/{50,-138,51,-138,65,-138,78,-138,-1,0},
    /*78*/{50,-123,51,-123,65,-123,78,-123,-1,0},
    /*79*/{38,-34,50,-34,51,-34,52,-34,54,-34,56,-34,57,-34,59,-34,60,-34,63,-34,65,-34,69,-34,70,-34,71,-34,72,-34,73,-34,75,-34,76,-34,77,-34,78,-34,-1,0},
    /*80*/{50,-154,51,-154,59,-154,65,-154,78,-154,-1,0},
    /*81*/{50,-183,51,-183,64,153,65,-183,78,-183,-1,0},
    /*82*/{50,-140,51,-140,65,-140,78,-140,-1,0},
    /*83*/{50,-125,51,-125,65,-125,78,-125,-1,0},
    /*84*/{50,-139,51,-139,65,-139,78,-139,-1,0},
    /*85*/{50,-156,51,-156,65,-156,78,-156,-1,0},
    /*86*/{50,-144,51,-144,59,-144,65,-144,78,-144,-1,0},
    /*87*/{50,-143,51,-143,59,-143,65,-143,78,-143,-1,0},
    /*88*/{50,-120,51,-120,65,-120,78,-120,-1,0},
    /*89*/{50,-149,51,-149,59,-149,65,-149,78,-149,-1,0},
    /*90*/{50,-153,51,-153,59,-153,65,-153,78,-153,-1,0},
    /*91*/{50,-184,51,-184,64,96,65,-184,78,-184,-1,0},
    /*92*/{50,-155,51,-155,65,-155,78,-155,-1,0},
    /*93*/{78,-201,-1,0},
    /*94*/{50,-142,51,-142,65,-142,78,-142,-1,0},
    /*95*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*96*/{50,-74,51,-74,54,-74,59,-74,63,-74,65,-74,69,-74,70,141,-1,0},
    /*97*/{50,-102,51,-102,52,-102,54,-102,56,-102,57,-102,59,-102,63,-102,65,-102,69,-102,70,-102,71,-102,72,-102,73,-102,76,-102,77,-102,-1,0},
    /*98*/{16,-93,25,-93,40,-93,58,-93,66,-93,67,-93,75,-93,78,-93,81,-93,83,-93,84,-93,-1,0},
    /*99*/{50,-101,51,-101,52,-101,54,-101,56,-101,57,-101,59,-101,63,-101,65,-101,69,-101,70,-101,71,-101,72,-101,73,-101,76,-101,77,-101,-1,0},
    /*100*/{50,-95,51,-95,52,-95,54,-95,56,-95,57,-95,59,-95,63,-95,65,-95,69,-95,70,-95,71,-95,72,-95,73,-95,75,151,76,-95,77,-95,-1,0},
    /*101*/{67,148,78,149,-1,0},
    /*102*/{50,-103,51,-103,52,-103,54,-103,56,-103,57,-103,59,-103,63,-103,65,-103,69,-103,70,-103,71,-103,72,-103,73,-103,76,-103,77,-103,-1,0},
    /*103*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*104*/{16,-94,25,-94,40,-94,58,-94,66,-94,67,-94,75,-94,78,-94,81,-94,83,-94,84,-94,-1,0},
    /*105*/{50,-80,51,-80,54,-80,56,126,57,127,59,-80,63,-80,65,-80,69,-80,70,-80,71,-80,76,-80,77,-80,-1,0},
    /*106*/{50,-86,51,-86,52,-86,54,-86,56,-86,57,-86,59,-86,63,-86,65,-86,69,-86,70,-86,71,-86,72,-86,73,-86,76,-86,77,-86,-1,0},
    /*107*/{79,144,-1,0},
    /*108*/{65,143,-1,0},
    /*109*/{50,-73,51,-73,54,-73,59,-73,63,-73,65,-73,69,139,-1,0},
    /*110*/{50,-98,51,-98,52,-98,54,-98,56,-98,57,-98,59,-98,63,-98,65,-98,69,-98,70,-98,71,-98,72,-98,73,-98,76,-98,77,-98,-1,0},
    /*111*/{50,-91,51,-91,52,-91,54,-91,56,-91,57,-91,59,-91,63,-91,65,-91,69,-91,70,-91,71,-91,72,-91,73,-91,76,-91,77,-91,-1,0},
    /*112*/{50,-104,51,-104,52,-104,54,-104,56,-104,57,-104,59,-104,63,-104,65,-104,69,-104,70,-104,71,-104,72,-104,73,-104,76,-104,77,-104,-1,0},
    /*113*/{16,-92,25,-92,40,-92,58,-92,66,-92,67,-92,75,-92,78,-92,81,-92,83,-92,84,-92,-1,0},
    /*114*/{50,-96,51,-96,52,-96,54,-96,56,-96,57,-96,59,-96,63,-96,65,-96,69,-96,70,-96,71,-96,72,-96,73,-96,76,-96,77,-96,-1,0},
    /*115*/{50,-100,51,-100,52,-100,54,-100,56,-100,57,-100,59,-100,63,-100,65,-100,69,-100,70,-100,71,-100,72,-100,73,-100,76,-100,77,-100,-1,0},
    /*116*/{50,-76,51,-76,54,-76,59,-76,63,-76,65,-76,69,-76,70,-76,71,137,-1,0},
    /*117*/{50,-83,51,-83,52,129,54,-83,56,-83,57,-83,59,-83,63,-83,65,-83,69,-83,70,-83,71,-83,72,131,73,130,76,-83,77,-83,-1,0},
    /*118*/{51,-107,63,-107,65,-107,-1,0},
    /*119*/{50,-78,51,-78,54,-78,59,-78,63,-78,65,-78,69,-78,70,-78,71,-78,76,124,77,123,-1,0},
    /*120*/{16,113,25,80,40,103,58,104,66,108,67,102,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*121*/{50,-90,51,-90,52,-90,54,-90,56,-90,57,-90,59,-90,63,-90,65,-90,69,-90,70,-90,71,-90,72,-90,73,-90,76,-90,77,-90,-1,0},
    /*122*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*123*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*124*/{50,-82,51,-82,54,-82,56,126,57,127,59,-82,63,-82,65,-82,69,-82,70,-82,71,-82,76,-82,77,-82,-1,0},
    /*125*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*126*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*127*/{50,-85,51,-85,52,129,54,-85,56,-85,57,-85,59,-85,63,-85,65,-85,69,-85,70,-85,71,-85,72,131,73,130,76,-85,77,-85,-1,0},
    /*128*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*129*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*130*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*131*/{50,-88,51,-88,52,-88,54,-88,56,-88,57,-88,59,-88,63,-88,65,-88,69,-88,70,-88,71,-88,72,-88,73,-88,76,-88,77,-88,-1,0},
    /*132*/{50,-89,51,-89,52,-89,54,-89,56,-89,57,-89,59,-89,63,-89,65,-89,69,-89,70,-89,71,-89,72,-89,73,-89,76,-89,77,-89,-1,0},
    /*133*/{50,-87,51,-87,52,-87,54,-87,56,-87,57,-87,59,-87,63,-87,65,-87,69,-87,70,-87,71,-87,72,-87,73,-87,76,-87,77,-87,-1,0},
    /*134*/{50,-84,51,-84,52,129,54,-84,56,-84,57,-84,59,-84,63,-84,65,-84,69,-84,70,-84,71,-84,72,131,73,130,76,-84,77,-84,-1,0},
    /*135*/{50,-81,51,-81,54,-81,56,126,57,127,59,-81,63,-81,65,-81,69,-81,70,-81,71,-81,76,-81,77,-81,-1,0},
    /*136*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*137*/{50,-79,51,-79,54,-79,59,-79,63,-79,65,-79,69,-79,70,-79,71,-79,76,124,77,123,-1,0},
    /*138*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*139*/{50,-75,51,-75,54,-75,59,-75,63,-75,65,-75,69,-75,70,141,-1,0},
    /*140*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*141*/{50,-77,51,-77,54,-77,59,-77,63,-77,65,-77,69,-77,70,-77,71,137,-1,0},
    /*142*/{50,-182,51,-182,65,-182,78,-182,-1,0},
    /*143*/{66,145,-1,0},
    /*144*/{50,-99,51,-99,52,-99,54,-99,56,-99,57,-99,59,-99,63,-99,65,-99,69,-99,70,-99,71,-99,72,-99,73,-99,76,-99,77,-99,-1,0},
    /*145*/{59,147,-1,0},
    /*146*/{50,-97,51,-97,52,-97,54,-97,56,-97,57,-97,59,-97,63,-97,65,-97,69,-97,70,-97,71,-97,72,-97,73,-97,76,-97,77,-97,-1,0},
    /*147*/{50,-106,51,-106,52,-106,54,-106,56,-106,57,-106,59,-106,63,-106,65,-106,69,-106,70,-106,71,-106,72,-106,73,-106,76,-106,77,-106,-1,0},
    /*148*/{67,150,-1,0},
    /*149*/{50,-105,51,-105,52,-105,54,-105,56,-105,57,-105,59,-105,63,-105,65,-105,69,-105,70,-105,71,-105,72,-105,73,-105,76,-105,77,-105,-1,0},
    /*150*/{78,152,-1,0},
    /*151*/{38,-33,50,-33,51,-33,52,-33,54,-33,56,-33,57,-33,59,-33,60,-33,63,-33,65,-33,69,-33,70,-33,71,-33,72,-33,73,-33,75,-33,76,-33,77,-33,78,-33,-1,0},
    /*152*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*153*/{65,155,-1,0},
    /*154*/{50,-181,51,-181,65,-181,78,-181,-1,0},
    /*155*/{50,-148,51,-148,59,-148,65,-148,78,-148,-1,0},
    /*156*/{50,-146,51,-146,59,-146,65,-146,78,-146,-1,0},
    /*157*/{50,-145,51,-145,59,-145,65,-145,78,-145,-1,0},
    /*158*/{38,-32,50,-32,51,-32,52,-32,54,-32,56,-32,57,-32,59,-32,60,-32,63,-32,65,-32,69,-32,70,-32,71,-32,72,-32,73,-32,75,-32,76,-32,77,-32,78,-32,-1,0},
    /*159*/{58,161,-1,0},
    /*160*/{19,182,20,185,28,181,59,183,-1,0},
    /*161*/{9,-219,32,163,50,-219,-1,0},
    /*162*/{58,175,-1,0},
    /*163*/{9,168,50,-219,-1,0},
    /*164*/{9,-211,50,-211,-1,0},
    /*165*/{50,-196,-1,0},
    /*166*/{50,-213,-1,0},
    /*167*/{58,169,-1,0},
    /*168*/{67,102,-1,0},
    /*169*/{51,173,59,-214,-1,0},
    /*170*/{59,172,-1,0},
    /*171*/{50,-212,-1,0},
    /*172*/{67,102,-1,0},
    /*173*/{59,-215,-1,0},
    /*174*/{25,80,75,70,78,76,-1,0},
    /*175*/{38,-30,51,179,59,-30,60,-30,75,151,-1,0},
    /*176*/{59,178,-1,0},
    /*177*/{9,-210,50,-210,-1,0},
    /*178*/{25,80,75,70,78,76,-1,0},
    /*179*/{38,-29,59,-29,60,-29,-1,0},
    /*180*/{3,-208,5,-208,7,-208,12,-208,18,-208,22,-208,25,-208,26,-208,35,-208,36,-208,43,-208,45,-208,48,-208,49,-208,75,-208,78,-208,-1,0},
    /*181*/{3,-207,5,-207,7,-207,12,-207,18,-207,22,-207,25,-207,26,-207,35,-207,36,-207,43,-207,45,-207,48,-207,49,-207,75,-207,78,-207,-1,0},
    /*182*/{9,-203,32,-203,50,-203,-1,0},
    /*183*/{59,193,-1,0},
    /*184*/{3,-209,5,-209,7,-209,12,-209,18,-209,22,-209,25,-209,26,-209,35,-209,36,-209,43,-209,45,-209,48,-209,49,-209,75,-209,78,-209,-1,0},
    /*185*/{51,191,59,-205,-1,0},
    /*186*/{3,86,5,81,7,67,12,95,18,83,22,64,25,80,26,93,35,90,36,82,43,73,45,77,48,91,49,92,75,70,78,76,-1,0},
    /*187*/{78,189,-1,0},
    /*188*/{50,-137,51,-137,59,-137,-1,0},
    /*189*/{51,-206,59,-206,-1,0},
    /*190*/{19,182,20,185,28,181,-1,0},
    /*191*/{59,-204,-1,0},
    /*192*/{9,-202,32,-202,50,-202,-1,0},
    /*193*/{50,-151,51,-151,59,-151,65,-151,78,-151,-1,0},
    /*194*/{78,189,-1,0},
    /*195*/{50,-192,51,198,-1,0},
    /*196*/{50,-191,-1,0},
    /*197*/{78,189,-1,0},
    /*198*/{50,-193,-1,0},
    /*199*/{3,86,5,81,7,67,12,95,18,83,22,64,25,80,26,93,35,90,36,82,43,73,45,77,48,91,49,92,75,70,78,76,-1,0},
    /*200*/{78,189,-1,0},
    /*201*/{50,-190,-1,0},
    /*202*/{3,-22,4,-22,5,-22,7,-22,8,-22,12,-22,13,-22,14,-22,15,-22,18,-22,22,-22,24,-22,25,-22,26,-22,27,-22,29,-22,30,-22,33,-22,35,-22,36,-22,37,-22,42,-22,43,-22,44,-22,45,-22,47,-22,48,-22,49,-22,61,-22,75,-22,78,-22,-1,0},
    /*203*/{60,-48,-1,0},
    /*204*/{25,-51,75,-51,78,-51,-1,0},
    /*205*/{25,-52,75,-52,78,-52,-1,0},
    /*206*/{25,80,75,70,78,76,-1,0},
    /*207*/{38,209,60,-47,-1,0},
    /*208*/{25,80,75,70,78,76,-1,0},
    /*209*/{60,-49,-1,0},
    /*210*/{50,-18,54,213,60,-219,-1,0},
    /*211*/{60,216,-1,0},
    /*212*/{25,80,75,70,78,76,-1,0},
    /*213*/{60,-28,-1,0},
    /*214*/{60,-27,-1,0},
    /*215*/{3,-219,4,45,5,-219,7,-219,8,26,12,-219,13,27,14,10,18,-219,22,-219,24,13,25,-219,26,-219,27,46,33,44,35,-219,36,-219,37,12,42,23,43,-219,44,25,45,-219,47,-219,48,-219,49,-219,61,-219,75,-219,78,-219,-1,0},
    /*216*/{61,221,-1,0},
    /*217*/{3,-198,5,-198,7,-198,12,-198,18,-198,22,-198,25,-198,26,-198,35,-198,36,-198,43,-198,45,-198,47,-198,48,-198,49,-198,61,-21,75,-198,78,-198,-1,0},
    /*218*/{3,-219,4,45,5,-219,7,-219,8,26,12,-219,13,27,14,10,18,-219,22,-219,24,13,25,-219,26,-219,27,46,33,44,35,-219,36,-219,37,12,42,23,43,-219,44,25,45,-219,47,-219,48,-219,49,-219,61,-219,75,-219,78,-219,-1,0},
    /*219*/{61,-20,-1,0},
    /*220*/{50,-15,-1,0},
    /*221*/{50,-17,54,213,60,-219,-1,0},
    /*222*/{60,224,-1,0},
    /*223*/{3,-219,4,45,5,-219,7,-219,8,26,12,-219,13,27,14,10,18,-219,22,-219,24,13,25,-219,26,-219,27,46,33,44,35,-219,36,-219,37,12,42,23,43,-219,44,25,45,-219,47,-219,48,-219,49,-219,61,-219,75,-219,78,-219,-1,0},
    /*224*/{61,226,-1,0},
    /*225*/{50,-14,-1,0},
    /*226*/{60,228,-1,0},
    /*227*/{78,229,-1,0},
    /*228*/{51,232,61,-176,-1,0},
    /*229*/{61,231,-1,0},
    /*230*/{50,-175,59,-175,78,-175,-1,0},
    /*231*/{78,229,-1,0},
    /*232*/{61,-177,-1,0},
    /*233*/{78,-71,-1,0},
    /*234*/{78,-70,-1,0},
    /*235*/{78,-66,-1,0},
    /*236*/{75,151,78,-72,-1,0},
    /*237*/{78,-65,-1,0},
    /*238*/{78,-67,-1,0},
    /*239*/{78,-69,-1,0},
    /*240*/{78,-68,-1,0},
    /*241*/{78,-141,-1,0},
    /*242*/{78,244,-1,0},
    /*243*/{55,245,-1,0},
    /*244*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*245*/{50,-64,-1,0},
    /*246*/{39,248,-1,0},
    /*247*/{58,249,-1,0},
    /*248*/{5,81,7,67,13,27,22,64,25,80,35,90,43,73,48,91,75,70,78,76,-1,0},
    /*249*/{59,-165,-1,0},
    /*250*/{59,-163,-1,0},
    /*251*/{59,256,-1,0},
    /*252*/{59,-166,75,151,-1,0},
    /*253*/{59,-162,-1,0},
    /*254*/{59,-164,-1,0},
    /*255*/{60,257,-1,0},
    /*256*/{6,262,11,259,-1,0},
    /*257*/{61,306,-1,0},
    /*258*/{54,304,-1,0},
    /*259*/{6,262,11,259,61,-167,-1,0},
    /*260*/{3,86,5,81,7,67,12,95,13,27,17,271,18,83,22,64,25,80,26,93,34,280,35,90,36,82,37,12,43,73,44,25,45,77,48,91,49,92,75,70,78,76,-1,0},
    /*261*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*262*/{54,264,-1,0},
    /*263*/{3,-170,5,-170,6,262,7,-170,11,259,12,-170,13,-170,17,-170,18,-170,22,-170,25,-170,26,-170,34,-170,35,-170,36,-170,37,-170,43,-170,44,-170,45,-170,48,-170,49,-170,75,-170,78,-170,-1,0},
    /*264*/{3,-172,5,-172,7,-172,12,-172,13,-172,17,-172,18,-172,22,-172,25,-172,26,-172,34,-172,35,-172,36,-172,37,-172,43,-172,44,-172,45,-172,48,-172,49,-172,75,-172,78,-172,-1,0},
    /*265*/{50,-130,78,-130,-1,0},
    /*266*/{50,-132,78,-132,-1,0},
    /*267*/{50,302,-1,0},
    /*268*/{50,-115,78,-115,-1,0},
    /*269*/{50,-118,51,-118,65,-118,78,-118,-1,0},
    /*270*/{64,297,-1,0},
    /*271*/{50,-116,78,-116,-1,0},
    /*272*/{50,-131,78,-131,-1,0},
    /*273*/{50,-119,51,-119,65,-119,75,151,78,-119,-1,0},
    /*274*/{50,-128,51,-128,65,-128,78,-128,-1,0},
    /*275*/{78,287,-1,0},
    /*276*/{50,-127,51,-127,65,-127,78,-127,-1,0},
    /*277*/{50,-117,51,-117,65,-117,78,-117,-1,0},
    /*278*/{50,-129,51,-129,65,-129,78,-129,-1,0},
    /*279*/{64,281,-1,0},
    /*280*/{3,86,5,81,7,67,12,95,17,271,18,83,22,64,25,80,26,93,34,280,35,90,36,82,43,73,45,77,48,91,49,92,75,70,78,76,-1,0},
    /*281*/{51,283,65,284,-1,0},
    /*282*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*283*/{50,-180,51,-180,65,-180,78,-180,-1,0},
    /*284*/{65,286,-1,0},
    /*285*/{50,-179,51,-179,65,-179,78,-179,-1,0},
    /*286*/{50,-137,51,-137,62,293,-1,0},
    /*287*/{50,-135,51,-135,-1,0},
    /*288*/{50,-174,-1,0},
    /*289*/{50,-136,51,-136,-1,0},
    /*290*/{50,-187,51,-187,62,293,-1,0},
    /*291*/{50,-186,51,-186,-1,0},
    /*292*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*293*/{63,295,-1,0},
    /*294*/{50,-189,51,-189,62,-189,-1,0},
    /*295*/{50,-188,51,-188,-1,0},
    /*296*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*297*/{51,299,-1,0},
    /*298*/{16,113,25,80,40,103,56,99,57,114,58,104,66,108,67,102,74,105,75,70,78,76,81,111,83,98,84,100,-1,0},
    /*299*/{65,301,-1,0},
    /*300*/{50,-185,51,-185,65,-185,78,-185,-1,0},
    /*301*/{6,-169,11,-169,61,-169,-1,0},
    /*302*/{61,-168,-1,0},
    /*303*/{3,-171,5,-171,6,262,7,-171,11,259,12,-171,13,-171,17,-171,18,-171,22,-171,25,-171,26,-171,34,-171,35,-171,36,-171,37,-171,43,-171,44,-171,45,-171,48,-171,49,-171,75,-171,78,-171,-1,0},
    /*304*/{3,-173,5,-173,7,-173,12,-173,13,-173,17,-173,18,-173,22,-173,25,-173,26,-173,34,-173,35,-173,36,-173,37,-173,43,-173,44,-173,45,-173,48,-173,49,-173,75,-173,78,-173,-1,0},
    /*305*/{50,-161,78,-161,-1,0},
    /*306*/{0,-12,2,-12,8,-12,10,-12,13,-12,14,-12,21,-12,23,-12,24,-12,31,-12,37,-12,42,-12,44,-12,46,-12,61,-12,-1,0},
    /*307*/{50,-113,-1,0},
    /*308*/{78,287,-1,0},
    /*309*/{50,-134,51,312,-1,0},
    /*310*/{50,-114,-1,0},
    /*311*/{78,287,-1,0},
    /*312*/{50,-133,-1,0},
    /*313*/{78,315,-1,0},
    /*314*/{50,-19,54,213,60,-219,-1,0},
    /*315*/{60,317,-1,0},
    /*316*/{3,-219,4,45,5,-219,7,-219,8,26,12,-219,13,27,14,10,18,-219,22,-219,24,13,25,-219,26,-219,27,46,33,44,35,-219,36,-219,37,12,42,23,43,-219,44,25,45,-219,47,-219,48,-219,49,-219,61,-219,75,-219,78,-219,-1,0},
    /*317*/{61,319,-1,0},
    /*318*/{50,-16,-1,0},
    /*319*/{0,-9,2,-9,8,-9,10,-9,13,-9,14,-9,21,-9,23,-9,24,-9,31,-9,37,-9,42,-9,44,-9,46,-9,61,-9,-1,0},
    /*320*/{60,322,-1,0},
    /*321*/{2,29,8,26,10,8,13,27,14,10,21,28,23,19,24,13,31,22,37,12,42,23,44,25,46,16,-1,0},
    /*322*/{61,324,-1,0},
    /*323*/{50,-13,-1,0},
    /*324*/{0,-8,2,-8,8,-8,10,-8,13,-8,14,-8,21,-8,23,-8,24,-8,31,-8,37,-8,42,-8,44,-8,46,-8,61,-8,-1,0},
    /*325*/{3,86,5,81,7,67,12,95,13,27,17,271,18,83,22,64,25,80,26,93,34,280,35,90,36,82,37,12,38,40,43,73,44,25,45,77,48,91,49,92,50,-39,54,38,60,-219,75,70,78,76,-1,0},
    /*326*/{60,329,-1,0},
    /*327*/{50,-40,-1,0},
    /*328*/{3,-219,4,45,5,-219,7,-219,8,26,12,-219,13,27,14,10,15,335,18,-219,22,-219,24,13,25,-219,26,-219,27,46,29,330,30,332,33,44,35,-219,36,-219,37,12,42,23,43,-219,44,25,45,-219,47,-219,48,-219,49,-219,61,-219,75,-219,78,-219,-1,0},
    /*329*/{3,86,5,81,7,67,12,95,13,27,17,271,18,83,22,64,25,80,26,93,34,280,35,90,36,82,37,12,43,73,44,25,45,77,48,91,49,92,75,70,78,76,-1,0},
    /*330*/{3,-56,4,-56,5,-56,7,-56,8,-56,12,-56,13,-56,14,-56,15,-56,18,-56,22,-56,24,-56,25,-56,26,-56,27,-56,29,-56,30,-56,33,-56,35,-56,36,-56,37,-56,42,-56,43,-56,44,-56,45,-56,47,-56,48,-56,49,-56,61,-56,75,-56,78,-56,-1,0},
    /*331*/{3,86,5,81,7,67,12,95,13,27,17,271,18,83,22,64,25,80,26,93,34,280,35,90,36,82,37,12,43,73,44,25,45,77,48,91,49,92,75,70,78,76,-1,0},
    /*332*/{3,-198,5,-198,7,-198,12,-198,18,-198,22,-198,25,-198,26,-198,35,-198,36,-198,43,-198,45,-198,47,-198,48,-198,49,-198,61,-54,75,-198,78,-198,-1,0},
    /*333*/{3,-55,4,-55,5,-55,7,-55,8,-55,12,-55,13,-55,14,-55,15,-55,18,-55,22,-55,24,-55,25,-55,26,-55,27,-55,29,-55,30,-55,33,-55,35,-55,36,-55,37,-55,42,-55,43,-55,44,-55,45,-55,47,-55,48,-55,49,-55,61,-55,75,-55,78,-55,-1,0},
    /*334*/{78,340,-1,0},
    /*335*/{61,339,-1,0},
    /*336*/{3,-219,4,45,5,-219,7,-219,8,26,12,-219,13,27,14,10,15,335,18,-219,22,-219,24,13,25,-219,26,-219,27,46,29,330,30,332,33,44,35,-219,36,-219,37,12,42,23,43,-219,44,25,45,-219,47,-219,48,-219,49,-219,61,-219,75,-219,78,-219,-1,0},
    /*337*/{61,-53,-1,0},
    /*338*/{50,-46,-1,0},
    /*339*/{58,341,-1,0},
    /*340*/{19,342,59,343,-1,0},
    /*341*/{3,86,5,81,7,67,12,95,18,83,22,64,25,80,26,93,35,90,36,82,43,73,45,77,48,91,49,92,75,70,78,76,-1,0},
    /*342*/{50,350,-1,0},
    /*343*/{59,348,-1,0},
    /*344*/{51,346,59,-61,-1,0},
    /*345*/{19,342,-1,0},
    /*346*/{59,-62,-1,0},
    /*347*/{50,349,-1,0},
    /*348*/{3,-57,4,-57,5,-57,7,-57,8,-57,12,-57,13,-57,14,-57,15,-57,18,-57,22,-57,24,-57,25,-57,26,-57,27,-57,29,-57,30,-57,33,-57,35,-57,36,-57,37,-57,42,-57,43,-57,44,-57,45,-57,47,-57,48,-57,49,-57,61,-57,75,-57,78,-57,-1,0},
    /*349*/{3,-58,4,-58,5,-58,7,-58,8,-58,12,-58,13,-58,14,-58,15,-58,18,-58,22,-58,24,-58,25,-58,26,-58,27,-58,29,-58,30,-58,33,-58,35,-58,36,-58,37,-58,42,-58,43,-58,44,-58,45,-58,47,-58,48,-58,49,-58,61,-58,75,-58,78,-58,-1,0},
    /*350*/{78,189,-1,0},
    /*351*/{51,-63,59,-63,-1,0},
    /*352*/{78,287,-1,0},
    /*353*/{50,355,-1,0},
    /*354*/{3,-59,4,-59,5,-59,7,-59,8,-59,12,-59,13,-59,14,-59,15,-59,18,-59,22,-59,24,-59,25,-59,26,-59,27,-59,29,-59,30,-59,33,-59,35,-59,36,-59,37,-59,42,-59,43,-59,44,-59,45,-59,47,-59,48,-59,49,-59,61,-59,75,-59,78,-59,-1,0},
    /*355*/{78,287,-1,0},
    /*356*/{50,358,-1,0},
    /*357*/{3,-60,4,-60,5,-60,7,-60,8,-60,12,-60,13,-60,14,-60,15,-60,18,-60,22,-60,24,-60,25,-60,26,-60,27,-60,29,-60,30,-60,33,-60,35,-60,36,-60,37,-60,42,-60,43,-60,44,-60,45,-60,47,-60,48,-60,49,-60,61,-60,75,-60,78,-60,-1,0},
    /*358*/{0,-5,61,-5,-1,0},
    /*359*/{50,-178,-1,0},
    /*360*/{60,362,-1,0},
    /*361*/{3,86,5,81,7,67,12,95,13,27,17,271,18,83,22,64,25,80,26,93,34,280,35,90,36,82,37,12,43,73,44,25,45,77,48,91,49,92,75,70,78,76,-1,0},
    /*362*/{61,369,-1,0},
    /*363*/{78,287,-1,0},
    /*364*/{3,86,5,81,7,67,12,95,13,27,17,271,18,83,22,64,25,80,26,93,34,280,35,90,36,82,37,12,43,73,44,25,45,77,48,91,49,92,61,-158,75,70,78,76,-1,0},
    /*365*/{61,-159,-1,0},
    /*366*/{50,368,-1,0},
    /*367*/{3,-160,5,-160,7,-160,12,-160,13,-160,17,-160,18,-160,22,-160,25,-160,26,-160,34,-160,35,-160,36,-160,37,-160,43,-160,44,-160,45,-160,48,-160,49,-160,61,-160,75,-160,78,-160,-1,0},
    /*368*/{50,-157,78,-157,-1,0},
    /*369*/{60,371,-1,0},
    /*370*/{3,86,5,81,7,67,12,95,13,27,17,271,18,83,22,64,25,80,26,93,34,280,35,90,36,82,37,12,43,73,44,25,45,77,48,91,49,92,61,373,75,70,78,76,-1,0},
    /*371*/{61,374,-1,0},
    /*372*/{50,-194,-1,0},
    /*373*/{50,-195,-1,0},
    /*374*/{0,-11,2,-11,8,-11,10,-11,13,-11,14,-11,21,-11,23,-11,24,-11,31,-11,37,-11,42,-11,44,-11,46,-11,61,-11,-1,0},
    /*375*/{78,377,-1,0},
    /*376*/{38,40,54,38,60,-219,-1,0},
    /*377*/{60,379,-1,0},
    /*378*/{3,-219,4,45,5,-219,7,-219,8,26,12,-219,13,27,14,10,15,335,18,-219,22,-219,24,13,25,-219,26,-219,27,46,29,330,30,332,33,44,35,-219,36,-219,37,12,42,23,43,-219,44,25,45,-219,47,-219,48,-219,49,-219,61,-219,75,-219,78,-219,-1,0},
    /*379*/{61,381,-1,0},
    /*380*/{50,-45,-1,0},
    /*381*/{0,-7,2,-7,8,-7,10,-7,13,-7,14,-7,21,-7,23,-7,24,-7,31,-7,37,-7,42,-7,44,-7,46,-7,61,-7,-1,0},
    /*382*/{0,-10,2,-10,8,-10,10,-10,13,-10,14,-10,21,-10,23,-10,24,-10,31,-10,37,-10,42,-10,44,-10,46,-10,61,-10,-1,0},
  };

  /** access to parse action table */
  public short[][] action_table() {return _action_table;}

  /** reduce_goto table */
  protected static final short[][] _reduce_table = {
    /*0*/{4,3,9,2,96,1,-1,-1},
    /*1*/{10,13,11,33,12,8,13,5,17,23,18,16,19,29,21,14,28,17,40,6,46,31,50,10,51,32,52,20,53,30,54,19,-1,-1},
    /*2*/{-1,-1},
    /*3*/{-1,-1},
    /*4*/{-1,-1},
    /*5*/{-1,-1},
    /*6*/{-1,-1},
    /*7*/{-1,-1},
    /*8*/{-1,-1},
    /*9*/{-1,-1},
    /*10*/{-1,-1},
    /*11*/{-1,-1},
    /*12*/{79,359,-1,-1},
    /*13*/{10,13,11,358,12,8,13,5,17,23,18,16,19,29,21,14,28,17,40,6,46,31,50,10,51,32,52,20,53,30,54,19,-1,-1},
    /*14*/{-1,-1},
    /*15*/{-1,-1},
    /*16*/{-1,-1},
    /*17*/{-1,-1},
    /*18*/{-1,-1},
    /*19*/{-1,-1},
    /*20*/{-1,-1},
    /*21*/{-1,-1},
    /*22*/{16,273,41,307,42,308,47,268,48,269,49,271,50,266,51,265,53,272,58,277,59,73,60,88,61,77,63,84,64,68,65,87,66,86,67,64,68,78,69,61,70,83,72,274,73,276,74,278,-1,-1},
    /*23*/{-1,-1},
    /*24*/{-1,-1},
    /*25*/{16,236,29,242,59,237,60,240,61,77,62,239,63,84,64,68,65,87,66,86,67,235,68,238,69,233,72,234,-1,-1},
    /*26*/{-1,-1},
    /*27*/{-1,-1},
    /*28*/{-1,-1},
    /*29*/{-1,-1},
    /*30*/{-1,-1},
    /*31*/{-1,-1},
    /*32*/{-1,-1},
    /*33*/{-1,-1},
    /*34*/{-1,-1},
    /*35*/{-1,-1},
    /*36*/{4,38,22,40,-1,-1},
    /*37*/{4,205,7,206,-1,-1},
    /*38*/{-1,-1},
    /*39*/{16,175,90,203,-1,-1},
    /*40*/{-1,-1},
    /*41*/{4,48,5,46,15,54,20,53,28,50,40,42,46,31,50,10,51,32,52,52,53,30,54,19,84,51,85,47,-1,-1},
    /*42*/{-1,-1},
    /*43*/{-1,-1},
    /*44*/{16,65,44,194,58,71,59,73,60,88,61,77,63,84,64,68,65,87,66,86,67,64,68,78,69,61,70,83,72,62,-1,-1},
    /*45*/{-1,-1},
    /*46*/{16,65,43,67,44,70,58,71,59,73,60,88,61,77,63,84,64,68,65,87,66,86,67,64,68,78,69,61,70,83,71,74,72,62,-1,-1},
    /*47*/{-1,-1},
    /*48*/{-1,-1},
    /*49*/{-1,-1},
    /*50*/{-1,-1},
    /*51*/{-1,-1},
    /*52*/{-1,-1},
    /*53*/{-1,-1},
    /*54*/{4,48,5,46,15,54,20,55,28,50,40,42,46,31,50,10,51,32,52,52,53,30,54,19,84,51,85,47,-1,-1},
    /*55*/{-1,-1},
    /*56*/{-1,-1},
    /*57*/{-1,-1},
    /*58*/{-1,-1},
    /*59*/{-1,-1},
    /*60*/{-1,-1},
    /*61*/{-1,-1},
    /*62*/{-1,-1},
    /*63*/{-1,-1},
    /*64*/{-1,-1},
    /*65*/{-1,-1},
    /*66*/{-1,-1},
    /*67*/{-1,-1},
    /*68*/{-1,-1},
    /*69*/{-1,-1},
    /*70*/{-1,-1},
    /*71*/{-1,-1},
    /*72*/{64,155,65,157,66,156,-1,-1},
    /*73*/{-1,-1},
    /*74*/{-1,-1},
    /*75*/{-1,-1},
    /*76*/{-1,-1},
    /*77*/{-1,-1},
    /*78*/{-1,-1},
    /*79*/{-1,-1},
    /*80*/{-1,-1},
    /*81*/{-1,-1},
    /*82*/{-1,-1},
    /*83*/{-1,-1},
    /*84*/{-1,-1},
    /*85*/{-1,-1},
    /*86*/{-1,-1},
    /*87*/{-1,-1},
    /*88*/{-1,-1},
    /*89*/{-1,-1},
    /*90*/{-1,-1},
    /*91*/{-1,-1},
    /*92*/{-1,-1},
    /*93*/{-1,-1},
    /*94*/{-1,-1},
    /*95*/{8,120,16,100,30,118,31,108,32,109,33,96,34,116,35,119,36,105,37,117,38,106,39,111,75,114,76,115,-1,-1},
    /*96*/{-1,-1},
    /*97*/{-1,-1},
    /*98*/{-1,-1},
    /*99*/{-1,-1},
    /*100*/{-1,-1},
    /*101*/{-1,-1},
    /*102*/{-1,-1},
    /*103*/{8,120,16,100,30,145,32,109,33,96,34,116,35,119,36,105,37,117,38,106,39,111,75,114,76,115,-1,-1},
    /*104*/{-1,-1},
    /*105*/{-1,-1},
    /*106*/{-1,-1},
    /*107*/{-1,-1},
    /*108*/{-1,-1},
    /*109*/{-1,-1},
    /*110*/{-1,-1},
    /*111*/{-1,-1},
    /*112*/{-1,-1},
    /*113*/{-1,-1},
    /*114*/{-1,-1},
    /*115*/{-1,-1},
    /*116*/{-1,-1},
    /*117*/{-1,-1},
    /*118*/{-1,-1},
    /*119*/{-1,-1},
    /*120*/{16,100,39,121,75,114,76,115,-1,-1},
    /*121*/{-1,-1},
    /*122*/{8,120,16,100,36,135,37,117,38,106,39,111,75,114,76,115,-1,-1},
    /*123*/{8,120,16,100,36,124,37,117,38,106,39,111,75,114,76,115,-1,-1},
    /*124*/{-1,-1},
    /*125*/{8,120,16,100,37,134,38,106,39,111,75,114,76,115,-1,-1},
    /*126*/{8,120,16,100,37,127,38,106,39,111,75,114,76,115,-1,-1},
    /*127*/{-1,-1},
    /*128*/{8,120,16,100,38,133,39,111,75,114,76,115,-1,-1},
    /*129*/{8,120,16,100,38,132,39,111,75,114,76,115,-1,-1},
    /*130*/{8,120,16,100,38,131,39,111,75,114,76,115,-1,-1},
    /*131*/{-1,-1},
    /*132*/{-1,-1},
    /*133*/{-1,-1},
    /*134*/{-1,-1},
    /*135*/{-1,-1},
    /*136*/{8,120,16,100,35,137,36,105,37,117,38,106,39,111,75,114,76,115,-1,-1},
    /*137*/{-1,-1},
    /*138*/{8,120,16,100,33,139,34,116,35,119,36,105,37,117,38,106,39,111,75,114,76,115,-1,-1},
    /*139*/{-1,-1},
    /*140*/{8,120,16,100,34,141,35,119,36,105,37,117,38,106,39,111,75,114,76,115,-1,-1},
    /*141*/{-1,-1},
    /*142*/{-1,-1},
    /*143*/{-1,-1},
    /*144*/{-1,-1},
    /*145*/{-1,-1},
    /*146*/{-1,-1},
    /*147*/{-1,-1},
    /*148*/{-1,-1},
    /*149*/{-1,-1},
    /*150*/{-1,-1},
    /*151*/{-1,-1},
    /*152*/{8,120,16,100,30,118,31,153,32,109,33,96,34,116,35,119,36,105,37,117,38,106,39,111,75,114,76,115,-1,-1},
    /*153*/{-1,-1},
    /*154*/{-1,-1},
    /*155*/{-1,-1},
    /*156*/{-1,-1},
    /*157*/{-1,-1},
    /*158*/{-1,-1},
    /*159*/{89,161,-1,-1},
    /*160*/{6,186,82,185,88,183,-1,-1},
    /*161*/{4,164,83,163,-1,-1},
    /*162*/{-1,-1},
    /*163*/{2,165,4,166,-1,-1},
    /*164*/{-1,-1},
    /*165*/{-1,-1},
    /*166*/{-1,-1},
    /*167*/{-1,-1},
    /*168*/{3,170,76,169,-1,-1},
    /*169*/{-1,-1},
    /*170*/{-1,-1},
    /*171*/{-1,-1},
    /*172*/{3,173,76,169,-1,-1},
    /*173*/{-1,-1},
    /*174*/{16,175,90,176,-1,-1},
    /*175*/{-1,-1},
    /*176*/{-1,-1},
    /*177*/{-1,-1},
    /*178*/{16,175,90,179,-1,-1},
    /*179*/{-1,-1},
    /*180*/{-1,-1},
    /*181*/{-1,-1},
    /*182*/{-1,-1},
    /*183*/{-1,-1},
    /*184*/{-1,-1},
    /*185*/{-1,-1},
    /*186*/{16,65,44,187,58,71,59,73,60,88,61,77,63,84,64,68,65,87,66,86,67,64,68,78,69,61,70,83,72,62,-1,-1},
    /*187*/{79,189,-1,-1},
    /*188*/{-1,-1},
    /*189*/{-1,-1},
    /*190*/{6,186,82,185,88,191,-1,-1},
    /*191*/{-1,-1},
    /*192*/{-1,-1},
    /*193*/{-1,-1},
    /*194*/{79,195,91,196,-1,-1},
    /*195*/{-1,-1},
    /*196*/{-1,-1},
    /*197*/{79,195,91,198,-1,-1},
    /*198*/{-1,-1},
    /*199*/{16,65,44,200,58,71,59,73,60,88,61,77,63,84,64,68,65,87,66,86,67,64,68,78,69,61,70,83,72,62,-1,-1},
    /*200*/{79,195,91,201,-1,-1},
    /*201*/{-1,-1},
    /*202*/{-1,-1},
    /*203*/{-1,-1},
    /*204*/{-1,-1},
    /*205*/{-1,-1},
    /*206*/{16,175,90,207,-1,-1},
    /*207*/{-1,-1},
    /*208*/{16,175,90,209,-1,-1},
    /*209*/{-1,-1},
    /*210*/{4,213,93,211,-1,-1},
    /*211*/{-1,-1},
    /*212*/{16,175,90,214,-1,-1},
    /*213*/{-1,-1},
    /*214*/{-1,-1},
    /*215*/{4,217,5,46,14,216,15,218,28,50,40,42,46,31,50,10,51,32,52,52,53,30,54,19,84,51,85,47,-1,-1},
    /*216*/{-1,-1},
    /*217*/{-1,-1},
    /*218*/{4,217,5,46,14,219,15,218,28,50,40,42,46,31,50,10,51,32,52,52,53,30,54,19,84,51,85,47,-1,-1},
    /*219*/{-1,-1},
    /*220*/{-1,-1},
    /*221*/{4,213,93,222,-1,-1},
    /*222*/{-1,-1},
    /*223*/{4,217,5,46,14,224,15,218,28,50,40,42,46,31,50,10,51,32,52,52,53,30,54,19,84,51,85,47,-1,-1},
    /*224*/{-1,-1},
    /*225*/{-1,-1},
    /*226*/{-1,-1},
    /*227*/{94,229,-1,-1},
    /*228*/{-1,-1},
    /*229*/{-1,-1},
    /*230*/{-1,-1},
    /*231*/{94,232,-1,-1},
    /*232*/{-1,-1},
    /*233*/{-1,-1},
    /*234*/{-1,-1},
    /*235*/{-1,-1},
    /*236*/{-1,-1},
    /*237*/{-1,-1},
    /*238*/{-1,-1},
    /*239*/{-1,-1},
    /*240*/{-1,-1},
    /*241*/{-1,-1},
    /*242*/{-1,-1},
    /*243*/{-1,-1},
    /*244*/{8,120,16,100,30,245,32,109,33,96,34,116,35,119,36,105,37,117,38,106,39,111,75,114,76,115,-1,-1},
    /*245*/{-1,-1},
    /*246*/{-1,-1},
    /*247*/{-1,-1},
    /*248*/{16,252,45,251,50,249,59,253,64,68,65,87,66,86,67,250,68,254,-1,-1},
    /*249*/{-1,-1},
    /*250*/{-1,-1},
    /*251*/{-1,-1},
    /*252*/{-1,-1},
    /*253*/{-1,-1},
    /*254*/{-1,-1},
    /*255*/{-1,-1},
    /*256*/{55,257,56,259,87,260,-1,-1},
    /*257*/{-1,-1},
    /*258*/{-1,-1},
    /*259*/{55,302,56,259,87,260,-1,-1},
    /*260*/{16,273,42,275,47,268,48,269,49,271,50,266,51,265,53,272,57,267,58,277,59,73,60,88,61,77,63,84,64,68,65,87,66,86,67,64,68,78,69,61,70,83,72,274,73,276,74,278,-1,-1},
    /*261*/{8,120,16,100,30,262,32,109,33,96,34,116,35,119,36,105,37,117,38,106,39,111,75,114,76,115,-1,-1},
    /*262*/{-1,-1},
    /*263*/{87,264,-1,-1},
    /*264*/{-1,-1},
    /*265*/{-1,-1},
    /*266*/{-1,-1},
    /*267*/{-1,-1},
    /*268*/{-1,-1},
    /*269*/{-1,-1},
    /*270*/{-1,-1},
    /*271*/{-1,-1},
    /*272*/{-1,-1},
    /*273*/{-1,-1},
    /*274*/{-1,-1},
    /*275*/{78,288,79,287,80,289,-1,-1},
    /*276*/{-1,-1},
    /*277*/{-1,-1},
    /*278*/{-1,-1},
    /*279*/{-1,-1},
    /*280*/{16,273,47,281,48,269,58,277,59,73,60,88,61,77,63,84,64,68,65,87,66,86,67,64,68,78,69,61,70,83,72,274,73,276,74,278,-1,-1},
    /*281*/{-1,-1},
    /*282*/{8,120,16,100,30,118,31,284,32,109,33,96,34,116,35,119,36,105,37,117,38,106,39,111,75,114,76,115,-1,-1},
    /*283*/{-1,-1},
    /*284*/{-1,-1},
    /*285*/{-1,-1},
    /*286*/{81,290,95,291,-1,-1},
    /*287*/{-1,-1},
    /*288*/{-1,-1},
    /*289*/{-1,-1},
    /*290*/{81,290,95,295,-1,-1},
    /*291*/{-1,-1},
    /*292*/{8,120,16,100,30,118,31,293,32,109,33,96,34,116,35,119,36,105,37,117,38,106,39,111,75,114,76,115,-1,-1},
    /*293*/{-1,-1},
    /*294*/{-1,-1},
    /*295*/{-1,-1},
    /*296*/{8,120,16,100,30,118,31,297,32,109,33,96,34,116,35,119,36,105,37,117,38,106,39,111,75,114,76,115,-1,-1},
    /*297*/{-1,-1},
    /*298*/{8,120,16,100,30,118,31,299,32,109,33,96,34,116,35,119,36,105,37,117,38,106,39,111,75,114,76,115,-1,-1},
    /*299*/{-1,-1},
    /*300*/{-1,-1},
    /*301*/{-1,-1},
    /*302*/{-1,-1},
    /*303*/{87,304,-1,-1},
    /*304*/{-1,-1},
    /*305*/{-1,-1},
    /*306*/{-1,-1},
    /*307*/{-1,-1},
    /*308*/{78,309,79,287,80,289,92,310,-1,-1},
    /*309*/{-1,-1},
    /*310*/{-1,-1},
    /*311*/{78,309,79,287,80,289,92,312,-1,-1},
    /*312*/{-1,-1},
    /*313*/{-1,-1},
    /*314*/{4,213,93,315,-1,-1},
    /*315*/{-1,-1},
    /*316*/{4,217,5,46,14,317,15,218,28,50,40,42,46,31,50,10,51,32,52,52,53,30,54,19,84,51,85,47,-1,-1},
    /*317*/{-1,-1},
    /*318*/{-1,-1},
    /*319*/{-1,-1},
    /*320*/{-1,-1},
    /*321*/{10,13,11,322,12,8,13,5,17,23,18,16,19,29,21,14,28,17,40,6,46,31,50,10,51,32,52,20,53,30,54,19,-1,-1},
    /*322*/{-1,-1},
    /*323*/{-1,-1},
    /*324*/{-1,-1},
    /*325*/{4,38,16,273,22,326,42,327,47,268,48,269,49,271,50,266,51,265,53,272,58,277,59,73,60,88,61,77,63,84,64,68,65,87,66,86,67,64,68,78,69,61,70,83,72,274,73,276,74,278,-1,-1},
    /*326*/{-1,-1},
    /*327*/{-1,-1},
    /*328*/{4,332,5,46,15,333,23,335,24,336,25,330,28,50,40,42,46,31,50,10,51,32,52,52,53,30,54,19,84,51,85,47,-1,-1},
    /*329*/{16,273,42,355,47,268,48,269,49,271,50,266,51,265,53,272,58,277,59,73,60,88,61,77,63,84,64,68,65,87,66,86,67,64,68,78,69,61,70,83,72,274,73,276,74,278,-1,-1},
    /*330*/{-1,-1},
    /*331*/{16,273,42,352,47,268,48,269,49,271,50,266,51,265,53,272,58,277,59,73,60,88,61,77,63,84,64,68,65,87,66,86,67,64,68,78,69,61,70,83,72,274,73,276,74,278,-1,-1},
    /*332*/{-1,-1},
    /*333*/{-1,-1},
    /*334*/{-1,-1},
    /*335*/{-1,-1},
    /*336*/{4,332,5,46,15,333,23,337,24,336,25,330,28,50,40,42,46,31,50,10,51,32,52,52,53,30,54,19,84,51,85,47,-1,-1},
    /*337*/{-1,-1},
    /*338*/{-1,-1},
    /*339*/{-1,-1},
    /*340*/{26,343,27,344,-1,-1},
    /*341*/{16,65,44,350,58,71,59,73,60,88,61,77,63,84,64,68,65,87,66,86,67,64,68,78,69,61,70,83,72,62,-1,-1},
    /*342*/{-1,-1},
    /*343*/{-1,-1},
    /*344*/{-1,-1},
    /*345*/{26,346,27,344,-1,-1},
    /*346*/{-1,-1},
    /*347*/{-1,-1},
    /*348*/{-1,-1},
    /*349*/{-1,-1},
    /*350*/{79,351,-1,-1},
    /*351*/{-1,-1},
    /*352*/{78,309,79,287,80,289,92,353,-1,-1},
    /*353*/{-1,-1},
    /*354*/{-1,-1},
    /*355*/{78,309,79,287,80,289,92,356,-1,-1},
    /*356*/{-1,-1},
    /*357*/{-1,-1},
    /*358*/{-1,-1},
    /*359*/{-1,-1},
    /*360*/{-1,-1},
    /*361*/{16,273,42,363,47,268,48,269,49,271,50,266,51,265,53,272,58,277,59,73,60,88,61,77,63,84,64,68,65,87,66,86,67,64,68,78,69,61,70,83,72,274,73,276,74,278,77,364,86,362,-1,-1},
    /*362*/{-1,-1},
    /*363*/{78,309,79,287,80,289,92,366,-1,-1},
    /*364*/{16,273,42,363,47,268,48,269,49,271,50,266,51,265,53,272,58,277,59,73,60,88,61,77,63,84,64,68,65,87,66,86,67,64,68,78,69,61,70,83,72,274,73,276,74,278,77,364,86,365,-1,-1},
    /*365*/{-1,-1},
    /*366*/{-1,-1},
    /*367*/{-1,-1},
    /*368*/{-1,-1},
    /*369*/{-1,-1},
    /*370*/{16,273,42,363,47,268,48,269,49,271,50,266,51,265,53,272,58,277,59,73,60,88,61,77,63,84,64,68,65,87,66,86,67,64,68,78,69,61,70,83,72,274,73,276,74,278,77,364,86,371,-1,-1},
    /*371*/{-1,-1},
    /*372*/{-1,-1},
    /*373*/{-1,-1},
    /*374*/{-1,-1},
    /*375*/{-1,-1},
    /*376*/{4,38,22,377,-1,-1},
    /*377*/{-1,-1},
    /*378*/{4,332,5,46,15,333,23,379,24,336,25,330,28,50,40,42,46,31,50,10,51,32,52,52,53,30,54,19,84,51,85,47,-1,-1},
    /*379*/{-1,-1},
    /*380*/{-1,-1},
    /*381*/{-1,-1},
    /*382*/{-1,-1},
  };

  /** access to reduce_goto table */
  public short[][] reduce_table() {return _reduce_table;}

  /** instance of action encapsulation class */
  protected CUP$actions action_obj;

  /** action encapsulation object initializer */
  protected void init_actions()
    {
      action_obj = new CUP$actions();
    }

  /** invoke a user supplied parse action */
  public java_cup.runtime.symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$do_action(act_num, parser, stack, top);
  }

  /** start state */
  public int start_state() {return 0;}
  /** start production */
  public int start_production() {return 0;}

  /** EOF symbol index */
  public int EOF_sym() {return 0;}

  /** error symbol index */
  public int error_sym() {return 1;}


  /** user initialization */
  public void user_init() throws java.lang.Exception
    {
 
        lexer.init(); 

    }

  /** scan to get the next token */
  public java_cup.runtime.token scan()
    throws java.lang.Exception
    {
 
        return lexer.next_token(); 

    }



    static String command_line[] = null;

    public static Vector import_list = new Vector();
    public static Hashtable pack_replace = new Hashtable();
    public static Stack scopes = new Stack();

    public static String currentVersion = "";
    public static String compiler_version = "1.3.20, 26 March 2001";

    static String out_dir = "."; 
    static String package_prefix = null;

    static boolean parse_only = false;
    static boolean global_import = false;

    /** compiler flags */
    public static boolean include_state = false;
    public static boolean generateIR = false;
    public static boolean generate_skeletons = true;
    public static boolean generate_stubs = true;

    private static boolean generateIncluded = false;
    private static boolean inhibitionState = false;
    private static boolean localityContraint = false;

    /*  a la CORBA 2.4, allow forward declarations that remain undefined */
    public static boolean sloppy = false;

    /**
     *  allows reinitialization if compiler is not 
     *  run from a command-line
     */

    private static void init()
    {
        command_line = null;
        import_list = new Vector();
        pack_replace = new Hashtable();
        scopes = new Stack();

        out_dir = "."; 
        package_prefix = null;

        parse_only = false;
        global_import = false;

        include_state = false;
        generateIR = false;
        generate_skeletons = true;

        generateIncluded = false;
        boolean inhibitionState = false;
        boolean localityContraint = false;
    }

    public static void main( String argv[] ) 
    {
        init();
        boolean result = compile( argv );
    }

    
    public static boolean compile( String argv[] ) 
    {
        init();
        try
        {
           command_line = argv;
           if( argv.length > 0 )
           {
                int i;
                for( i = 0; i < argv.length; i++ )
                {
                        if( argv[i].equals("-syntax"))
                        {
                                parse_only = true;
                                continue;
                        } 
                        if( argv[i].equals("-global_import"))
                        {
                                global_import = true;
                                continue;
                        } 
                        if( argv[i].equals("-noskel"))
                        {
                                generate_skeletons = false;
                                continue;
                        } 
                        if( argv[i].equals("-nostub"))
                        {
                                generate_stubs = false;
                                continue;
                        } 
                        if( argv[i].equals("-sloppy_forward"))
                        {
                                sloppy = true;
                                continue;
                        } 
                        if( argv[i].equals("-d")) 
                        {
                                if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                                        usage(argv, "-d");
                                out_dir = argv[++i];
                                continue;
                        } 
                        if( argv[i].equals("-W")) 
                        {
                                if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                                        usage(argv, "-W");
                                org.jacorb.idl.Environment.verbosityLevel(Integer.parseInt( argv[++i]));
                                continue;
                        } 
                        if( argv[i].startsWith("-D")) 
                        {
                                String def = argv[i].substring(2);
                                String val;

                                if( def.indexOf('=') > 0 )
                                {
                                        val = def.substring( def.indexOf('=') + 1);
                                        def = def.substring( 0, def.indexOf('='));
                                }
                                else
                                        val = "1";
                                lexer.define( def, val );
                                continue;
                        }
                        if( argv[i].startsWith("-U")) 
                        {
                                lexer.undefine(argv[i].substring(2) );
                                continue;
                        } 
                        if( argv[i].equals("-p")) 
                        {
                                if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                                        usage(argv, "-p");
                                package_prefix = argv[++i];
                                continue;
                        } 
                        if( argv[i].equals("-i2jpackage")) 
                        {
                                if( i+1 == argv.length || argv[i+1].charAt(0)=='-')
                                        usage(argv, "-i2jpackage");

                                int split_idx = argv[i+1].indexOf(':');
                                if( split_idx  < 0 )
                                        usage(argv, "-i2jpackage");
                                String idlp = argv[i+1].substring(0,split_idx);
                                String jp = argv[i+1].substring(split_idx+1);

                                pack_replace.put( idlp, jp );
                                Environment.output(3,"Replace pack " + idlp + " with " + jp );
                                i++;
                                continue;
                        } 
                        if( argv[i].equals("-ir")) 
                        {  
                              generateIR = true;
                              continue;
                        } 
                        if( argv[i].equals("-i")) 
                        {
                                if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                                        usage(argv, "-i");
                                import_list.addElement( argv[++i]) ;
                                continue;
                        } 
                        if( argv[i].startsWith("-I")) 
                        {
                                GlobalInputStream.setIncludePath(argv[i].substring(2));
                                continue;
                        }
                        if( argv[i].equals("-h") || argv[i].equals("-help") )
                        {
                                help();
                                System.exit(0);
                        }
                        if( argv[i].equals("-all"))
                        {
                                generateIncluded = true;
                                continue;
                        }
                        if( argv[i].equals("-v") || argv[i].equals("-version"))
                        {
                                version();
                                System.exit(0);
                        }
                        if( argv[i].endsWith(".idl"))
                        {
                                break;
                        }

                        // else:
                        usage(argv, "Unrecognized option");

                   }
                   for( int j=i; j < argv.length; j++)
                   {
                        if( argv[j].endsWith(".idl"))
                        {
                                Environment.output(4,argv[j]);
                                GlobalInputStream.init();
                                try
                                {               
                                    GlobalInputStream.setInput( argv[j] );
                                }       
                                catch (java.io.IOException io )
                                {
                                    System.err.println("Could not find file " + argv[j]);
                                    parser.help();
                                }
                                new parser().parse();
                        }
                        else
                        {
                                System.err.println("Not an IDL file:" + argv[j]);
                        }
                    }
                }
           }
           catch( org.jacorb.idl.ParseException e )
           {
              return false;
           }
           catch( Exception e )
           {
              System.err.println( e.getMessage());
              // e.printStackTrace();
              usage(argv, e.getMessage());
           }
           return true;
    }

    public static void usage(String [] argv, String msg)
    {
        // debug:
        for( int i = 0; i < argv.length; i++)
            System.out.print( argv[i] + " " );
        System.out.println(" : " + msg);

        System.out.println("Usage: idl [-h|-help][-v|-version][-syntax][-all][-Idir][-Dsymbol[=value]][-U <symbol>][-noskel][-nostub][-ir] [-i2jpackage x:y][-d <Output Dir>][-p <package_prefix>][-i <import_package][-W debug_level] <filelist>");
        System.exit(1);
    }

    private static void help()
    {     
        System.out.println("\t-syntax\tsyntax check only, no code generation, implies -no_ir");
//ystem.out.println("\t-no_ir\tdo not generate information for the Interface Repository");
        System.out.println("\t-noskel\tdisables generation of POA skeletons");
        System.out.println("\t-nostub\tdisables generation of client stubs");
        System.out.println("\t-Idir\tset include path for idl files");
        System.out.println("\t-sloppy_forward\tallow forward declarations wo. later definitions");
        System.out.println("\t-Dx\tdefine preprocessor symbol x with value 1");
        System.out.println("\t-Dx=y\tdefine preprocessor symbol x with value y");
        System.out.println("\t-U\tundefine preprocessor symbol");
        System.out.println("\t-p pack\tapply pack as prefix to all names in generated Java code");
        System.out.println("\t\t\tand put code into package <pack>");
        System.out.println("\t-i2jpackage x:a.b.c\t replace IDL package name x by a.b.c in generated Java code (e.g. CORBA:org.omg.CORBA)");
        System.out.println("\t-i <x>\tgenerated Java code will include \"import <x>;\"");
        System.out.println("\t-ir <x>\tgenerate information required by the Interface Repository");
        System.out.println("\t-global_import \tgenerated Java code will include import statements for all global types");
        System.out.println("\t-d dir\troot of directory tree for output");
        System.out.println("\t-W [1..4]\tdebug level");
        System.out.println("\t-all generate code for all IDL files, even included ones");
        System.out.println("\t-v|version \tprint version information");
        System.out.println("\t-h|help \tthese few lines of help");
        System.out.println("\t<filelist>\t");
  }

  private static void version()
  {
        System.out.println("JacORB IDL compiler V" + compiler_version + ",\n   (C) Gerald Brose, FU Berlin, 1997-2001.");
  }


  /* override error routines */

    public void report_fatal_error( String message, Object info)
        throws ParseException
    {
       done_parsing();
       lexer.emit_error(message);
       System.err.println("Can't recover from previous error(s), giving up.");
       throw new ParseException();
       // System.exit(1);
    }

    public static void fatal_error(String message, str_token p_info)
        throws ParseException
    {
       //done_parsing();
       lexer.emit_error(message, p_info);
       System.err.println("Can't recover from previous error(s), giving up.");
       throw new ParseException();
       // System.exit(1);
    }

    public void report_error(String message, Object info)
    {
       lexer.emit_error(message);
    }

    public static void error(String message, str_token p_info)
    {
       lexer.emit_error(message, p_info);
    }




        /* bookkeeping with IDL scopes */

        /** called from the lexer/scanner whenever a scope opening
            symbol is encountered */

        public static void openScope()
        {
            scopes.push(new ScopeData());
        }

        /** called from within the parser whenever parsing a scope 
            symbol is complete */

        public static void closeScope(Scope symbol)
        {
                ScopeData data = (ScopeData) scopes.pop();
                symbol.setScopeData( data );
        }

        public static ScopeData currentScopeData()
        {
                return (ScopeData)scopes.peek();
        }


        // an interface inheriting from an forward declared interface
        // needs to wait on an object until the ancestor has been parsed
        // if get_pending returns null, the ancestor was not forward 
        // declared and thus has already been parsed

        // forward declared interfaces are put into this list

    public static java.util.Hashtable pending_interfaces = new java.util.Hashtable();

    public static synchronized void set_pending( String name )
    {
           // name will only be marked pending if it has not already been
           // parsed before and if is not already pending
           if( ! ( pending_interfaces.containsKey(name) ||
                   NameTable.parsed_interfaces.containsKey(name)) )
           {
                   pending_interfaces.put(name,new Object());
           }
    }

    public static synchronized void remove_pending( String name )
    {
        Object o = pending_interfaces.remove(name);
        if( o!= null) 
        {
                synchronized(o)
                { 
                        o.notifyAll();
                }
        }
        if( pending_interfaces.size() == 0 )
                // notify the main thread that the parsing phase is complete
                synchronized( pending_interfaces )
                {
                        pending_interfaces.notifyAll();
                }
       }


        public static boolean generateIncluded()
        {
                return generateIncluded;
        }

        /**
         * sets locality constraint
         */

        public static void setLocalityContraint()
        {
                localityContraint = true;
        }

    /**
      * return the current locality constraint, resets constraint
      */

    public static boolean getLocalityContraint()
    {
        boolean result = localityContraint;
        localityContraint = false;
        return result;
    }

    public static boolean getInhibitionState()
    {
        return inhibitionState;
    }

    public static void setInhibitionState(boolean flag)
    {
        inhibitionState = flag;
    }

    public static void set_included( boolean i )
    {
        include_state = i;
    }

    public static synchronized Object get_pending( String name )
    {
        return pending_interfaces.get(name);
    }

    public static boolean hasImports()
    {
        return import_list.size() > 0 ;
    }

    static void addGlobalNamesToImport()
    {
        for( Enumeration e = NameTable.getGlobalTypes(); 
                e.hasMoreElements(); )
        {
                String s = (String) e.nextElement();
                import_list.addElement( s );
                Environment.output(4,"Adding import for global name " + s );
        }       
    }


    /** 
     * Package replacements as requested
     * by compiler options
     */

    public static String pack_replace(String old)
    {
        String n_str = (String)pack_replace.get(old);
        if( n_str == null )
            return old;
        else
            return n_str;
    }


};

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$actions {




  /** Constructor */
  CUP$actions() { }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.symbol CUP$do_action(
    int                        CUP$act_num,
    java_cup.runtime.lr_parser CUP$parser,
    java.util.Stack            CUP$stack,
    int                        CUP$top)
    throws java.lang.Exception
    {
      /* object for return from actions */
      java_cup.runtime.symbol CUP$result;

      /* select the action based on the action number */
      switch (CUP$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // empty ::= 
            {
              CUP$result = new java_cup.runtime.symbol(/*empty*/4);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // param_type_spec ::= scopename 
            {
              CUP$result = new TypeSpec(/*param_type_spec*/44);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // param_type_spec ::= string_type 
            {
              CUP$result = new TypeSpec(/*param_type_spec*/44);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(StringType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // param_type_spec ::= base_type_spec 
            {
              CUP$result = new TypeSpec(/*param_type_spec*/44);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(BaseType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // string_literal_list ::= string_literal COMMA string_literal_list 
            {
              CUP$result = new java_cup.runtime.symbol(/*string_literal_list*/3);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // string_literal_list ::= string_literal 
            {
              CUP$result = new java_cup.runtime.symbol(/*string_literal_list*/3);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // context_expr ::= empty 
            {
              CUP$result = new java_cup.runtime.symbol(/*context_expr*/2);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // context_expr ::= CONTEXT LPAREN string_literal_list RPAREN 
            {
              CUP$result = new java_cup.runtime.symbol(/*context_expr*/2);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // raises_expr ::= empty 
            {
              CUP$result = new RaisesExpr(/*raises_expr*/83);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // raises_expr ::= RAISES LPAREN scopename_list RPAREN 
            {
              CUP$result = new RaisesExpr(/*raises_expr*/83);
               
                ((RaisesExpr)CUP$result).nameList = (Vector)(/*snl*/(SymbolList)CUP$stack.elementAt(CUP$top-1)).v.clone(); 
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // param_attribute ::= INOUT 
            {
              CUP$result = new java_cup.runtime.int_token(/*param_attribute*/6);
               ((java_cup.runtime.int_token)CUP$result).int_val = 3; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // param_attribute ::= OUT 
            {
              CUP$result = new java_cup.runtime.int_token(/*param_attribute*/6);
               ((java_cup.runtime.int_token)CUP$result).int_val = 2; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // param_attribute ::= IN 
            {
              CUP$result = new java_cup.runtime.int_token(/*param_attribute*/6);
               ((java_cup.runtime.int_token)CUP$result).int_val = 1; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // param_dcl ::= param_attribute param_type_spec simple_declarator 
            {
              CUP$result = new ParamDecl(/*param_dcl*/82);
               
                ((ParamDecl)CUP$result).paramAttribute = (/*pa*/(java_cup.runtime.int_token)CUP$stack.elementAt(CUP$top-2)).int_val;
                ((ParamDecl)CUP$result).paramTypeSpec = (/*pts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                ((ParamDecl)CUP$result).simple_declarator = (/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0));
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // param_dcls ::= param_dcl 
            {
              CUP$result = new SymbolList(/*param_dcls*/88);
               
                        ((SymbolList)CUP$result).v.insertElementAt((/*pd*/(ParamDecl)CUP$stack.elementAt(CUP$top-0)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // param_dcls ::= param_dcl COMMA param_dcls 
            {
              CUP$result = new SymbolList(/*param_dcls*/88);
               
                        ((SymbolList)CUP$result).v = (Vector)(/*pds*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone(); 
                        ((SymbolList)CUP$result).v.insertElementAt((/*pd*/(ParamDecl)CUP$stack.elementAt(CUP$top-2)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // parameter_dcls ::= LPAREN RPAREN 
            {
              CUP$result = new SymbolList(/*parameter_dcls*/89);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // parameter_dcls ::= LPAREN param_dcls RPAREN 
            {
              CUP$result = new SymbolList(/*parameter_dcls*/89);
               
                        ((SymbolList)CUP$result).v = (Vector)(/*pds*/(SymbolList)CUP$stack.elementAt(CUP$top-1)).v.clone(); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // void_type_spec ::= VOID 
            {
              CUP$result = new VoidTypeSpec(/*void_type_spec*/71);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // op_type_spec ::= void_type_spec 
            {
              CUP$result = new TypeSpec(/*op_type_spec*/43);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(VoidTypeSpec)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // op_type_spec ::= param_type_spec 
            {
              CUP$result = new TypeSpec(/*op_type_spec*/43);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(TypeSpec)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // op_attribute ::= empty 
            {
              CUP$result = new java_cup.runtime.int_token(/*op_attribute*/5);
               ((java_cup.runtime.int_token)CUP$result).int_val = 0; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // op_attribute ::= ONEWAY 
            {
              CUP$result = new java_cup.runtime.int_token(/*op_attribute*/5);
               ((java_cup.runtime.int_token)CUP$result).int_val = 1; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // op_dcl ::= op_attribute op_type_spec ID parameter_dcls raises_expr context_expr 
            {
              CUP$result = new OpDecl(/*op_dcl*/84);
               
                        ((OpDecl)CUP$result).opAttribute = (/*oa*/(java_cup.runtime.int_token)CUP$stack.elementAt(CUP$top-5)).int_val;
                        ((OpDecl)CUP$result).opTypeSpec = (/*ots*/(TypeSpec)CUP$stack.elementAt(CUP$top-4));
                        ((OpDecl)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));    
                        ((OpDecl)CUP$result).paramDecls = (Vector)(/*pds*/(SymbolList)CUP$stack.elementAt(CUP$top-2)).v.clone();
                        ((OpDecl)CUP$result).raisesExpr = (/*re*/(RaisesExpr)CUP$stack.elementAt(CUP$top-1));
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // except_dcl ::= EXCEPTION ID LCBRACE member_list RCBRACE 
            {
              CUP$result = new StructType(/*except_dcl*/52);
               
                        ((StructType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));    
                        ((StructType)CUP$result).exc = true;
                        ((StructType)CUP$result).set_memberlist( (/*ml*/(MemberList)CUP$stack.elementAt(CUP$top-1)) );
                        ((StructType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((StructType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // except_dcl ::= EXCEPTION ID LCBRACE RCBRACE 
            {
              CUP$result = new StructType(/*except_dcl*/52);
               
                        ((StructType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)));    
                        ((StructType)CUP$result).exc = true;
                        ((StructType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((StructType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // simple_declarator_list ::= simple_declarator COMMA simple_declarator_list 
            {
              CUP$result = new SymbolList(/*simple_declarator_list*/91);
               
                        ((SymbolList)CUP$result).v = (Vector)(/*sdl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-2)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // simple_declarator_list ::= simple_declarator 
            {
              CUP$result = new SymbolList(/*simple_declarator_list*/91);
               
                        ((SymbolList)CUP$result).v.insertElementAt((/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // attr_dcl ::= ATTRIBUTE param_type_spec simple_declarator_list 
            {
              CUP$result = new AttrDecl(/*attr_dcl*/85);
              
                        ((AttrDecl)CUP$result).readOnly = false;
                        ((AttrDecl)CUP$result).param_type_spec = (/*pts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((AttrDecl)CUP$result).declarators = (/*sdl*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // attr_dcl ::= READONLY ATTRIBUTE param_type_spec simple_declarator_list 
            {
              CUP$result = new AttrDecl(/*attr_dcl*/85);
              
                        ((AttrDecl)CUP$result).readOnly = true;
                        ((AttrDecl)CUP$result).param_type_spec = (/*pts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((AttrDecl)CUP$result).declarators = (/*sdl*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // fixed_array_size ::= LSBRACE positive_int_const RSBRACE 
            {
              CUP$result = new FixedArraySize(/*fixed_array_size*/81);
               
                        ((FixedArraySize)CUP$result).pos_int_const = (/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // fixed_array_size_list ::= fixed_array_size fixed_array_size_list 
            {
              CUP$result = new SymbolList(/*fixed_array_size_list*/95);
               
                        ((SymbolList)CUP$result).v = (Vector)(/*fasl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*fas*/(FixedArraySize)CUP$stack.elementAt(CUP$top-1)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // fixed_array_size_list ::= fixed_array_size 
            {
              CUP$result = new SymbolList(/*fixed_array_size_list*/95);
               
                        ((SymbolList)CUP$result).v.insertElementAt((/*fas*/(FixedArraySize)CUP$stack.elementAt(CUP$top-0)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // array_declarator ::= ID fixed_array_size_list 
            {
              CUP$result = new ArrayDeclarator(/*array_declarator*/80);
               
                        ((ArrayDeclarator)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)));    
                        ((ArrayDeclarator)CUP$result).fixed_array_size_list = (/*fasl*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // fixed_point_type ::= FIXED LESSTHAN positive_int_const COMMA positive_int_const GREATERTHAN 
            {
              CUP$result = new FixedPointType(/*fixed_point_type*/74);
               
                ((FixedPointType)CUP$result).digit_expr = (/*digits*/(PosIntConst)CUP$stack.elementAt(CUP$top-3)).const_expr;
                ((FixedPointType)CUP$result).scale_expr = (/*scale*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr;
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // string_type ::= WSTRING 
            {
              CUP$result = new StringType(/*string_type*/72);
               ((StringType)CUP$result).setWide(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // string_type ::= STRING 
            {
              CUP$result = new StringType(/*string_type*/72);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // string_type ::= WSTRING LESSTHAN positive_int_const GREATERTHAN 
            {
              CUP$result = new StringType(/*string_type*/72);
               
                ((StringType)CUP$result).max = (/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr; 
                ((StringType)CUP$result).setWide();
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // string_type ::= STRING LESSTHAN positive_int_const GREATERTHAN 
            {
              CUP$result = new StringType(/*string_type*/72);
               ((StringType)CUP$result).max = (/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // sequence_type ::= SEQUENCE LESSTHAN simple_type_spec GREATERTHAN 
            {
              CUP$result = new SequenceType(/*sequence_type*/73);
              
                        ((SequenceType)CUP$result).setTypeSpec( (/*sts*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-1)) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // sequence_type ::= SEQUENCE LESSTHAN simple_type_spec COMMA positive_int_const GREATERTHAN 
            {
              CUP$result = new SequenceType(/*sequence_type*/73);
              
                        ((SequenceType)CUP$result).max = (/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr;
                        ((SequenceType)CUP$result).setTypeSpec( (/*sts*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-3)) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // native_type ::= NATIVE simple_declarator 
            {
              CUP$result = new NativeType(/*native_type*/54);
              
                        ((NativeType)CUP$result).declarator = (/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // enumerator_list ::= ID COMMA enumerator_list 
            {
              CUP$result = new SymbolList(/*enumerator_list*/94);
               
                        ((SymbolList)CUP$result).v = (Vector)(/*el*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)).str_val,0); 
                        ((SymbolList)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)));    
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // enumerator_list ::= ID 
            {
              CUP$result = new SymbolList(/*enumerator_list*/94);
               
                        ((SymbolList)CUP$result).v.insertElementAt((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val,0); 
                        ((SymbolList)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));    
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // enum_type ::= ENUM ID LCBRACE enumerator_list RCBRACE 
            {
              CUP$result = new EnumType(/*enum_type*/50);
               
                        ((EnumType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));    
                        ((EnumType)CUP$result).enumlist = (/*el*/(SymbolList)CUP$stack.elementAt(CUP$top-1));
                        ((EnumType)CUP$result).set_included( parser.include_state );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // element_spec ::= type_spec declarator 
            {
              CUP$result = new ElementSpec(/*element_spec*/57);
              
                        ((ElementSpec)CUP$result).t.type_spec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((ElementSpec)CUP$result).d = (/*dc*/(Declarator)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // case_label_list ::= DEFAULT COLON case_label_list 
            {
              CUP$result = new SymbolList(/*case_label_list*/87);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*cll*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.addElement(null);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // case_label_list ::= CASE const_expr COLON case_label_list 
            {
              CUP$result = new SymbolList(/*case_label_list*/87);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*cll*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.addElement((/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-2)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // case_label_list ::= DEFAULT COLON 
            {
              CUP$result = new SymbolList(/*case_label_list*/87);
               ((SymbolList)CUP$result).v.addElement( null ); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // case_label_list ::= CASE const_expr COLON 
            {
              CUP$result = new SymbolList(/*case_label_list*/87);
               ((SymbolList)CUP$result).v.addElement((/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // case ::= case_label_list element_spec SEMI 
            {
              CUP$result = new Case(/*case*/56);
              
                        ((Case)CUP$result).element_spec = (/*es*/(ElementSpec)CUP$stack.elementAt(CUP$top-1));
                        ((Case)CUP$result).case_label_list = (/*c*/(SymbolList)CUP$stack.elementAt(CUP$top-2));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // switch_body ::= case switch_body 
            {
              CUP$result = new SwitchBody(/*switch_body*/55);
              
                ((SwitchBody)CUP$result).v = (Vector)(/*sb*/(SwitchBody)CUP$stack.elementAt(CUP$top-0)).v.clone();
                ((SwitchBody)CUP$result).v.addElement((/*c*/(Case)CUP$stack.elementAt(CUP$top-1)));
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // switch_body ::= case 
            {
              CUP$result = new SwitchBody(/*switch_body*/55);
              
                ((SwitchBody)CUP$result).v.addElement((/*c*/(Case)CUP$stack.elementAt(CUP$top-0)));
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // switch_type_spec ::= scopename 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // switch_type_spec ::= enum_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).set_constr((/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // switch_type_spec ::= bool_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).type_spec = (/*b*/(BooleanType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // switch_type_spec ::= char_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).type_spec = (/*c*/(CharType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // switch_type_spec ::= int_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).type_spec = (/*i*/(IntType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // union_type ::= UNION ID SWITCH LPAREN switch_type_spec RPAREN LCBRACE switch_body RCBRACE 
            {
              CUP$result = new UnionType(/*union_type*/53);
               
                        ((UnionType)CUP$result).setSwitchType( (/*s*/(TypeSpec)CUP$stack.elementAt(CUP$top-4)) ); 
                        ((UnionType)CUP$result).setSwitchBody( (/*sb*/(SwitchBody)CUP$stack.elementAt(CUP$top-1)) ); 
                        ((UnionType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-7)));
                        ((UnionType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((UnionType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // member ::= type_spec declarators SEMI 
            {
              CUP$result = new Member(/*member*/77);
               
                        ((Member)CUP$result).type_spec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-2));
                        ((Member)CUP$result).declarators = (/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-1));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // member_list ::= member member_list 
            {
              CUP$result = new MemberList(/*member_list*/86);
               
                        ((MemberList)CUP$result).v = (Vector)(/*ml*/(MemberList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((MemberList)CUP$result).v.insertElementAt((/*m*/(Member)CUP$stack.elementAt(CUP$top-1)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // member_list ::= member 
            {
              CUP$result = new MemberList(/*member_list*/86);
               
                        ((MemberList)CUP$result).v.insertElementAt((/*m*/(Member)CUP$stack.elementAt(CUP$top-0)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // struct_type ::= STRUCT ID LCBRACE member_list RCBRACE 
            {
              CUP$result = new StructType(/*struct_type*/51);
               
                        ((StructType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));    
                        ((StructType)CUP$result).exc = false;
                        ((StructType)CUP$result).set_memberlist( (/*ml*/(MemberList)CUP$stack.elementAt(CUP$top-1)) );
                        ((StructType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((StructType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // any_type ::= ANY 
            {
              CUP$result = new AnyType(/*any_type*/70);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // octet_type ::= OCTET 
            {
              CUP$result = new OctetType(/*octet_type*/69);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // bool_type ::= BOOLEAN 
            {
              CUP$result = new BooleanType(/*bool_type*/68);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // char_type ::= WCHAR 
            {
              CUP$result = new CharType(/*char_type*/67);
               ((CharType)CUP$result).setWide(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // char_type ::= CHAR 
            {
              CUP$result = new CharType(/*char_type*/67);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // long_long_type ::= LONG LONG 
            {
              CUP$result = new LongLongType(/*long_long_type*/66);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // long_type ::= LONG 
            {
              CUP$result = new LongType(/*long_type*/65);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // short_type ::= SHORT 
            {
              CUP$result = new ShortType(/*short_type*/64);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // int_type ::= UNSIGNED short_type 
            {
              CUP$result = new IntType(/*int_type*/59);
               
                        ((IntType)CUP$result).type_spec = (/*s*/(ShortType)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // int_type ::= short_type 
            {
              CUP$result = new IntType(/*int_type*/59);
               
                        ((IntType)CUP$result).type_spec = (/*s*/(ShortType)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // int_type ::= UNSIGNED long_long_type 
            {
              CUP$result = new IntType(/*int_type*/59);
               
                        ((IntType)CUP$result).type_spec = (/*l*/(LongLongType)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // int_type ::= UNSIGNED long_type 
            {
              CUP$result = new IntType(/*int_type*/59);
               
                        ((IntType)CUP$result).type_spec = (/*l*/(LongType)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // int_type ::= long_long_type 
            {
              CUP$result = new IntType(/*int_type*/59);
               
                        ((IntType)CUP$result).type_spec = (/*ll*/(LongLongType)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // int_type ::= long_type 
            {
              CUP$result = new IntType(/*int_type*/59);
               
                        ((IntType)CUP$result).type_spec = (/*l*/(LongType)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // double_type ::= DOUBLE 
            {
              CUP$result = new DoubleType(/*double_type*/63);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // fixed_pt_const_type ::= FIXED 
            {
              CUP$result = new FixedPointConstType(/*fixed_pt_const_type*/62);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // float_type ::= FLOAT 
            {
              CUP$result = new FloatType(/*float_type*/61);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // float_pt_type ::= double_type 
            {
              CUP$result = new FloatPtType(/*float_pt_type*/60);
              ((FloatPtType)CUP$result).type_spec = (/*d*/(DoubleType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // float_pt_type ::= float_type 
            {
              CUP$result = new FloatPtType(/*float_pt_type*/60);
              ((FloatPtType)CUP$result).type_spec = (/*f*/(FloatType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // simple_declarator ::= ID 
            {
              CUP$result = new SimpleDeclarator(/*simple_declarator*/79);
               
                        ((SimpleDeclarator)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));    
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // declarator ::= array_declarator 
            {
              CUP$result = new Declarator(/*declarator*/78);
               ((Declarator)CUP$result).d = (/*s*/(ArrayDeclarator)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // declarator ::= simple_declarator 
            {
              CUP$result = new Declarator(/*declarator*/78);
               ((Declarator)CUP$result).d = (/*s*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // declarators ::= declarator 
            {
              CUP$result = new SymbolList(/*declarators*/92);
               
                        ((SymbolList)CUP$result).v.insertElementAt((/*d*/(Declarator)CUP$stack.elementAt(CUP$top-0)),0);
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // declarators ::= declarator COMMA declarators 
            {
              CUP$result = new SymbolList(/*declarators*/92);
               
                        ((SymbolList)CUP$result).v = (Vector)(/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*d*/(Declarator)CUP$stack.elementAt(CUP$top-2)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // constr_type_spec ::= enum_type 
            {
              CUP$result = new ConstrTypeSpec(/*constr_type_spec*/49);
               
                        ((ConstrTypeSpec)CUP$result).c_type_spec = (/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0)); 
                        ((ConstrTypeSpec)CUP$result).set_token((/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // constr_type_spec ::= union_type 
            {
              CUP$result = new ConstrTypeSpec(/*constr_type_spec*/49);
               
                        ((ConstrTypeSpec)CUP$result).c_type_spec = (/*u*/(UnionType)CUP$stack.elementAt(CUP$top-0)); 
                        ((ConstrTypeSpec)CUP$result).set_token((/*u*/(UnionType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // constr_type_spec ::= struct_type 
            {
              CUP$result = new ConstrTypeSpec(/*constr_type_spec*/49);
               
                        ((ConstrTypeSpec)CUP$result).c_type_spec = (/*s*/(StructType)CUP$stack.elementAt(CUP$top-0)); 
                        ((ConstrTypeSpec)CUP$result).set_token((/*s*/(StructType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // template_type_spec ::= fixed_point_type 
            {
              CUP$result = new TemplateTypeSpec(/*template_type_spec*/48);
               
                        ((TemplateTypeSpec)CUP$result).type_spec = (/*f*/(FixedPointType)CUP$stack.elementAt(CUP$top-0)); 
                        ((TemplateTypeSpec)CUP$result).set_token((/*f*/(FixedPointType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // template_type_spec ::= string_type 
            {
              CUP$result = new TemplateTypeSpec(/*template_type_spec*/48);
               
                        ((TemplateTypeSpec)CUP$result).type_spec = (/*s*/(StringType)CUP$stack.elementAt(CUP$top-0)); 
                        ((TemplateTypeSpec)CUP$result).set_token((/*s*/(StringType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // template_type_spec ::= sequence_type 
            {
              CUP$result = new TemplateTypeSpec(/*template_type_spec*/48);
               
                        ((TemplateTypeSpec)CUP$result).type_spec = (/*s*/(SequenceType)CUP$stack.elementAt(CUP$top-0)); 
                        ((TemplateTypeSpec)CUP$result).set_token((/*s*/(SequenceType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // base_type_spec ::= VALUEBASE 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // base_type_spec ::= any_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(AnyType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // base_type_spec ::= octet_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(OctetType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // base_type_spec ::= bool_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(BooleanType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // base_type_spec ::= char_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(CharType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // base_type_spec ::= int_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               
                        ((BaseType)CUP$result).type_spec = (/*s*/(IntType)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // base_type_spec ::= float_pt_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(FloatPtType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // simple_type_spec ::= scopename 
            {
              CUP$result = new SimpleTypeSpec(/*simple_type_spec*/47);
               
                        ((SimpleTypeSpec)CUP$result).type_spec = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
                        ((SimpleTypeSpec)CUP$result).set_token((/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // simple_type_spec ::= template_type_spec 
            {
              CUP$result = new SimpleTypeSpec(/*simple_type_spec*/47);
               
                        ((SimpleTypeSpec)CUP$result).type_spec = (/*s*/(TemplateTypeSpec)CUP$stack.elementAt(CUP$top-0)); 
                        ((SimpleTypeSpec)CUP$result).set_token((/*s*/(TemplateTypeSpec)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // simple_type_spec ::= base_type_spec 
            {
              CUP$result = new SimpleTypeSpec(/*simple_type_spec*/47);
               
                        ((SimpleTypeSpec)CUP$result).type_spec = (/*s*/(BaseType)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // type_spec ::= constr_type_spec 
            {
              CUP$result = new TypeSpec(/*type_spec*/42);
               
                        ((TypeSpec)CUP$result).type_spec = (/*s*/(ConstrTypeSpec)CUP$stack.elementAt(CUP$top-0)); 
                        ((TypeSpec)CUP$result).set_token((/*s*/(ConstrTypeSpec)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // type_spec ::= simple_type_spec 
            {
              CUP$result = new TypeSpec(/*type_spec*/42);
               
                        ((TypeSpec)CUP$result).type_spec = (/*s*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-0)); 
                        ((TypeSpec)CUP$result).set_token((/*s*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // type_declarator ::= type_spec declarators 
            {
              CUP$result = new TypeDeclarator(/*type_declarator*/41);
              
                        ((TypeDeclarator)CUP$result).type_spec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((TypeDeclarator)CUP$result).declarators = (/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // type_def ::= TYPEDEF type_declarator 
            {
              CUP$result = new TypeDef(/*type_def*/46);
               
                ((TypeDef)CUP$result).type_declarator = (/*t*/(TypeDeclarator)CUP$stack.elementAt(CUP$top-0)); 
                ((TypeDef)CUP$result).set_included( parser.include_state );
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // type_dcl ::= native_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*n*/(NativeType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // type_dcl ::= enum_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // type_dcl ::= union_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*u*/(UnionType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // type_dcl ::= struct_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*s*/(StructType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // type_dcl ::= type_def 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*t*/(TypeDef)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // positive_int_const ::= const_expr 
            {
              CUP$result = new PosIntConst(/*positive_int_const*/31);
               ((PosIntConst)CUP$result).const_expr = (/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // string_literal ::= DBLQUOTE DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/76);
               ((Literal)CUP$result).string = "\"\""; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // string_literal ::= DBLQUOTE ID DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/76);
               ((Literal)CUP$result).string = "\"" + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)).str_val + "\""; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // literal ::= FALSE 
            {
              CUP$result = new Literal(/*literal*/75);
               ((Literal)CUP$result).string = "false"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // literal ::= TRUE 
            {
              CUP$result = new Literal(/*literal*/75);
               ((Literal)CUP$result).string = "true"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // literal ::= FLOAT_NUMBER 
            {
              CUP$result = new Literal(/*literal*/75);
               ((Literal)CUP$result).string = "" + (/*n*/(java_cup.runtime.float_token)CUP$stack.elementAt(CUP$top-0)).float_val ; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // literal ::= FIXED_NUMBER 
            {
              CUP$result = new Literal(/*literal*/75);
               ((Literal)CUP$result).string = "" + (/*f*/(fixed_token)CUP$stack.elementAt(CUP$top-0)).fixed_val; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // literal ::= string_literal 
            {
              CUP$result = new Literal(/*literal*/75);
               ((Literal)CUP$result).string = (/*s*/(Literal)CUP$stack.elementAt(CUP$top-0)).string; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // literal ::= QUOTE CH QUOTE 
            {
              CUP$result = new Literal(/*literal*/75);
               ((Literal)CUP$result).string = "\'" + (/*c*/(java_cup.runtime.char_token)CUP$stack.elementAt(CUP$top-1)).char_val + "\'"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // literal ::= NUMBER 
            {
              CUP$result = new Literal(/*literal*/75);
               ((Literal)CUP$result).string = "" + (/*n*/(java_cup.runtime.int_token)CUP$stack.elementAt(CUP$top-0)).int_val; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // primary_expr ::= LPAREN const_expr RPAREN 
            {
              CUP$result = new PrimaryExpr(/*primary_expr*/39);
               ((PrimaryExpr)CUP$result).symbol = (/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-1)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // primary_expr ::= literal 
            {
              CUP$result = new PrimaryExpr(/*primary_expr*/39);
               ((PrimaryExpr)CUP$result).symbol = (/*l*/(Literal)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // primary_expr ::= scopename 
            {
              CUP$result = new PrimaryExpr(/*primary_expr*/39);
               ((PrimaryExpr)CUP$result).symbol = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // unary_op ::= TILDE 
            {
              CUP$result = new java_cup.runtime.str_token(/*unary_op*/8);
               ((java_cup.runtime.str_token)CUP$result).str_val = "~"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // unary_op ::= PLUS 
            {
              CUP$result = new java_cup.runtime.str_token(/*unary_op*/8);
               ((java_cup.runtime.str_token)CUP$result).str_val = "+"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // unary_op ::= MINUS 
            {
              CUP$result = new java_cup.runtime.str_token(/*unary_op*/8);
               ((java_cup.runtime.str_token)CUP$result).str_val = "-"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // unary_expr ::= primary_expr 
            {
              CUP$result = new UnaryExpr(/*unary_expr*/38);
               ((UnaryExpr)CUP$result).primary_expr = (/*p*/(PrimaryExpr)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // unary_expr ::= unary_op primary_expr 
            {
              CUP$result = new UnaryExpr(/*unary_expr*/38);
              
                        ((UnaryExpr)CUP$result).primary_expr = (/*p*/(PrimaryExpr)CUP$stack.elementAt(CUP$top-0));
                        ((UnaryExpr)CUP$result).unary_op = (/*u*/(java_cup.runtime.str_token)CUP$stack.elementAt(CUP$top-1)).str_val;
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // mult_expr ::= mult_expr PERCENT unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/37);
              
                        ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0)); 
                        ((MultExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-2));
                        ((MultExpr)CUP$result).operator = "%";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // mult_expr ::= mult_expr SLASH unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/37);
              
                        ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0)); 
                        ((MultExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-2));
                        ((MultExpr)CUP$result).operator = "/";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // mult_expr ::= mult_expr STAR unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/37);
              
                        ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0)); 
                        ((MultExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-2));
                        ((MultExpr)CUP$result).operator = "*";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // mult_expr ::= unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/37);
               ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // add_expr ::= add_expr MINUS mult_expr 
            {
              CUP$result = new AddExpr(/*add_expr*/36);
              
                        ((AddExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-2)); 
                        ((AddExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-0));
                        ((AddExpr)CUP$result).operator = "-";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // add_expr ::= add_expr PLUS mult_expr 
            {
              CUP$result = new AddExpr(/*add_expr*/36);
              
                        ((AddExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-2)); 
                        ((AddExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-0));
                        ((AddExpr)CUP$result).operator = "+";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // add_expr ::= mult_expr 
            {
              CUP$result = new AddExpr(/*add_expr*/36);
              
                        ((AddExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // shift_expr ::= shift_expr RSHIFT add_expr 
            {
              CUP$result = new ShiftExpr(/*shift_expr*/35);
              
                        ((ShiftExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-0)); 
                        ((ShiftExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-2));
                        ((ShiftExpr)CUP$result).operator = ">>";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // shift_expr ::= shift_expr LSHIFT add_expr 
            {
              CUP$result = new ShiftExpr(/*shift_expr*/35);
              
                        ((ShiftExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-0)); 
                        ((ShiftExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-2));
                        ((ShiftExpr)CUP$result).operator = "<<";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // shift_expr ::= add_expr 
            {
              CUP$result = new ShiftExpr(/*shift_expr*/35);
               
                        ((ShiftExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // and_expr ::= and_expr AMPERSAND shift_expr 
            {
              CUP$result = new AndExpr(/*and_expr*/34);
              
                        ((AndExpr)CUP$result).and_expr = (/*a*/(AndExpr)CUP$stack.elementAt(CUP$top-2)); 
                        ((AndExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // and_expr ::= shift_expr 
            {
              CUP$result = new AndExpr(/*and_expr*/34);
               
                        ((AndExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // xor_expr ::= xor_expr CIRCUM and_expr 
            {
              CUP$result = new XorExpr(/*xor_expr*/33);
              
                        ((XorExpr)CUP$result).and_expr = (/*a*/(AndExpr)CUP$stack.elementAt(CUP$top-0)); 
                        ((XorExpr)CUP$result).xor_expr = (/*x*/(XorExpr)CUP$stack.elementAt(CUP$top-2));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // xor_expr ::= and_expr 
            {
              CUP$result = new XorExpr(/*xor_expr*/33);
               
                        ((XorExpr)CUP$result).and_expr = (/*a*/(AndExpr)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // or_expr ::= or_expr BAR xor_expr 
            {
              CUP$result = new OrExpr(/*or_expr*/32);
              
                        ((OrExpr)CUP$result).or_expr = (/*o*/(OrExpr)CUP$stack.elementAt(CUP$top-2)); 
                        ((OrExpr)CUP$result).xor_expr = (/*x*/(XorExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // or_expr ::= xor_expr 
            {
              CUP$result = new OrExpr(/*or_expr*/32);
               
                        ((OrExpr)CUP$result).xor_expr = (/*x*/(XorExpr)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // const_expr ::= or_expr 
            {
              CUP$result = new ConstExpr(/*const_expr*/30);
               
                        ((ConstExpr)CUP$result).or_expr = (/*o*/(OrExpr)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // const_type ::= scopename 
            {
              CUP$result = new ConstType(/*const_type*/29);
               
                        ((ConstType)CUP$result).symbol = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
                        ((ConstType)CUP$result).set_token((/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // const_type ::= octet_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(OctetType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // const_type ::= string_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(StringType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // const_type ::= fixed_pt_const_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(FixedPointConstType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // const_type ::= float_pt_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(FloatPtType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // const_type ::= bool_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(BooleanType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // const_type ::= char_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(CharType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // const_type ::= int_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(IntType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // const_dcl ::= CONST const_type ID EQUALS const_expr 
            {
              CUP$result = new ConstDecl(/*const_dcl*/28);
              
                        ((ConstDecl)CUP$result).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)).str_val);
                        ((ConstDecl)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)));    
                        ((ConstDecl)CUP$result).const_expr = (/*ce*/(ConstExpr)CUP$stack.elementAt(CUP$top-0));
                        ((ConstDecl)CUP$result).const_type = (ConstType)(/*ct*/(ConstType)CUP$stack.elementAt(CUP$top-3));
                        ((ConstDecl)CUP$result).set_included( parser.include_state );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // init_param_decl ::= IN param_type_spec simple_declarator 
            {
              CUP$result = new IdlSymbol(/*init_param_decl*/27);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // init_param_decls ::= init_param_decl COMMA init_param_decls 
            {
              CUP$result = new IdlSymbol(/*init_param_decls*/26);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // init_param_decls ::= init_param_decl 
            {
              CUP$result = new IdlSymbol(/*init_param_decls*/26);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // state_member ::= PRIVATE type_spec declarators SEMI 
            {
              CUP$result = new IdlSymbol(/*state_member*/25);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // state_member ::= PUBLIC type_spec declarators SEMI 
            {
              CUP$result = new IdlSymbol(/*state_member*/25);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // value_element ::= FACTORY ID LPAREN RPAREN SEMI 
            {
              CUP$result = new IdlSymbol(/*value_element*/24);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // value_element ::= FACTORY ID LPAREN init_param_decls RPAREN SEMI 
            {
              CUP$result = new IdlSymbol(/*value_element*/24);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // value_element ::= state_member 
            {
              CUP$result = new IdlSymbol(/*value_element*/24);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // value_element ::= export 
            {
              CUP$result = new IdlSymbol(/*value_element*/24);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // value_elements ::= empty 
            {
              CUP$result = new IdlSymbol(/*value_elements*/23);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // value_elements ::= value_element value_elements 
            {
              CUP$result = new IdlSymbol(/*value_elements*/23);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // truncatable ::= empty 
            {
              CUP$result = new java_cup.runtime.int_token(/*truncatable*/7);
               
                ((java_cup.runtime.int_token)CUP$result).int_val = 0; 
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // truncatable ::= TRUNCATABLE 
            {
              CUP$result = new java_cup.runtime.int_token(/*truncatable*/7);
               
                ((java_cup.runtime.int_token)CUP$result).int_val = 1; 
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // value_inheritance_spec ::= empty 
            {
              CUP$result = new IdlSymbol(/*value_inheritance_spec*/22);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // value_inheritance_spec ::= COLON truncatable scopename_list SUPPORTS scopename_list 
            {
              CUP$result = new IdlSymbol(/*value_inheritance_spec*/22);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // value_inheritance_spec ::= SUPPORTS scopename_list 
            {
              CUP$result = new IdlSymbol(/*value_inheritance_spec*/22);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // value_inheritance_spec ::= COLON truncatable scopename_list 
            {
              CUP$result = new IdlSymbol(/*value_inheritance_spec*/22);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // value_dcl ::= VALUETYPE ID value_inheritance_spec LCBRACE value_elements RCBRACE 
            {
              CUP$result = new Value(/*value_dcl*/21);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // value_dcl ::= CUSTOM VALUETYPE ID value_inheritance_spec LCBRACE value_elements RCBRACE 
            {
              CUP$result = new Value(/*value_dcl*/21);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // value_body ::= export 
            {
              CUP$result = new IdlSymbol(/*value_body*/20);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // value_body ::= export value_body 
            {
              CUP$result = new IdlSymbol(/*value_body*/20);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // value_abs_dcl ::= ABSTRACT VALUETYPE ID value_inheritance_spec LCBRACE RCBRACE 
            {
              CUP$result = new IdlSymbol(/*value_abs_dcl*/19);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // value_abs_dcl ::= ABSTRACT VALUETYPE ID value_inheritance_spec LCBRACE value_body RCBRACE 
            {
              CUP$result = new IdlSymbol(/*value_abs_dcl*/19);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // value_box_dcl ::= VALUETYPE ID type_spec 
            {
              CUP$result = new ValueBoxDecl(/*value_box_dcl*/18);
               
                        ((ValueBoxDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)).str_val;
                        ((ValueBoxDecl)CUP$result).typeSpec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // value ::= VALUETYPE ID 
            {
              CUP$result = new ValueDeclaration(/*value*/17);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // value ::= ABSTRACT VALUETYPE ID 
            {
              CUP$result = new ValueDeclaration(/*value*/17);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // value ::= value_box_dcl 
            {
              CUP$result = new ValueDeclaration(/*value*/17);
               
                        ((ValueDeclaration)CUP$result).value_decl = (/*vbx*/(ValueBoxDecl)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // value ::= value_abs_dcl 
            {
              CUP$result = new ValueDeclaration(/*value*/17);
               
                        ((ValueDeclaration)CUP$result).value_decl = (/*vad*/(IdlSymbol)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // value ::= value_dcl 
            {
              CUP$result = new ValueDeclaration(/*value*/17);
               
                        ((ValueDeclaration)CUP$result).value_decl = (/*vd*/(Value)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // scopename ::= OBJECT 
            {
              CUP$result = new ScopedName(/*scopename*/16);
               
                        ((ScopedName)CUP$result).typeName = "org.omg.CORBA.Object";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // scopename ::= scopename DBLCOLON ID 
            {
              CUP$result = new ScopedName(/*scopename*/16);
               
                        ((ScopedName)CUP$result).setId( (/*sn*/(ScopedName)CUP$stack.elementAt(CUP$top-2)).typeName + "." + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val );
                        ((ScopedName)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // scopename ::= DBLCOLON ID 
            {
              CUP$result = new ScopedName(/*scopename*/16);
               
                        ((ScopedName)CUP$result).setId( "." + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val);
                        ((ScopedName)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));    
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // scopename ::= ID 
            {
              CUP$result = new ScopedName(/*scopename*/16);
               
                        ((ScopedName)CUP$result).setId( (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val );
                        ((ScopedName)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));    
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // scopename_list ::= scopename 
            {
              CUP$result = new SymbolList(/*scopename_list*/90);
               ((SymbolList)CUP$result).v.insertElementAt((/*sn*/(ScopedName)CUP$stack.elementAt(CUP$top-0)),0); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // scopename_list ::= scopename COMMA scopename_list 
            {
              CUP$result = new SymbolList(/*scopename_list*/90);
               
                ((SymbolList)CUP$result).v = (Vector)(/*snl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone(); 
                ((SymbolList)CUP$result).v.insertElementAt((/*sn*/(ScopedName)CUP$stack.elementAt(CUP$top-2)),0); 
            
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // inheritance_spec ::= empty 
            {
              CUP$result = new SymbolList(/*inheritance_spec*/93);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // inheritance_spec ::= COLON scopename_list 
            {
              CUP$result = new SymbolList(/*inheritance_spec*/93);
               ((SymbolList)CUP$result).v = (Vector)(/*sl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // export ::= op_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/15);
               ((Definition)CUP$result).set_declaration((/*o*/(OpDecl)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // export ::= attr_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/15);
               ((Definition)CUP$result).set_declaration((/*a*/(AttrDecl)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // export ::= except_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/15);
               ((Definition)CUP$result).set_declaration((/*e*/(StructType)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // export ::= const_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/15);
               ((Definition)CUP$result).set_declaration((/*c*/(ConstDecl)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // export ::= type_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/15);
               ((Definition)CUP$result).set_declaration((/*t*/(TypeDeclaration)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // interface_body ::= empty 
            {
              CUP$result = new InterfaceBody(/*interface_body*/14);
               ((InterfaceBody)CUP$result).commit(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // interface_body ::= export interface_body 
            {
              CUP$result = new InterfaceBody(/*interface_body*/14);
               
                        ((InterfaceBody)CUP$result).v = (Vector)(/*i*/(InterfaceBody)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((InterfaceBody)CUP$result).v.insertElementAt((/*e*/(Definition)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // interface ::= PSEUDO INTERFACE ID 
            {
              CUP$result = new Interface(/*interface*/13);
              
                ((Interface)CUP$result).set_pseudo();
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));    
                ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // interface ::= ABSTRACT INTERFACE ID 
            {
              CUP$result = new Interface(/*interface*/13);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));    
                ((Interface)CUP$result).set_abstract();
                ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // interface ::= INTERFACE ID 
            {
              CUP$result = new Interface(/*interface*/13);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));    
                ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // interface ::= PSEUDO INTERFACE ID inheritance_spec LCBRACE interface_body RCBRACE 
            {
              CUP$result = new Interface(/*interface*/13);
               
                ((Interface)CUP$result).set_pseudo();
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                ((Interface)CUP$result).inheritanceSpec = (/*is*/(SymbolList)CUP$stack.elementAt(CUP$top-3));
                ((Interface)CUP$result).body = (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)); 
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_pseudo();
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
//              (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4))); 
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).my_interface = ((Interface)CUP$result);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Interface)CUP$result));
                ((Interface)CUP$result).set_included( parser.include_state );
                ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // interface ::= ABSTRACT INTERFACE ID inheritance_spec LCBRACE interface_body RCBRACE 
            {
              CUP$result = new Interface(/*interface*/13);
               
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                ((Interface)CUP$result).set_abstract();
                ((Interface)CUP$result).inheritanceSpec = (/*is*/(SymbolList)CUP$stack.elementAt(CUP$top-3));
                ((Interface)CUP$result).body = (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)) ;
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).my_interface = ((Interface)CUP$result);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Interface)CUP$result));
                ((Interface)CUP$result).set_included( parser.include_state );
                ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // interface ::= INTERFACE ID inheritance_spec LCBRACE interface_body RCBRACE 
            {
              CUP$result = new Interface(/*interface*/13);
               
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                ((Interface)CUP$result).inheritanceSpec = (/*is*/(SymbolList)CUP$stack.elementAt(CUP$top-3));
                ((Interface)CUP$result).body = (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)) ;
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).my_interface = ((Interface)CUP$result);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Interface)CUP$result));
                ((Interface)CUP$result).set_included( parser.include_state );
                ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // module ::= MODULE ID LCBRACE definitions RCBRACE 
            {
              CUP$result = new Module(/*module*/12);
               
                ((Module)CUP$result).spec = (/*d*/(Definitions)CUP$stack.elementAt(CUP$top-1));
                ((Module)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));
                ((Module)CUP$result).setPackage((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)).str_val );
                ((Module)CUP$result).set_included( parser.include_state );

                (/*d*/(Definitions)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Module)CUP$result));
                parser.closeScope( (Scope)((Module)CUP$result) );
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // definition ::= value SEMI 
            {
              CUP$result = new Definition(/*definition*/10);
               
                        ((Definition)CUP$result).set_declaration((/*m*/(ValueDeclaration)CUP$stack.elementAt(CUP$top-1)));
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // definition ::= module SEMI 
            {
              CUP$result = new Definition(/*definition*/10);
               
                        ((Definition)CUP$result).set_declaration((/*m*/(Module)CUP$stack.elementAt(CUP$top-1)));
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // definition ::= interface SEMI 
            {
              CUP$result = new Definition(/*definition*/10);
               
                        ((Definition)CUP$result).set_declaration((/*p*/(Interface)CUP$stack.elementAt(CUP$top-1))); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // definition ::= except_dcl SEMI 
            {
              CUP$result = new Definition(/*definition*/10);
               
                        ((Definition)CUP$result).set_declaration((/*e*/(StructType)CUP$stack.elementAt(CUP$top-1))); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // definition ::= const_dcl SEMI 
            {
              CUP$result = new Definition(/*definition*/10);
               
                        ((Definition)CUP$result).set_declaration((/*c*/(ConstDecl)CUP$stack.elementAt(CUP$top-1))); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // definition ::= type_dcl SEMI 
            {
              CUP$result = new Definition(/*definition*/10);
               
                        ((Definition)CUP$result).set_declaration((/*t*/(TypeDeclaration)CUP$stack.elementAt(CUP$top-1))); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // definitions ::= definition 
            {
              CUP$result = new Definitions(/*definitions*/11);
              
                        ((Definitions)CUP$result).v.insertElementAt((/*d*/(Definition)CUP$stack.elementAt(CUP$top-0)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // definitions ::= definition definitions 
            {
              CUP$result = new Definitions(/*definitions*/11);
              
                        ((Definitions)CUP$result).v = (Vector)(/*ds*/(Definitions)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((Definitions)CUP$result).v.insertElementAt((/*d*/(Definition)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // specification ::= empty 
            {
              CUP$result = new Spec(/*specification*/9);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // specification ::= NT$0 definitions 
            {
              CUP$result = new Spec(/*specification*/9);
              
                /* parsing */

                // open the global scope
                parser.openScope();

                ((Spec)CUP$result).definitions = (Vector)(/*ds*/(Definitions)CUP$stack.elementAt(CUP$top-0)).v.clone();

                if( ((org.jacorb.idl.parser)CUP$parser).package_prefix != null )
                        ((Spec)CUP$result).setPackage( ((org.jacorb.idl.parser)CUP$parser).package_prefix );

                ((Spec)CUP$result).parse();

                if ( lexer.error_count != 0 )
                {
                        System.err.println(lexer.error_count + " error(s).");
                        System.exit(1);
                }

                // if there are still interfaces to be parsed, wait until the
                // threads performing this have finished. The last one will call notify() :) 

                if( parser.pending_interfaces.size() > 0 )
                {
                        if( Thread.activeCount() > 1 )
                        {
                           synchronized(parser.pending_interfaces)
                           {
                                parser.pending_interfaces.wait();
                           }
                        } 
                        else 
                        {
                                if( !parser.sloppy )
                                     parser.fatal_error("Undefined interface: " + 
                                     (String)(parser.pending_interfaces.keys().nextElement()), null );
                        }
                }

                /* complete global import list */
                if( parser.global_import )
                {
                        Environment.output(3,"Preparing global import");
                        parser.addGlobalNamesToImport();
                }
                else
                        Environment.output(3,"No global import");

                /* code generation phase */

                try
                {

                   if (! ((org.jacorb.idl.parser)CUP$parser).parse_only  )
                   {
                        ((Spec)CUP$result).print(new java.io.PrintWriter( java.lang.System.out ));
                   }
                } 
                catch ( Exception e )
                {
                        e.printStackTrace();
                }
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              CUP$result = new java_cup.runtime.token(/*NT$0*/96);
              
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= specification EOF 
            {
              CUP$result = new java_cup.runtime.token(/*$START*/0);
              
            }
          /* ACCEPT */
          CUP$parser.done_parsing();
          return CUP$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
};

