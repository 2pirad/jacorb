
//----------------------------------------------------
// The following code was generated by CUP v0.9e
// Fri Nov 09 10:48:45 GMT+01:00 2001
//----------------------------------------------------

package org.jacorb.idl;

import java_cup.runtime.*;
import java.util.*;

public class parser extends java_cup.runtime.lr_parser {

  /** constructor */
  public parser() {super();}

  /** production table */
  protected static final short _production_table[][] = {
        {0, 2},     {96, 0},     {9, 2},     {9, 1},     {11, 2}, 
        {11, 1},     {10, 2},     {10, 2},     {10, 2},     {10, 2}, 
        {10, 2},     {10, 2},     {12, 5},     {13, 6},     {13, 7}, 
        {13, 7},     {13, 2},     {13, 3},     {13, 3},     {14, 2}, 
        {14, 1},     {15, 2},     {15, 2},     {15, 2},     {15, 2}, 
        {15, 2},     {93, 2},     {93, 1},     {90, 3},     {90, 1}, 
        {16, 1},     {16, 2},     {16, 3},     {16, 1},     {17, 1}, 
        {17, 1},     {17, 3},     {17, 2},     {18, 3},     {20, 2}, 
        {20, 1},     {19, 7},     {19, 6},     {21, 3},     {21, 2}, 
        {21, 5},     {21, 1},     {7, 1},     {7, 1},     {22, 2}, 
        {22, 1},     {23, 1},     {23, 1},     {23, 6},     {23, 5}, 
        {24, 4},     {24, 4},     {25, 1},     {25, 3},     {26, 3}, 
        {27, 5},     {28, 1},     {28, 1},     {28, 1},     {28, 1}, 
        {28, 1},     {28, 1},     {28, 1},     {28, 1},     {29, 1}, 
        {31, 1},     {31, 3},     {32, 1},     {32, 3},     {33, 1}, 
        {33, 3},     {34, 1},     {34, 3},     {34, 3},     {35, 1}, 
        {35, 3},     {35, 3},     {36, 1},     {36, 3},     {36, 3}, 
        {36, 3},     {37, 2},     {37, 1},     {8, 1},     {8, 1}, 
        {8, 1},     {38, 1},     {38, 1},     {38, 3},     {74, 1}, 
        {74, 3},     {74, 1},     {74, 1},     {74, 1},     {74, 1}, 
        {74, 1},     {75, 3},     {75, 2},     {75, 3},     {75, 2}, 
        {30, 1},     {39, 1},     {39, 1},     {39, 1},     {39, 1}, 
        {39, 1},     {45, 2},     {40, 2},     {41, 1},     {41, 1}, 
        {46, 1},     {46, 1},     {46, 1},     {57, 1},     {57, 1}, 
        {57, 1},     {57, 1},     {57, 1},     {57, 1},     {57, 1}, 
        {47, 1},     {47, 1},     {47, 1},     {48, 1},     {48, 1}, 
        {48, 1},     {92, 3},     {92, 1},     {78, 1},     {78, 1}, 
        {79, 1},     {59, 1},     {59, 1},     {60, 1},     {61, 1}, 
        {62, 1},     {58, 1},     {58, 1},     {58, 2},     {58, 2}, 
        {58, 1},     {58, 2},     {63, 1},     {64, 1},     {65, 2}, 
        {66, 1},     {66, 1},     {67, 1},     {68, 1},     {69, 1}, 
        {50, 5},     {86, 1},     {86, 2},     {77, 3},     {52, 9}, 
        {44, 1},     {44, 1},     {44, 1},     {44, 1},     {44, 1}, 
        {54, 1},     {54, 2},     {55, 3},     {87, 3},     {87, 2}, 
        {87, 4},     {87, 3},     {56, 2},     {49, 5},     {94, 1}, 
        {94, 3},     {53, 2},     {72, 6},     {72, 4},     {71, 4}, 
        {71, 4},     {71, 1},     {71, 1},     {73, 6},     {80, 2}, 
        {95, 1},     {95, 2},     {81, 3},     {85, 4},     {85, 3}, 
        {91, 1},     {91, 3},     {51, 4},     {51, 5},     {84, 6}, 
        {5, 1},     {5, 1},     {42, 1},     {42, 1},     {70, 1}, 
        {89, 3},     {89, 2},     {88, 3},     {88, 1},     {82, 3}, 
        {6, 1},     {6, 1},     {6, 1},     {83, 4},     {83, 1}, 
        {2, 4},     {2, 1},     {3, 1},     {3, 3},     {43, 1}, 
        {43, 1},     {43, 1},     {4, 0}  };

  /** access to production table */
  public short[][] production_table() {return _production_table;}

  /** parse action table */
  protected static final short[][] _action_table = {
    /*0*/{0,-218,2,-2,8,-2,10,-2,13,-2,14,-2,21,-2,23,-2,24,-2,31,-2,37,-2,42,-2,44,-2,46,-2,-1,0},
    /*1*/{2,29,8,26,10,8,13,27,14,10,21,28,23,19,24,13,31,22,37,12,42,23,44,25,46,16,-1,0},
    /*2*/{0,5,-1,0},
    /*3*/{0,-4,-1,0},
    /*4*/{0,-1,-1,0},
    /*5*/{50,378,-1,0},
    /*6*/{50,377,-1,0},
    /*7*/{46,371,-1,0},
    /*8*/{50,370,-1,0},
    /*9*/{79,365,-1,0},
    /*10*/{50,-110,-1,0},
    /*11*/{79,356,-1,0},
    /*12*/{79,190,-1,0},
    /*13*/{0,-6,2,29,8,26,10,8,13,27,14,10,21,28,23,19,24,13,31,22,37,12,42,23,44,25,46,16,61,-6,-1,0},
    /*14*/{50,-35,-1,0},
    /*15*/{79,311,-1,0},
    /*16*/{50,-36,-1,0},
    /*17*/{50,310,-1,0},
    /*18*/{79,306,-1,0},
    /*19*/{50,-111,-1,0},
    /*20*/{50,305,-1,0},
    /*21*/{21,299,-1,0},
    /*22*/{3,89,5,84,7,74,12,98,13,27,17,256,18,86,22,70,25,42,26,95,34,265,35,93,36,85,37,12,43,78,44,25,45,81,48,94,49,96,75,44,79,41,-1,0},
    /*23*/{50,292,-1,0},
    /*24*/{79,232,-1,0},
    /*25*/{5,84,7,74,12,98,17,227,18,86,22,70,25,42,26,95,35,93,36,85,43,78,48,94,49,96,75,44,79,41,-1,0},
    /*26*/{79,212,-1,0},
    /*27*/{79,207,-1,0},
    /*28*/{21,34,46,35,-1,0},
    /*29*/{50,-109,-1,0},
    /*30*/{50,-107,-1,0},
    /*31*/{50,-108,-1,0},
    /*32*/{0,-3,-1,0},
    /*33*/{79,37,-1,0},
    /*34*/{79,36,-1,0},
    /*35*/{50,-37,-1,0},
    /*36*/{50,-18,54,39,60,-218,-1,0},
    /*37*/{60,51,-1,0},
    /*38*/{25,42,75,44,79,41,-1,0},
    /*39*/{60,-28,-1,0},
    /*40*/{38,-31,50,-31,51,-31,52,-31,54,-31,56,-31,57,-31,59,-31,60,-31,63,-31,65,-31,69,-31,70,-31,71,-31,72,-31,73,-31,75,-31,76,-31,77,-31,79,-31,-1,0},
    /*41*/{38,-34,50,-34,51,-34,52,-34,54,-34,56,-34,57,-34,59,-34,60,-34,63,-34,65,-34,69,-34,70,-34,71,-34,72,-34,73,-34,75,-34,76,-34,77,-34,79,-34,-1,0},
    /*42*/{38,-30,51,47,59,-30,60,-30,75,48,-1,0},
    /*43*/{79,46,-1,0},
    /*44*/{60,-27,-1,0},
    /*45*/{38,-32,50,-32,51,-32,52,-32,54,-32,56,-32,57,-32,59,-32,60,-32,63,-32,65,-32,69,-32,70,-32,71,-32,72,-32,73,-32,75,-32,76,-32,77,-32,79,-32,-1,0},
    /*46*/{25,42,75,44,79,41,-1,0},
    /*47*/{79,49,-1,0},
    /*48*/{38,-33,50,-33,51,-33,52,-33,54,-33,56,-33,57,-33,59,-33,60,-33,63,-33,65,-33,69,-33,70,-33,71,-33,72,-33,73,-33,75,-33,76,-33,77,-33,79,-33,-1,0},
    /*49*/{38,-29,59,-29,60,-29,-1,0},
    /*50*/{3,-218,4,54,5,-218,7,-218,8,26,12,-218,13,27,14,10,18,-218,22,-218,24,13,25,-218,26,-218,27,56,33,53,35,-218,36,-218,37,12,42,23,43,-218,44,25,45,-218,47,-218,48,-218,49,-218,61,-218,75,-218,79,-218,-1,0},
    /*51*/{50,206,-1,0},
    /*52*/{4,203,-1,0},
    /*53*/{3,89,5,84,7,74,12,98,18,86,22,70,25,42,26,95,35,93,36,85,43,78,45,81,48,94,49,96,75,44,79,41,-1,0},
    /*54*/{61,197,-1,0},
    /*55*/{3,-196,5,-196,7,-196,12,-196,18,-196,22,-196,25,-196,26,-196,35,-196,36,-196,43,-196,45,-196,47,-196,48,-196,49,-196,75,-196,79,-196,-1,0},
    /*56*/{50,196,-1,0},
    /*57*/{3,89,5,84,7,74,12,98,18,86,22,70,25,42,26,95,35,93,36,85,43,78,45,81,47,97,48,94,49,96,75,44,79,41,-1,0},
    /*58*/{3,-197,5,-197,7,-197,12,-197,18,-197,22,-197,25,-197,26,-197,35,-197,36,-197,43,-197,45,-197,47,-197,48,-197,49,-197,61,-21,75,-197,79,-197,-1,0},
    /*59*/{50,67,-1,0},
    /*60*/{50,66,-1,0},
    /*61*/{50,65,-1,0},
    /*62*/{3,-218,4,54,5,-218,7,-218,8,26,12,-218,13,27,14,10,18,-218,22,-218,24,13,25,-218,26,-218,27,56,33,53,35,-218,36,-218,37,12,42,23,43,-218,44,25,45,-218,47,-218,48,-218,49,-218,61,-218,75,-218,79,-218,-1,0},
    /*63*/{61,-20,-1,0},
    /*64*/{3,-24,4,-24,5,-24,7,-24,8,-24,12,-24,13,-24,14,-24,15,-24,18,-24,22,-24,24,-24,25,-24,26,-24,27,-24,29,-24,30,-24,33,-24,35,-24,36,-24,37,-24,42,-24,43,-24,44,-24,45,-24,47,-24,48,-24,49,-24,61,-24,75,-24,79,-24,-1,0},
    /*65*/{3,-26,4,-26,5,-26,7,-26,8,-26,12,-26,13,-26,14,-26,15,-26,18,-26,22,-26,24,-26,25,-26,26,-26,27,-26,29,-26,30,-26,33,-26,35,-26,36,-26,37,-26,42,-26,43,-26,44,-26,45,-26,47,-26,48,-26,49,-26,61,-26,75,-26,79,-26,-1,0},
    /*66*/{3,-23,4,-23,5,-23,7,-23,8,-23,12,-23,13,-23,14,-23,15,-23,18,-23,22,-23,24,-23,25,-23,26,-23,27,-23,29,-23,30,-23,33,-23,35,-23,36,-23,37,-23,42,-23,43,-23,44,-23,45,-23,47,-23,48,-23,49,-23,61,-23,75,-23,79,-23,-1,0},
    /*67*/{50,-123,51,-123,65,-123,79,-123,-1,0},
    /*68*/{79,-216,-1,0},
    /*69*/{22,195,50,-149,51,-149,59,-149,65,-149,79,-149,-1,0},
    /*70*/{50,-121,51,-121,65,-121,79,-121,-1,0},
    /*71*/{75,48,79,-217,-1,0},
    /*72*/{79,164,-1,0},
    /*73*/{50,-151,51,-151,59,-151,65,-151,79,-151,-1,0},
    /*74*/{50,-146,51,-146,59,-146,65,-146,79,-146,-1,0},
    /*75*/{79,-198,-1,0},
    /*76*/{79,-215,-1,0},
    /*77*/{22,70,35,93,-1,0},
    /*78*/{50,-120,51,-120,65,-120,79,-120,-1,0},
    /*79*/{79,-199,-1,0},
    /*80*/{50,-125,51,-125,65,-125,79,-125,-1,0},
    /*81*/{50,-137,51,-137,65,-137,79,-137,-1,0},
    /*82*/{50,-122,51,-122,65,-122,79,-122,-1,0},
    /*83*/{50,-153,51,-153,59,-153,65,-153,79,-153,-1,0},
    /*84*/{50,-182,51,-182,64,158,65,-182,79,-182,-1,0},
    /*85*/{50,-139,51,-139,65,-139,79,-139,-1,0},
    /*86*/{50,-124,51,-124,65,-124,79,-124,-1,0},
    /*87*/{50,-138,51,-138,65,-138,79,-138,-1,0},
    /*88*/{50,-155,51,-155,65,-155,79,-155,-1,0},
    /*89*/{50,-143,51,-143,59,-143,65,-143,79,-143,-1,0},
    /*90*/{50,-142,51,-142,59,-142,65,-142,79,-142,-1,0},
    /*91*/{50,-119,51,-119,65,-119,79,-119,-1,0},
    /*92*/{50,-148,51,-148,59,-148,65,-148,79,-148,-1,0},
    /*93*/{50,-152,51,-152,59,-152,65,-152,79,-152,-1,0},
    /*94*/{50,-154,51,-154,65,-154,79,-154,-1,0},
    /*95*/{50,-183,51,-183,64,99,65,-183,79,-183,-1,0},
    /*96*/{79,-200,-1,0},
    /*97*/{50,-141,51,-141,65,-141,79,-141,-1,0},
    /*98*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*99*/{50,-71,51,-71,54,-71,59,-71,63,-71,65,-71,69,-71,70,148,-1,0},
    /*100*/{50,-99,51,-99,52,-99,54,-99,56,-99,57,-99,59,-99,63,-99,65,-99,69,-99,70,-99,71,-99,72,-99,73,-99,76,-99,77,-99,-1,0},
    /*101*/{16,-90,25,-90,40,-90,58,-90,66,-90,67,-90,75,-90,78,-90,79,-90,82,-90,84,-90,85,-90,-1,0},
    /*102*/{50,-98,51,-98,52,-98,54,-98,56,-98,57,-98,59,-98,63,-98,65,-98,69,-98,70,-98,71,-98,72,-98,73,-98,76,-98,77,-98,-1,0},
    /*103*/{50,-92,51,-92,52,-92,54,-92,56,-92,57,-92,59,-92,63,-92,65,-92,69,-92,70,-92,71,-92,72,-92,73,-92,75,48,76,-92,77,-92,-1,0},
    /*104*/{50,-100,51,-100,52,-100,54,-100,56,-100,57,-100,59,-100,63,-100,65,-100,69,-100,70,-100,71,-100,72,-100,73,-100,76,-100,77,-100,-1,0},
    /*105*/{67,155,79,156,-1,0},
    /*106*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*107*/{16,-91,25,-91,40,-91,58,-91,66,-91,67,-91,75,-91,78,-91,79,-91,82,-91,84,-91,85,-91,-1,0},
    /*108*/{50,-77,51,-77,54,-77,56,130,57,131,59,-77,63,-77,65,-77,69,-77,70,-77,71,-77,76,-77,77,-77,-1,0},
    /*109*/{80,151,-1,0},
    /*110*/{50,-83,51,-83,52,-83,54,-83,56,-83,57,-83,59,-83,63,-83,65,-83,69,-83,70,-83,71,-83,72,-83,73,-83,76,-83,77,-83,-1,0},
    /*111*/{50,-95,51,-95,52,-95,54,-95,56,-95,57,-95,59,-95,63,-95,65,-95,69,-95,70,-95,71,-95,72,-95,73,-95,76,-95,77,-95,-1,0},
    /*112*/{65,150,-1,0},
    /*113*/{50,-70,51,-70,54,-70,59,-70,63,-70,65,-70,69,146,-1,0},
    /*114*/{50,-88,51,-88,52,-88,54,-88,56,-88,57,-88,59,-88,63,-88,65,-88,69,-88,70,-88,71,-88,72,-88,73,-88,76,-88,77,-88,-1,0},
    /*115*/{50,-101,51,-101,52,-101,54,-101,56,-101,57,-101,59,-101,63,-101,65,-101,69,-101,70,-101,71,-101,72,-101,73,-101,76,-101,77,-101,-1,0},
    /*116*/{16,-89,25,-89,40,-89,58,-89,66,-89,67,-89,75,-89,78,-89,79,-89,82,-89,84,-89,85,-89,-1,0},
    /*117*/{50,-93,51,-93,52,-93,54,-93,56,-93,57,-93,59,-93,63,-93,65,-93,69,-93,70,-93,71,-93,72,-93,73,-93,76,-93,77,-93,-1,0},
    /*118*/{50,-73,51,-73,54,-73,59,-73,63,-73,65,-73,69,-73,70,-73,71,144,-1,0},
    /*119*/{50,-97,51,-97,52,-97,54,-97,56,-97,57,-97,59,-97,63,-97,65,-97,69,-97,70,-97,71,-97,72,-97,73,-97,76,-97,77,-97,-1,0},
    /*120*/{50,-80,51,-80,52,133,54,-80,56,-80,57,-80,59,-80,63,-80,65,-80,69,-80,70,-80,71,-80,72,135,73,134,76,-80,77,-80,-1,0},
    /*121*/{67,142,79,141,-1,0},
    /*122*/{51,-106,63,-106,65,-106,-1,0},
    /*123*/{50,-75,51,-75,54,-75,59,-75,63,-75,65,-75,69,-75,70,-75,71,-75,76,128,77,127,-1,0},
    /*124*/{16,116,25,42,40,105,58,107,66,110,67,106,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*125*/{50,-87,51,-87,52,-87,54,-87,56,-87,57,-87,59,-87,63,-87,65,-87,69,-87,70,-87,71,-87,72,-87,73,-87,76,-87,77,-87,-1,0},
    /*126*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*127*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*128*/{50,-79,51,-79,54,-79,56,130,57,131,59,-79,63,-79,65,-79,69,-79,70,-79,71,-79,76,-79,77,-79,-1,0},
    /*129*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*130*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*131*/{50,-82,51,-82,52,133,54,-82,56,-82,57,-82,59,-82,63,-82,65,-82,69,-82,70,-82,71,-82,72,135,73,134,76,-82,77,-82,-1,0},
    /*132*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*133*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*134*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*135*/{50,-85,51,-85,52,-85,54,-85,56,-85,57,-85,59,-85,63,-85,65,-85,69,-85,70,-85,71,-85,72,-85,73,-85,76,-85,77,-85,-1,0},
    /*136*/{50,-86,51,-86,52,-86,54,-86,56,-86,57,-86,59,-86,63,-86,65,-86,69,-86,70,-86,71,-86,72,-86,73,-86,76,-86,77,-86,-1,0},
    /*137*/{50,-84,51,-84,52,-84,54,-84,56,-84,57,-84,59,-84,63,-84,65,-84,69,-84,70,-84,71,-84,72,-84,73,-84,76,-84,77,-84,-1,0},
    /*138*/{50,-81,51,-81,52,133,54,-81,56,-81,57,-81,59,-81,63,-81,65,-81,69,-81,70,-81,71,-81,72,135,73,134,76,-81,77,-81,-1,0},
    /*139*/{50,-78,51,-78,54,-78,56,130,57,131,59,-78,63,-78,65,-78,69,-78,70,-78,71,-78,76,-78,77,-78,-1,0},
    /*140*/{67,143,-1,0},
    /*141*/{50,-105,51,-105,52,-105,54,-105,56,-105,57,-105,59,-105,63,-105,65,-105,69,-105,70,-105,71,-105,72,-105,73,-105,76,-105,77,-105,-1,0},
    /*142*/{50,-104,51,-104,52,-104,54,-104,56,-104,57,-104,59,-104,63,-104,65,-104,69,-104,70,-104,71,-104,72,-104,73,-104,76,-104,77,-104,-1,0},
    /*143*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*144*/{50,-76,51,-76,54,-76,59,-76,63,-76,65,-76,69,-76,70,-76,71,-76,76,128,77,127,-1,0},
    /*145*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*146*/{50,-72,51,-72,54,-72,59,-72,63,-72,65,-72,69,-72,70,148,-1,0},
    /*147*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*148*/{50,-74,51,-74,54,-74,59,-74,63,-74,65,-74,69,-74,70,-74,71,144,-1,0},
    /*149*/{50,-181,51,-181,65,-181,79,-181,-1,0},
    /*150*/{66,152,-1,0},
    /*151*/{50,-96,51,-96,52,-96,54,-96,56,-96,57,-96,59,-96,63,-96,65,-96,69,-96,70,-96,71,-96,72,-96,73,-96,76,-96,77,-96,-1,0},
    /*152*/{59,154,-1,0},
    /*153*/{50,-94,51,-94,52,-94,54,-94,56,-94,57,-94,59,-94,63,-94,65,-94,69,-94,70,-94,71,-94,72,-94,73,-94,76,-94,77,-94,-1,0},
    /*154*/{50,-103,51,-103,52,-103,54,-103,56,-103,57,-103,59,-103,63,-103,65,-103,69,-103,70,-103,71,-103,72,-103,73,-103,76,-103,77,-103,-1,0},
    /*155*/{67,157,-1,0},
    /*156*/{50,-102,51,-102,52,-102,54,-102,56,-102,57,-102,59,-102,63,-102,65,-102,69,-102,70,-102,71,-102,72,-102,73,-102,76,-102,77,-102,-1,0},
    /*157*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*158*/{65,160,-1,0},
    /*159*/{50,-180,51,-180,65,-180,79,-180,-1,0},
    /*160*/{50,-147,51,-147,59,-147,65,-147,79,-147,-1,0},
    /*161*/{50,-145,51,-145,59,-145,65,-145,79,-145,-1,0},
    /*162*/{50,-144,51,-144,59,-144,65,-144,79,-144,-1,0},
    /*163*/{58,165,-1,0},
    /*164*/{19,183,20,186,28,182,59,184,-1,0},
    /*165*/{9,-218,32,167,50,-218,-1,0},
    /*166*/{58,179,-1,0},
    /*167*/{9,172,50,-218,-1,0},
    /*168*/{9,-210,50,-210,-1,0},
    /*169*/{50,-195,-1,0},
    /*170*/{50,-212,-1,0},
    /*171*/{58,173,-1,0},
    /*172*/{67,106,78,122,-1,0},
    /*173*/{51,177,59,-213,-1,0},
    /*174*/{59,176,-1,0},
    /*175*/{50,-211,-1,0},
    /*176*/{67,106,78,122,-1,0},
    /*177*/{59,-214,-1,0},
    /*178*/{25,42,75,44,79,41,-1,0},
    /*179*/{59,181,-1,0},
    /*180*/{9,-209,50,-209,-1,0},
    /*181*/{3,-207,5,-207,7,-207,12,-207,18,-207,22,-207,25,-207,26,-207,35,-207,36,-207,43,-207,45,-207,48,-207,49,-207,75,-207,79,-207,-1,0},
    /*182*/{3,-206,5,-206,7,-206,12,-206,18,-206,22,-206,25,-206,26,-206,35,-206,36,-206,43,-206,45,-206,48,-206,49,-206,75,-206,79,-206,-1,0},
    /*183*/{9,-202,32,-202,50,-202,-1,0},
    /*184*/{59,194,-1,0},
    /*185*/{3,-208,5,-208,7,-208,12,-208,18,-208,22,-208,25,-208,26,-208,35,-208,36,-208,43,-208,45,-208,48,-208,49,-208,75,-208,79,-208,-1,0},
    /*186*/{51,192,59,-204,-1,0},
    /*187*/{3,89,5,84,7,74,12,98,18,86,22,70,25,42,26,95,35,93,36,85,43,78,45,81,48,94,49,96,75,44,79,41,-1,0},
    /*188*/{79,190,-1,0},
    /*189*/{50,-136,51,-136,59,-136,-1,0},
    /*190*/{51,-205,59,-205,-1,0},
    /*191*/{19,183,20,186,28,182,-1,0},
    /*192*/{59,-203,-1,0},
    /*193*/{9,-201,32,-201,50,-201,-1,0},
    /*194*/{50,-150,51,-150,59,-150,65,-150,79,-150,-1,0},
    /*195*/{3,-25,4,-25,5,-25,7,-25,8,-25,12,-25,13,-25,14,-25,15,-25,18,-25,22,-25,24,-25,25,-25,26,-25,27,-25,29,-25,30,-25,33,-25,35,-25,36,-25,37,-25,42,-25,43,-25,44,-25,45,-25,47,-25,48,-25,49,-25,61,-25,75,-25,79,-25,-1,0},
    /*196*/{50,-15,-1,0},
    /*197*/{79,190,-1,0},
    /*198*/{50,-191,51,201,-1,0},
    /*199*/{50,-190,-1,0},
    /*200*/{79,190,-1,0},
    /*201*/{50,-192,-1,0},
    /*202*/{3,89,5,84,7,74,12,98,18,86,22,70,25,42,26,95,35,93,36,85,43,78,45,81,48,94,49,96,75,44,79,41,-1,0},
    /*203*/{79,190,-1,0},
    /*204*/{50,-189,-1,0},
    /*205*/{3,-22,4,-22,5,-22,7,-22,8,-22,12,-22,13,-22,14,-22,15,-22,18,-22,22,-22,24,-22,25,-22,26,-22,27,-22,29,-22,30,-22,33,-22,35,-22,36,-22,37,-22,42,-22,43,-22,44,-22,45,-22,47,-22,48,-22,49,-22,61,-22,75,-22,79,-22,-1,0},
    /*206*/{50,-17,54,39,60,-218,-1,0},
    /*207*/{60,209,-1,0},
    /*208*/{3,-218,4,54,5,-218,7,-218,8,26,12,-218,13,27,14,10,18,-218,22,-218,24,13,25,-218,26,-218,27,56,33,53,35,-218,36,-218,37,12,42,23,43,-218,44,25,45,-218,47,-218,48,-218,49,-218,61,-218,75,-218,79,-218,-1,0},
    /*209*/{61,211,-1,0},
    /*210*/{50,-14,-1,0},
    /*211*/{60,213,-1,0},
    /*212*/{79,214,-1,0},
    /*213*/{51,217,61,-175,-1,0},
    /*214*/{61,216,-1,0},
    /*215*/{50,-174,59,-174,79,-174,-1,0},
    /*216*/{79,214,-1,0},
    /*217*/{61,-176,-1,0},
    /*218*/{79,-68,-1,0},
    /*219*/{79,-67,-1,0},
    /*220*/{79,-63,-1,0},
    /*221*/{75,48,79,-69,-1,0},
    /*222*/{79,-62,-1,0},
    /*223*/{79,-66,-1,0},
    /*224*/{79,-64,-1,0},
    /*225*/{79,-65,-1,0},
    /*226*/{79,-140,-1,0},
    /*227*/{79,229,-1,0},
    /*228*/{55,230,-1,0},
    /*229*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*230*/{50,-61,-1,0},
    /*231*/{39,233,-1,0},
    /*232*/{58,234,-1,0},
    /*233*/{5,84,7,74,13,27,22,70,25,42,35,93,43,78,48,94,75,44,79,41,-1,0},
    /*234*/{59,-164,-1,0},
    /*235*/{59,-162,-1,0},
    /*236*/{59,241,-1,0},
    /*237*/{59,-165,75,48,-1,0},
    /*238*/{59,-161,-1,0},
    /*239*/{59,-163,-1,0},
    /*240*/{60,242,-1,0},
    /*241*/{6,247,11,244,-1,0},
    /*242*/{61,291,-1,0},
    /*243*/{54,289,-1,0},
    /*244*/{6,247,11,244,61,-166,-1,0},
    /*245*/{3,89,5,84,7,74,12,98,13,27,17,256,18,86,22,70,25,42,26,95,34,265,35,93,36,85,37,12,43,78,44,25,45,81,48,94,49,96,75,44,79,41,-1,0},
    /*246*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*247*/{54,249,-1,0},
    /*248*/{3,-169,5,-169,6,247,7,-169,11,244,12,-169,13,-169,17,-169,18,-169,22,-169,25,-169,26,-169,34,-169,35,-169,36,-169,37,-169,43,-169,44,-169,45,-169,48,-169,49,-169,75,-169,79,-169,-1,0},
    /*249*/{3,-171,5,-171,7,-171,12,-171,13,-171,17,-171,18,-171,22,-171,25,-171,26,-171,34,-171,35,-171,36,-171,37,-171,43,-171,44,-171,45,-171,48,-171,49,-171,75,-171,79,-171,-1,0},
    /*250*/{50,-129,79,-129,-1,0},
    /*251*/{50,-131,79,-131,-1,0},
    /*252*/{50,287,-1,0},
    /*253*/{50,-114,79,-114,-1,0},
    /*254*/{50,-117,51,-117,65,-117,79,-117,-1,0},
    /*255*/{64,282,-1,0},
    /*256*/{50,-115,79,-115,-1,0},
    /*257*/{50,-130,79,-130,-1,0},
    /*258*/{50,-118,51,-118,65,-118,75,48,79,-118,-1,0},
    /*259*/{50,-127,51,-127,65,-127,79,-127,-1,0},
    /*260*/{79,273,-1,0},
    /*261*/{50,-126,51,-126,65,-126,79,-126,-1,0},
    /*262*/{50,-116,51,-116,65,-116,79,-116,-1,0},
    /*263*/{50,-128,51,-128,65,-128,79,-128,-1,0},
    /*264*/{64,266,-1,0},
    /*265*/{3,89,5,84,7,74,12,98,17,256,18,86,22,70,25,42,26,95,34,265,35,93,36,85,43,78,45,81,48,94,49,96,75,44,79,41,-1,0},
    /*266*/{51,268,65,269,-1,0},
    /*267*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*268*/{50,-179,51,-179,65,-179,79,-179,-1,0},
    /*269*/{65,271,-1,0},
    /*270*/{50,-178,51,-178,65,-178,79,-178,-1,0},
    /*271*/{50,-134,51,-134,-1,0},
    /*272*/{50,-136,51,-136,62,278,-1,0},
    /*273*/{50,-173,-1,0},
    /*274*/{50,-135,51,-135,-1,0},
    /*275*/{50,-186,51,-186,62,278,-1,0},
    /*276*/{50,-185,51,-185,-1,0},
    /*277*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*278*/{63,280,-1,0},
    /*279*/{50,-188,51,-188,62,-188,-1,0},
    /*280*/{50,-187,51,-187,-1,0},
    /*281*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*282*/{51,284,-1,0},
    /*283*/{16,116,25,42,40,105,56,102,57,117,58,107,66,110,67,106,74,108,75,44,78,122,79,41,82,112,84,101,85,103,-1,0},
    /*284*/{65,286,-1,0},
    /*285*/{50,-184,51,-184,65,-184,79,-184,-1,0},
    /*286*/{6,-168,11,-168,61,-168,-1,0},
    /*287*/{61,-167,-1,0},
    /*288*/{3,-170,5,-170,6,247,7,-170,11,244,12,-170,13,-170,17,-170,18,-170,22,-170,25,-170,26,-170,34,-170,35,-170,36,-170,37,-170,43,-170,44,-170,45,-170,48,-170,49,-170,75,-170,79,-170,-1,0},
    /*289*/{3,-172,5,-172,7,-172,12,-172,13,-172,17,-172,18,-172,22,-172,25,-172,26,-172,34,-172,35,-172,36,-172,37,-172,43,-172,44,-172,45,-172,48,-172,49,-172,75,-172,79,-172,-1,0},
    /*290*/{50,-160,79,-160,-1,0},
    /*291*/{0,-12,2,-12,8,-12,10,-12,13,-12,14,-12,21,-12,23,-12,24,-12,31,-12,37,-12,42,-12,44,-12,46,-12,61,-12,-1,0},
    /*292*/{50,-112,-1,0},
    /*293*/{79,273,-1,0},
    /*294*/{50,-133,51,297,-1,0},
    /*295*/{50,-113,-1,0},
    /*296*/{79,273,-1,0},
    /*297*/{50,-132,-1,0},
    /*298*/{79,300,-1,0},
    /*299*/{50,-19,54,39,60,-218,-1,0},
    /*300*/{60,302,-1,0},
    /*301*/{3,-218,4,54,5,-218,7,-218,8,26,12,-218,13,27,14,10,18,-218,22,-218,24,13,25,-218,26,-218,27,56,33,53,35,-218,36,-218,37,12,42,23,43,-218,44,25,45,-218,47,-218,48,-218,49,-218,61,-218,75,-218,79,-218,-1,0},
    /*302*/{61,304,-1,0},
    /*303*/{50,-16,-1,0},
    /*304*/{0,-9,2,-9,8,-9,10,-9,13,-9,14,-9,21,-9,23,-9,24,-9,31,-9,37,-9,42,-9,44,-9,46,-9,61,-9,-1,0},
    /*305*/{60,307,-1,0},
    /*306*/{2,29,8,26,10,8,13,27,14,10,21,28,23,19,24,13,31,22,37,12,42,23,44,25,46,16,-1,0},
    /*307*/{61,309,-1,0},
    /*308*/{50,-13,-1,0},
    /*309*/{0,-8,2,-8,8,-8,10,-8,13,-8,14,-8,21,-8,23,-8,24,-8,31,-8,37,-8,42,-8,44,-8,46,-8,61,-8,-1,0},
    /*310*/{3,89,5,84,7,74,12,98,13,27,17,256,18,86,22,70,25,42,26,95,34,265,35,93,36,85,37,12,38,316,43,78,44,25,45,81,48,94,49,96,50,-38,54,315,60,-218,75,44,79,41,-1,0},
    /*311*/{60,-47,-1,0},
    /*312*/{60,324,-1,0},
    /*313*/{50,-39,-1,0},
    /*314*/{25,-218,41,318,75,-218,79,-218,-1,0},
    /*315*/{25,42,75,44,79,41,-1,0},
    /*316*/{60,-45,-1,0},
    /*317*/{25,-48,75,-48,79,-48,-1,0},
    /*318*/{25,-49,75,-49,79,-49,-1,0},
    /*319*/{25,42,75,44,79,41,-1,0},
    /*320*/{38,322,60,-44,-1,0},
    /*321*/{25,42,75,44,79,41,-1,0},
    /*322*/{60,-46,-1,0},
    /*323*/{3,-218,4,54,5,-218,7,-218,8,26,12,-218,13,27,14,10,15,330,18,-218,22,-218,24,13,25,-218,26,-218,27,56,29,325,30,327,33,53,35,-218,36,-218,37,12,42,23,43,-218,44,25,45,-218,47,-218,48,-218,49,-218,61,-218,75,-218,79,-218,-1,0},
    /*324*/{3,89,5,84,7,74,12,98,13,27,17,256,18,86,22,70,25,42,26,95,34,265,35,93,36,85,37,12,43,78,44,25,45,81,48,94,49,96,75,44,79,41,-1,0},
    /*325*/{3,-53,4,-53,5,-53,7,-53,8,-53,12,-53,13,-53,14,-53,15,-53,18,-53,22,-53,24,-53,25,-53,26,-53,27,-53,29,-53,30,-53,33,-53,35,-53,36,-53,37,-53,42,-53,43,-53,44,-53,45,-53,47,-53,48,-53,49,-53,61,-53,75,-53,79,-53,-1,0},
    /*326*/{3,89,5,84,7,74,12,98,13,27,17,256,18,86,22,70,25,42,26,95,34,265,35,93,36,85,37,12,43,78,44,25,45,81,48,94,49,96,75,44,79,41,-1,0},
    /*327*/{3,-197,5,-197,7,-197,12,-197,18,-197,22,-197,25,-197,26,-197,35,-197,36,-197,43,-197,45,-197,47,-197,48,-197,49,-197,61,-51,75,-197,79,-197,-1,0},
    /*328*/{3,-52,4,-52,5,-52,7,-52,8,-52,12,-52,13,-52,14,-52,15,-52,18,-52,22,-52,24,-52,25,-52,26,-52,27,-52,29,-52,30,-52,33,-52,35,-52,36,-52,37,-52,42,-52,43,-52,44,-52,45,-52,47,-52,48,-52,49,-52,61,-52,75,-52,79,-52,-1,0},
    /*329*/{79,335,-1,0},
    /*330*/{61,334,-1,0},
    /*331*/{3,-218,4,54,5,-218,7,-218,8,26,12,-218,13,27,14,10,15,330,18,-218,22,-218,24,13,25,-218,26,-218,27,56,29,325,30,327,33,53,35,-218,36,-218,37,12,42,23,43,-218,44,25,45,-218,47,-218,48,-218,49,-218,61,-218,75,-218,79,-218,-1,0},
    /*332*/{61,-50,-1,0},
    /*333*/{50,-43,-1,0},
    /*334*/{58,336,-1,0},
    /*335*/{19,337,59,339,-1,0},
    /*336*/{3,89,5,84,7,74,12,98,18,86,22,70,25,42,26,95,35,93,36,85,43,78,45,81,48,94,49,96,75,44,79,41,-1,0},
    /*337*/{59,344,-1,0},
    /*338*/{50,343,-1,0},
    /*339*/{51,341,59,-58,-1,0},
    /*340*/{19,337,-1,0},
    /*341*/{59,-59,-1,0},
    /*342*/{3,-55,4,-55,5,-55,7,-55,8,-55,12,-55,13,-55,14,-55,15,-55,18,-55,22,-55,24,-55,25,-55,26,-55,27,-55,29,-55,30,-55,33,-55,35,-55,36,-55,37,-55,42,-55,43,-55,44,-55,45,-55,47,-55,48,-55,49,-55,61,-55,75,-55,79,-55,-1,0},
    /*343*/{50,345,-1,0},
    /*344*/{3,-54,4,-54,5,-54,7,-54,8,-54,12,-54,13,-54,14,-54,15,-54,18,-54,22,-54,24,-54,25,-54,26,-54,27,-54,29,-54,30,-54,33,-54,35,-54,36,-54,37,-54,42,-54,43,-54,44,-54,45,-54,47,-54,48,-54,49,-54,61,-54,75,-54,79,-54,-1,0},
    /*345*/{79,190,-1,0},
    /*346*/{51,-60,59,-60,-1,0},
    /*347*/{79,273,-1,0},
    /*348*/{50,350,-1,0},
    /*349*/{3,-56,4,-56,5,-56,7,-56,8,-56,12,-56,13,-56,14,-56,15,-56,18,-56,22,-56,24,-56,25,-56,26,-56,27,-56,29,-56,30,-56,33,-56,35,-56,36,-56,37,-56,42,-56,43,-56,44,-56,45,-56,47,-56,48,-56,49,-56,61,-56,75,-56,79,-56,-1,0},
    /*350*/{79,273,-1,0},
    /*351*/{50,353,-1,0},
    /*352*/{3,-57,4,-57,5,-57,7,-57,8,-57,12,-57,13,-57,14,-57,15,-57,18,-57,22,-57,24,-57,25,-57,26,-57,27,-57,29,-57,30,-57,33,-57,35,-57,36,-57,37,-57,42,-57,43,-57,44,-57,45,-57,47,-57,48,-57,49,-57,61,-57,75,-57,79,-57,-1,0},
    /*353*/{0,-5,61,-5,-1,0},
    /*354*/{50,-177,-1,0},
    /*355*/{60,357,-1,0},
    /*356*/{3,89,5,84,7,74,12,98,13,27,17,256,18,86,22,70,25,42,26,95,34,265,35,93,36,85,37,12,43,78,44,25,45,81,48,94,49,96,75,44,79,41,-1,0},
    /*357*/{61,364,-1,0},
    /*358*/{79,273,-1,0},
    /*359*/{3,89,5,84,7,74,12,98,13,27,17,256,18,86,22,70,25,42,26,95,34,265,35,93,36,85,37,12,43,78,44,25,45,81,48,94,49,96,61,-157,75,44,79,41,-1,0},
    /*360*/{61,-158,-1,0},
    /*361*/{50,363,-1,0},
    /*362*/{3,-159,5,-159,7,-159,12,-159,13,-159,17,-159,18,-159,22,-159,25,-159,26,-159,34,-159,35,-159,36,-159,37,-159,43,-159,44,-159,45,-159,48,-159,49,-159,61,-159,75,-159,79,-159,-1,0},
    /*363*/{50,-156,79,-156,-1,0},
    /*364*/{60,366,-1,0},
    /*365*/{3,89,5,84,7,74,12,98,13,27,17,256,18,86,22,70,25,42,26,95,34,265,35,93,36,85,37,12,43,78,44,25,45,81,48,94,49,96,61,368,75,44,79,41,-1,0},
    /*366*/{61,369,-1,0},
    /*367*/{50,-193,-1,0},
    /*368*/{50,-194,-1,0},
    /*369*/{0,-11,2,-11,8,-11,10,-11,13,-11,14,-11,21,-11,23,-11,24,-11,31,-11,37,-11,42,-11,44,-11,46,-11,61,-11,-1,0},
    /*370*/{79,372,-1,0},
    /*371*/{38,316,54,315,60,-218,-1,0},
    /*372*/{60,374,-1,0},
    /*373*/{3,-218,4,54,5,-218,7,-218,8,26,12,-218,13,27,14,10,15,330,18,-218,22,-218,24,13,25,-218,26,-218,27,56,29,325,30,327,33,53,35,-218,36,-218,37,12,42,23,43,-218,44,25,45,-218,47,-218,48,-218,49,-218,61,-218,75,-218,79,-218,-1,0},
    /*374*/{61,376,-1,0},
    /*375*/{50,-42,-1,0},
    /*376*/{0,-7,2,-7,8,-7,10,-7,13,-7,14,-7,21,-7,23,-7,24,-7,31,-7,37,-7,42,-7,44,-7,46,-7,61,-7,-1,0},
    /*377*/{0,-10,2,-10,8,-10,10,-10,13,-10,14,-10,21,-10,23,-10,24,-10,31,-10,37,-10,42,-10,44,-10,46,-10,61,-10,-1,0},
  };

  /** access to parse action table */
  public short[][] action_table() {return _action_table;}

  /** reduce_goto table */
  protected static final short[][] _reduce_table = {
    /*0*/{4,3,9,2,96,1,-1,-1},
    /*1*/{10,13,11,32,12,8,13,5,17,23,18,16,19,14,27,17,39,6,45,30,49,10,50,31,51,20,52,29,53,19,-1,-1},
    /*2*/{-1,-1},
    /*3*/{-1,-1},
    /*4*/{-1,-1},
    /*5*/{-1,-1},
    /*6*/{-1,-1},
    /*7*/{-1,-1},
    /*8*/{-1,-1},
    /*9*/{-1,-1},
    /*10*/{-1,-1},
    /*11*/{-1,-1},
    /*12*/{79,354,-1,-1},
    /*13*/{10,13,11,353,12,8,13,5,17,23,18,16,19,14,27,17,39,6,45,30,49,10,50,31,51,20,52,29,53,19,-1,-1},
    /*14*/{-1,-1},
    /*15*/{-1,-1},
    /*16*/{-1,-1},
    /*17*/{-1,-1},
    /*18*/{-1,-1},
    /*19*/{-1,-1},
    /*20*/{-1,-1},
    /*21*/{-1,-1},
    /*22*/{16,258,40,292,41,293,46,253,47,254,48,256,49,251,50,250,52,257,57,262,58,78,59,91,60,81,62,87,63,74,64,90,65,89,66,70,67,82,68,67,69,86,71,259,72,261,73,263,-1,-1},
    /*23*/{-1,-1},
    /*24*/{-1,-1},
    /*25*/{16,221,28,227,58,222,59,225,60,81,61,223,62,87,63,74,64,90,65,89,66,220,67,224,68,218,71,219,-1,-1},
    /*26*/{-1,-1},
    /*27*/{-1,-1},
    /*28*/{-1,-1},
    /*29*/{-1,-1},
    /*30*/{-1,-1},
    /*31*/{-1,-1},
    /*32*/{-1,-1},
    /*33*/{-1,-1},
    /*34*/{-1,-1},
    /*35*/{-1,-1},
    /*36*/{4,39,93,37,-1,-1},
    /*37*/{-1,-1},
    /*38*/{16,42,90,44,-1,-1},
    /*39*/{-1,-1},
    /*40*/{-1,-1},
    /*41*/{-1,-1},
    /*42*/{-1,-1},
    /*43*/{-1,-1},
    /*44*/{-1,-1},
    /*45*/{-1,-1},
    /*46*/{16,42,90,49,-1,-1},
    /*47*/{-1,-1},
    /*48*/{-1,-1},
    /*49*/{-1,-1},
    /*50*/{4,58,5,57,14,54,15,62,27,59,39,51,45,30,49,10,50,31,51,61,52,29,53,19,84,60,85,56,-1,-1},
    /*51*/{-1,-1},
    /*52*/{-1,-1},
    /*53*/{16,71,43,197,57,76,58,78,59,91,60,81,62,87,63,74,64,90,65,89,66,70,67,82,68,67,69,86,71,68,-1,-1},
    /*54*/{-1,-1},
    /*55*/{-1,-1},
    /*56*/{-1,-1},
    /*57*/{16,71,42,72,43,75,57,76,58,78,59,91,60,81,62,87,63,74,64,90,65,89,66,70,67,82,68,67,69,86,70,79,71,68,-1,-1},
    /*58*/{-1,-1},
    /*59*/{-1,-1},
    /*60*/{-1,-1},
    /*61*/{-1,-1},
    /*62*/{4,58,5,57,14,63,15,62,27,59,39,51,45,30,49,10,50,31,51,61,52,29,53,19,84,60,85,56,-1,-1},
    /*63*/{-1,-1},
    /*64*/{-1,-1},
    /*65*/{-1,-1},
    /*66*/{-1,-1},
    /*67*/{-1,-1},
    /*68*/{-1,-1},
    /*69*/{-1,-1},
    /*70*/{-1,-1},
    /*71*/{-1,-1},
    /*72*/{-1,-1},
    /*73*/{-1,-1},
    /*74*/{-1,-1},
    /*75*/{-1,-1},
    /*76*/{-1,-1},
    /*77*/{63,160,64,162,65,161,-1,-1},
    /*78*/{-1,-1},
    /*79*/{-1,-1},
    /*80*/{-1,-1},
    /*81*/{-1,-1},
    /*82*/{-1,-1},
    /*83*/{-1,-1},
    /*84*/{-1,-1},
    /*85*/{-1,-1},
    /*86*/{-1,-1},
    /*87*/{-1,-1},
    /*88*/{-1,-1},
    /*89*/{-1,-1},
    /*90*/{-1,-1},
    /*91*/{-1,-1},
    /*92*/{-1,-1},
    /*93*/{-1,-1},
    /*94*/{-1,-1},
    /*95*/{-1,-1},
    /*96*/{-1,-1},
    /*97*/{-1,-1},
    /*98*/{8,124,16,103,29,122,30,112,31,113,32,99,33,118,34,123,35,108,36,120,37,110,38,114,74,117,75,119,-1,-1},
    /*99*/{-1,-1},
    /*100*/{-1,-1},
    /*101*/{-1,-1},
    /*102*/{-1,-1},
    /*103*/{-1,-1},
    /*104*/{-1,-1},
    /*105*/{-1,-1},
    /*106*/{8,124,16,103,29,152,31,113,32,99,33,118,34,123,35,108,36,120,37,110,38,114,74,117,75,119,-1,-1},
    /*107*/{-1,-1},
    /*108*/{-1,-1},
    /*109*/{-1,-1},
    /*110*/{-1,-1},
    /*111*/{-1,-1},
    /*112*/{-1,-1},
    /*113*/{-1,-1},
    /*114*/{-1,-1},
    /*115*/{-1,-1},
    /*116*/{-1,-1},
    /*117*/{-1,-1},
    /*118*/{-1,-1},
    /*119*/{-1,-1},
    /*120*/{-1,-1},
    /*121*/{-1,-1},
    /*122*/{-1,-1},
    /*123*/{-1,-1},
    /*124*/{16,103,38,125,74,117,75,119,-1,-1},
    /*125*/{-1,-1},
    /*126*/{8,124,16,103,35,139,36,120,37,110,38,114,74,117,75,119,-1,-1},
    /*127*/{8,124,16,103,35,128,36,120,37,110,38,114,74,117,75,119,-1,-1},
    /*128*/{-1,-1},
    /*129*/{8,124,16,103,36,138,37,110,38,114,74,117,75,119,-1,-1},
    /*130*/{8,124,16,103,36,131,37,110,38,114,74,117,75,119,-1,-1},
    /*131*/{-1,-1},
    /*132*/{8,124,16,103,37,137,38,114,74,117,75,119,-1,-1},
    /*133*/{8,124,16,103,37,136,38,114,74,117,75,119,-1,-1},
    /*134*/{8,124,16,103,37,135,38,114,74,117,75,119,-1,-1},
    /*135*/{-1,-1},
    /*136*/{-1,-1},
    /*137*/{-1,-1},
    /*138*/{-1,-1},
    /*139*/{-1,-1},
    /*140*/{-1,-1},
    /*141*/{-1,-1},
    /*142*/{-1,-1},
    /*143*/{8,124,16,103,34,144,35,108,36,120,37,110,38,114,74,117,75,119,-1,-1},
    /*144*/{-1,-1},
    /*145*/{8,124,16,103,32,146,33,118,34,123,35,108,36,120,37,110,38,114,74,117,75,119,-1,-1},
    /*146*/{-1,-1},
    /*147*/{8,124,16,103,33,148,34,123,35,108,36,120,37,110,38,114,74,117,75,119,-1,-1},
    /*148*/{-1,-1},
    /*149*/{-1,-1},
    /*150*/{-1,-1},
    /*151*/{-1,-1},
    /*152*/{-1,-1},
    /*153*/{-1,-1},
    /*154*/{-1,-1},
    /*155*/{-1,-1},
    /*156*/{-1,-1},
    /*157*/{8,124,16,103,29,122,30,158,31,113,32,99,33,118,34,123,35,108,36,120,37,110,38,114,74,117,75,119,-1,-1},
    /*158*/{-1,-1},
    /*159*/{-1,-1},
    /*160*/{-1,-1},
    /*161*/{-1,-1},
    /*162*/{-1,-1},
    /*163*/{89,165,-1,-1},
    /*164*/{6,187,82,186,88,184,-1,-1},
    /*165*/{4,168,83,167,-1,-1},
    /*166*/{-1,-1},
    /*167*/{2,169,4,170,-1,-1},
    /*168*/{-1,-1},
    /*169*/{-1,-1},
    /*170*/{-1,-1},
    /*171*/{-1,-1},
    /*172*/{3,174,75,173,-1,-1},
    /*173*/{-1,-1},
    /*174*/{-1,-1},
    /*175*/{-1,-1},
    /*176*/{3,177,75,173,-1,-1},
    /*177*/{-1,-1},
    /*178*/{16,42,90,179,-1,-1},
    /*179*/{-1,-1},
    /*180*/{-1,-1},
    /*181*/{-1,-1},
    /*182*/{-1,-1},
    /*183*/{-1,-1},
    /*184*/{-1,-1},
    /*185*/{-1,-1},
    /*186*/{-1,-1},
    /*187*/{16,71,43,188,57,76,58,78,59,91,60,81,62,87,63,74,64,90,65,89,66,70,67,82,68,67,69,86,71,68,-1,-1},
    /*188*/{79,190,-1,-1},
    /*189*/{-1,-1},
    /*190*/{-1,-1},
    /*191*/{6,187,82,186,88,192,-1,-1},
    /*192*/{-1,-1},
    /*193*/{-1,-1},
    /*194*/{-1,-1},
    /*195*/{-1,-1},
    /*196*/{-1,-1},
    /*197*/{79,198,91,199,-1,-1},
    /*198*/{-1,-1},
    /*199*/{-1,-1},
    /*200*/{79,198,91,201,-1,-1},
    /*201*/{-1,-1},
    /*202*/{16,71,43,203,57,76,58,78,59,91,60,81,62,87,63,74,64,90,65,89,66,70,67,82,68,67,69,86,71,68,-1,-1},
    /*203*/{79,198,91,204,-1,-1},
    /*204*/{-1,-1},
    /*205*/{-1,-1},
    /*206*/{4,39,93,207,-1,-1},
    /*207*/{-1,-1},
    /*208*/{4,58,5,57,14,209,15,62,27,59,39,51,45,30,49,10,50,31,51,61,52,29,53,19,84,60,85,56,-1,-1},
    /*209*/{-1,-1},
    /*210*/{-1,-1},
    /*211*/{-1,-1},
    /*212*/{94,214,-1,-1},
    /*213*/{-1,-1},
    /*214*/{-1,-1},
    /*215*/{-1,-1},
    /*216*/{94,217,-1,-1},
    /*217*/{-1,-1},
    /*218*/{-1,-1},
    /*219*/{-1,-1},
    /*220*/{-1,-1},
    /*221*/{-1,-1},
    /*222*/{-1,-1},
    /*223*/{-1,-1},
    /*224*/{-1,-1},
    /*225*/{-1,-1},
    /*226*/{-1,-1},
    /*227*/{-1,-1},
    /*228*/{-1,-1},
    /*229*/{8,124,16,103,29,230,31,113,32,99,33,118,34,123,35,108,36,120,37,110,38,114,74,117,75,119,-1,-1},
    /*230*/{-1,-1},
    /*231*/{-1,-1},
    /*232*/{-1,-1},
    /*233*/{16,237,44,236,49,234,58,238,63,74,64,90,65,89,66,235,67,239,-1,-1},
    /*234*/{-1,-1},
    /*235*/{-1,-1},
    /*236*/{-1,-1},
    /*237*/{-1,-1},
    /*238*/{-1,-1},
    /*239*/{-1,-1},
    /*240*/{-1,-1},
    /*241*/{54,242,55,244,87,245,-1,-1},
    /*242*/{-1,-1},
    /*243*/{-1,-1},
    /*244*/{54,287,55,244,87,245,-1,-1},
    /*245*/{16,258,41,260,46,253,47,254,48,256,49,251,50,250,52,257,56,252,57,262,58,78,59,91,60,81,62,87,63,74,64,90,65,89,66,70,67,82,68,67,69,86,71,259,72,261,73,263,-1,-1},
    /*246*/{8,124,16,103,29,247,31,113,32,99,33,118,34,123,35,108,36,120,37,110,38,114,74,117,75,119,-1,-1},
    /*247*/{-1,-1},
    /*248*/{87,249,-1,-1},
    /*249*/{-1,-1},
    /*250*/{-1,-1},
    /*251*/{-1,-1},
    /*252*/{-1,-1},
    /*253*/{-1,-1},
    /*254*/{-1,-1},
    /*255*/{-1,-1},
    /*256*/{-1,-1},
    /*257*/{-1,-1},
    /*258*/{-1,-1},
    /*259*/{-1,-1},
    /*260*/{78,273,79,271,80,274,-1,-1},
    /*261*/{-1,-1},
    /*262*/{-1,-1},
    /*263*/{-1,-1},
    /*264*/{-1,-1},
    /*265*/{16,258,46,266,47,254,57,262,58,78,59,91,60,81,62,87,63,74,64,90,65,89,66,70,67,82,68,67,69,86,71,259,72,261,73,263,-1,-1},
    /*266*/{-1,-1},
    /*267*/{8,124,16,103,29,122,30,269,31,113,32,99,33,118,34,123,35,108,36,120,37,110,38,114,74,117,75,119,-1,-1},
    /*268*/{-1,-1},
    /*269*/{-1,-1},
    /*270*/{-1,-1},
    /*271*/{-1,-1},
    /*272*/{81,275,95,276,-1,-1},
    /*273*/{-1,-1},
    /*274*/{-1,-1},
    /*275*/{81,275,95,280,-1,-1},
    /*276*/{-1,-1},
    /*277*/{8,124,16,103,29,122,30,278,31,113,32,99,33,118,34,123,35,108,36,120,37,110,38,114,74,117,75,119,-1,-1},
    /*278*/{-1,-1},
    /*279*/{-1,-1},
    /*280*/{-1,-1},
    /*281*/{8,124,16,103,29,122,30,282,31,113,32,99,33,118,34,123,35,108,36,120,37,110,38,114,74,117,75,119,-1,-1},
    /*282*/{-1,-1},
    /*283*/{8,124,16,103,29,122,30,284,31,113,32,99,33,118,34,123,35,108,36,120,37,110,38,114,74,117,75,119,-1,-1},
    /*284*/{-1,-1},
    /*285*/{-1,-1},
    /*286*/{-1,-1},
    /*287*/{-1,-1},
    /*288*/{87,289,-1,-1},
    /*289*/{-1,-1},
    /*290*/{-1,-1},
    /*291*/{-1,-1},
    /*292*/{-1,-1},
    /*293*/{78,294,79,271,80,274,92,295,-1,-1},
    /*294*/{-1,-1},
    /*295*/{-1,-1},
    /*296*/{78,294,79,271,80,274,92,297,-1,-1},
    /*297*/{-1,-1},
    /*298*/{-1,-1},
    /*299*/{4,39,93,300,-1,-1},
    /*300*/{-1,-1},
    /*301*/{4,58,5,57,14,302,15,62,27,59,39,51,45,30,49,10,50,31,51,61,52,29,53,19,84,60,85,56,-1,-1},
    /*302*/{-1,-1},
    /*303*/{-1,-1},
    /*304*/{-1,-1},
    /*305*/{-1,-1},
    /*306*/{10,13,11,307,12,8,13,5,17,23,18,16,19,14,27,17,39,6,45,30,49,10,50,31,51,20,52,29,53,19,-1,-1},
    /*307*/{-1,-1},
    /*308*/{-1,-1},
    /*309*/{-1,-1},
    /*310*/{4,311,16,258,21,312,41,313,46,253,47,254,48,256,49,251,50,250,52,257,57,262,58,78,59,91,60,81,62,87,63,74,64,90,65,89,66,70,67,82,68,67,69,86,71,259,72,261,73,263,-1,-1},
    /*311*/{-1,-1},
    /*312*/{-1,-1},
    /*313*/{-1,-1},
    /*314*/{4,318,7,319,-1,-1},
    /*315*/{16,42,90,316,-1,-1},
    /*316*/{-1,-1},
    /*317*/{-1,-1},
    /*318*/{-1,-1},
    /*319*/{16,42,90,320,-1,-1},
    /*320*/{-1,-1},
    /*321*/{16,42,90,322,-1,-1},
    /*322*/{-1,-1},
    /*323*/{4,327,5,57,15,328,22,330,23,331,24,325,27,59,39,51,45,30,49,10,50,31,51,61,52,29,53,19,84,60,85,56,-1,-1},
    /*324*/{16,258,41,350,46,253,47,254,48,256,49,251,50,250,52,257,57,262,58,78,59,91,60,81,62,87,63,74,64,90,65,89,66,70,67,82,68,67,69,86,71,259,72,261,73,263,-1,-1},
    /*325*/{-1,-1},
    /*326*/{16,258,41,347,46,253,47,254,48,256,49,251,50,250,52,257,57,262,58,78,59,91,60,81,62,87,63,74,64,90,65,89,66,70,67,82,68,67,69,86,71,259,72,261,73,263,-1,-1},
    /*327*/{-1,-1},
    /*328*/{-1,-1},
    /*329*/{-1,-1},
    /*330*/{-1,-1},
    /*331*/{4,327,5,57,15,328,22,332,23,331,24,325,27,59,39,51,45,30,49,10,50,31,51,61,52,29,53,19,84,60,85,56,-1,-1},
    /*332*/{-1,-1},
    /*333*/{-1,-1},
    /*334*/{-1,-1},
    /*335*/{25,337,26,339,-1,-1},
    /*336*/{16,71,43,345,57,76,58,78,59,91,60,81,62,87,63,74,64,90,65,89,66,70,67,82,68,67,69,86,71,68,-1,-1},
    /*337*/{-1,-1},
    /*338*/{-1,-1},
    /*339*/{-1,-1},
    /*340*/{25,341,26,339,-1,-1},
    /*341*/{-1,-1},
    /*342*/{-1,-1},
    /*343*/{-1,-1},
    /*344*/{-1,-1},
    /*345*/{79,346,-1,-1},
    /*346*/{-1,-1},
    /*347*/{78,294,79,271,80,274,92,348,-1,-1},
    /*348*/{-1,-1},
    /*349*/{-1,-1},
    /*350*/{78,294,79,271,80,274,92,351,-1,-1},
    /*351*/{-1,-1},
    /*352*/{-1,-1},
    /*353*/{-1,-1},
    /*354*/{-1,-1},
    /*355*/{-1,-1},
    /*356*/{16,258,41,358,46,253,47,254,48,256,49,251,50,250,52,257,57,262,58,78,59,91,60,81,62,87,63,74,64,90,65,89,66,70,67,82,68,67,69,86,71,259,72,261,73,263,77,359,86,357,-1,-1},
    /*357*/{-1,-1},
    /*358*/{78,294,79,271,80,274,92,361,-1,-1},
    /*359*/{16,258,41,358,46,253,47,254,48,256,49,251,50,250,52,257,57,262,58,78,59,91,60,81,62,87,63,74,64,90,65,89,66,70,67,82,68,67,69,86,71,259,72,261,73,263,77,359,86,360,-1,-1},
    /*360*/{-1,-1},
    /*361*/{-1,-1},
    /*362*/{-1,-1},
    /*363*/{-1,-1},
    /*364*/{-1,-1},
    /*365*/{16,258,41,358,46,253,47,254,48,256,49,251,50,250,52,257,57,262,58,78,59,91,60,81,62,87,63,74,64,90,65,89,66,70,67,82,68,67,69,86,71,259,72,261,73,263,77,359,86,366,-1,-1},
    /*366*/{-1,-1},
    /*367*/{-1,-1},
    /*368*/{-1,-1},
    /*369*/{-1,-1},
    /*370*/{-1,-1},
    /*371*/{4,311,21,372,-1,-1},
    /*372*/{-1,-1},
    /*373*/{4,327,5,57,15,328,22,374,23,331,24,325,27,59,39,51,45,30,49,10,50,31,51,61,52,29,53,19,84,60,85,56,-1,-1},
    /*374*/{-1,-1},
    /*375*/{-1,-1},
    /*376*/{-1,-1},
    /*377*/{-1,-1},
  };

  /** access to reduce_goto table */
  public short[][] reduce_table() {return _reduce_table;}

  /** instance of action encapsulation class */
  protected CUP$actions action_obj;

  /** action encapsulation object initializer */
  protected void init_actions()
    {
      action_obj = new CUP$actions();
    }

  /** invoke a user supplied parse action */
  public java_cup.runtime.symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$do_action(act_num, parser, stack, top);
  }

  /** start state */
  public int start_state() {return 0;}
  /** start production */
  public int start_production() {return 0;}

  /** EOF symbol index */
  public int EOF_sym() {return 0;}

  /** error symbol index */
  public int error_sym() {return 1;}


  /** user initialization */
  public void user_init() throws java.lang.Exception
    {
 
        lexer.init(); 

    }

  /** scan to get the next token */
  public java_cup.runtime.token scan()
    throws java.lang.Exception
    {
 
        return lexer.next_token(); 

    }



    static String command_line[] = null;

    public static Vector import_list = new Vector();
    public static Hashtable pack_replace = new Hashtable();
    public static Stack scopes = new Stack();

    public static String currentVersion = "";
    public static String compiler_version = "1.4 beta 2, 26 October 2001";

    static String out_dir = "."; 
    static String package_prefix = null;

    static boolean parse_only = false;
    static boolean global_import = false;

    /** compiler flags */
    public static boolean include_state = false;
    public static boolean strict_names = true;

    public static boolean generateIR = false;
    public static boolean generate_skeletons = true;
    public static boolean generate_stubs = true;

    private static boolean generateIncluded = false;
    private static boolean inhibitionState = false;
    private static boolean localityContraint = false;

    private static int activeParseThreads;

    /*  a la CORBA 2.4, allow forward declarations that remain undefined */
    public static boolean sloppy = false;

    /**
     *  allows reinitialization if compiler is not 
     *  run from a command-line
     */

    private static void init()
    {
        command_line = null;
        import_list = new Vector();
        pack_replace = new Hashtable();
        scopes = new Stack();

        out_dir = "."; 
        package_prefix = null;

        parse_only = false;
        global_import = false;

        include_state = false;
        generateIR = false;
        generate_skeletons = true;

        generateIncluded = false;
        boolean inhibitionState = false;
        boolean localityContraint = false;
    }

    public static void main( String argv[] ) 
    {
        //        init();
        boolean result = compile( argv );
    }

    
    public static boolean compile( String argv[] ) 
    {
        init();
        Hashtable tmpDefines = new Hashtable();
        Hashtable tmpUnDefines = new Hashtable();
        try
        {
            command_line = argv;
            if( argv.length > 0 )
            {
                int i;
                for( i = 0; i < argv.length; i++ )
                {
                    if( argv[i].equals("-syntax"))
                    {
                        parse_only = true;
                        continue;
                    } 
                    if( argv[i].equals("-global_import"))
                    {
                        global_import = true;
                        continue;
                    } 
                    if( argv[i].equals("-noskel"))
                    {
                        generate_skeletons = false;
                        continue;
                    } 
                    if( argv[i].equals("-nostub"))
                    {
                        generate_stubs = false;
                        continue;
                    } 
                    if( argv[i].equals("-sloppy_forward"))
                    {
                        sloppy = true;
                        continue;
                    } 
                    if( argv[i].equals("-sloppy_names"))
                    {
                        strict_names = false;
                        continue;
                    } 
                    if( argv[i].equals("-d")) 
                    {
                        if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                            usage(argv, "-d");
                        out_dir = argv[++i];
                        continue;
                    } 
                    if( argv[i].equals("-W")) 
                    {
                        if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                            usage(argv, "-W");
                        org.jacorb.idl.Environment.verbosityLevel(Integer.parseInt( argv[++i]));
                        continue;
                    } 
                    if( argv[i].startsWith("-D")) 
                    {
                        String def = argv[i].substring(2);
                        String val;
                        
                        if( def.indexOf('=') > 0 )
                        {
                            val = def.substring( def.indexOf('=') + 1);
                            def = def.substring( 0, def.indexOf('='));
                        }
                        else
                            val = "1";
                        tmpDefines.put( def, val );
                        continue;
                    }
                    if( argv[i].startsWith("-U")) 
                    {
                        tmpUnDefines.put( argv[i].substring(2), "" );
                        continue;
                    } 
                    if( argv[i].equals("-p")) 
                    {
                        if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                            usage(argv, "-p");
                        package_prefix = argv[++i];
                        continue;
                    } 
                    if( argv[i].equals("-i2jpackage")) 
                    {
                        if( i+1 == argv.length || argv[i+1].charAt(0)=='-')
                            usage(argv, "-i2jpackage");

                        int split_idx = argv[i+1].indexOf(':');
                        if( split_idx  < 0 )
                            usage(argv, "-i2jpackage");
                        String idlp = argv[i+1].substring(0,split_idx);
                        String jp = argv[i+1].substring(split_idx+1);

                        pack_replace.put( idlp, jp );
                        Environment.output(3,"Replace pack " + idlp + " with " + jp );
                        i++;
                        continue;
                    } 
                    if( argv[i].equals("-ir")) 
                    {  
                        generateIR = true;
                        continue;
                    } 
                    if( argv[i].equals("-i")) 
                    {
                        if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                            usage(argv, "-i");
                        import_list.addElement( argv[++i]) ;
                        continue;
                    } 
                    if( argv[i].startsWith("-I")) 
                    {
                        GlobalInputStream.setIncludePath(argv[i].substring(2));
                        continue;
                    }
                    if( argv[i].equals("-h") || argv[i].equals("-help") )
                    {
                        help();
                        System.exit(0);
                    }
                    if( argv[i].equals("-all"))
                    {
                        generateIncluded = true;
                        continue;
                    }
                    if( argv[i].equals("-v") || argv[i].equals("-version"))
                    {
                        version();
                        System.exit(0);
                    }
                    if( argv[i].endsWith(".idl"))
                    {
                        break;
                    }

                    // else:
                    usage(argv, "Unrecognized option");

                }
                for( int j=i; j < argv.length; j++)
                {
                    if( argv[j].endsWith(".idl"))
                    {
                        Environment.output( 4, argv[j] );
                        GlobalInputStream.init();
                        try
                        {               
                            GlobalInputStream.setInput( argv[j] );
                        }       
                        catch (java.io.IOException io )
                        {
                            System.err.println("Could not find file " + argv[j]);
                            parser.help();
                        }
                                /* reset tables everywhere */
                        lexer.reset();
                        NameTable.init();
                        ConstDecl.init();
                        TypeMap.init();

                                /* define/undefine symbols */
                        for( Enumeration e = tmpDefines.keys(); e.hasMoreElements(); )
                        {
                            String key = (String)e.nextElement();
                            lexer.define( key, (String)tmpDefines.get( key ));
                        }
                        for( Enumeration e = tmpUnDefines.keys(); e.hasMoreElements(); )
                        {
                            lexer.undefine( (String)e.nextElement() );
                        }
                        new parser().parse();
                    }
                    else
                    {
                        System.err.println("Not an IDL file:" + argv[j]);
                    }
                }
            }
        }
        catch( org.jacorb.idl.ParseException e )
        {
            return false;
        }
        catch( Exception e )
        {
            System.err.println( "Error: " + e.getMessage());
            org.jacorb.idl.Environment.output( 2, e );
            usage(argv, e.getMessage());
        }
        return true;
    }

    public static void usage(String [] argv, String msg)
    {
        // debug:
        for( int i = 0; i < argv.length; i++)
            System.out.print( argv[i] + " " );
        System.out.println(" : " + msg);

        System.out.println("Usage: idl [-h|-help][-v|-version][-syntax][-all][-Idir][-Dsymbol[=value]][-U <symbol>][-noskel][-nostub][-ir][-sloppy_names] [-i2jpackage x:y][-d <Output Dir>][-p <package_prefix>][-i <import_package][-W debug_level] <filelist>");
        System.exit(1);
    }

    private static void help()
    {     
        System.out.println("\t-syntax\tsyntax check only, no code generation, implies -no_ir");
//ystem.out.println("\t-no_ir\tdo not generate information for the Interface Repository");
        System.out.println("\t-noskel\tdisables generation of POA skeletons");
        System.out.println("\t-nostub\tdisables generation of client stubs");
        System.out.println("\t-Idir\tset include path for idl files");
        System.out.println("\t-sloppy_forward\tallow forward declarations wo. later definitions");
        System.out.println("\t-sloppy_names\tless strict checking of names for backward compatibility");
        System.out.println("\t-Dx\tdefine preprocessor symbol x with value 1");
        System.out.println("\t-Dx=y\tdefine preprocessor symbol x with value y");
        System.out.println("\t-U\tundefine preprocessor symbol");
        System.out.println("\t-p pack\tapply pack as prefix to all names in generated Java code");
        System.out.println("\t\t\tand put code into package <pack>");
        System.out.println("\t-i2jpackage x:a.b.c\t replace IDL package name x by a.b.c in generated Java code (e.g. CORBA:org.omg.CORBA)");
        System.out.println("\t-i <x>\tgenerated Java code will include \"import <x>;\"");
        System.out.println("\t-ir <x>\tgenerate information required by the Interface Repository");
        System.out.println("\t-global_import \tgenerated Java code will include import statements for all global types");
        System.out.println("\t-d dir\troot of directory tree for output");
        System.out.println("\t-W [1..4]\tdebug level");
        System.out.println("\t-all generate code for all IDL files, even included ones");
        System.out.println("\t-v|version \tprint version information");
        System.out.println("\t-h|help \tthese few lines of help");
        System.out.println("\t<filelist>\t");
  }

  private static void version()
  {
        System.out.println("JacORB IDL compiler V" + compiler_version + ",\n   (C) Gerald Brose, FU Berlin, 1997-2001.");
  }


    /* override error routines */

    public void report_fatal_error( String message, Object info)
        throws ParseException
    {
       done_parsing();
       lexer.emit_error(message);
       System.err.println("Can't recover from previous error(s), giving up.");
       throw new ParseException();
       // System.exit(1);
    }

    public static void fatal_error(String message, str_token p_info)
        throws ParseException
    {
       //done_parsing();
       lexer.emit_error(message, p_info);
       System.err.println("Can't recover from previous error(s), giving up.");
       throw new ParseException();
       // System.exit(1);
    }

    public void report_error(String message, Object info)
    {
       lexer.emit_error(message);
    }

    public static void error(String message, str_token p_info)
    {
       lexer.emit_error(message, p_info);
    }

    public static void error( String message )
    {
       lexer.emit_error( message );
    }

        /* bookkeeping with IDL scopes */

        /** called from the lexer/scanner whenever a scope opening
            symbol is encountered */

        public static void openScope()
        {
            scopes.push(new ScopeData());
        }

        /** called from within the parser whenever parsing a scope 
            symbol is complete */

        public static void closeScope(Scope symbol)
        {
                ScopeData data = (ScopeData) scopes.pop();
                symbol.setScopeData( data );
        }

        public static ScopeData currentScopeData()
        {
                return (ScopeData)scopes.peek();
        }


        // an interface inheriting from an forward declared interface
        // needs to wait on an object until the ancestor has been parsed
        // if get_pending returns null, the ancestor was not forward 
        // declared and thus has already been parsed

        // forward declared interfaces are put into this list

      public static java.util.Hashtable pending_interfaces = new java.util.Hashtable();

      public static synchronized void set_pending( String name )
      {
           // name will only be marked pending if it has not already been
           // parsed before and if is not already pending

           if( ! ( pending_interfaces.containsKey(name) ||
                   NameTable.parsed_interfaces.containsKey(name)) )
           {
                   pending_interfaces.put(name, new Object());
           }
      }

       public static synchronized void remove_pending( String name )
       {
            Object o = pending_interfaces.remove(name);
            if( o != null) 
            {
                synchronized( o )
                { 
                     o.notifyAll();
                }
            }
            if( pending_interfaces.size() == 0 )
            {
                // notify the main thread that the parsing phase is complete
                synchronized( pending_interfaces )
                {
                     pending_interfaces.notifyAll();
                }
            }
       }

      public static Object get_pending( String name )
      {
          return pending_interfaces.get(name);
      }

      public static synchronized void decActiveParseThreads()
      {
          Environment.output(3,"decActiveParseThreads");
          activeParseThreads--;
      }

      public static synchronized void incActiveParseThreads()
      {
          Environment.output(3,"incActiveParseThreads");
          activeParseThreads++;
      }

      public static synchronized int activeParseThreads()
      {
          Environment.output(3,"activeParseThreads returns "+activeParseThreads );
          return activeParseThreads;
      }

        public static boolean generateIncluded()
        {
                return generateIncluded;
        }

        /**
         * sets locality constraint
         */

        public static void setLocalityContraint()
        {
                localityContraint = true;
        }

    /**
      * return the current locality constraint, resets constraint
      */

    public static boolean getLocalityContraint()
    {
        boolean result = localityContraint;
        localityContraint = false;
        return result;
    }

    public static boolean getInhibitionState()
    {
        return inhibitionState;
    }

    public static void setInhibitionState(boolean flag)
    {
        inhibitionState = flag;
    }

    public static void set_included( boolean i )
    {
        include_state = i;
    }




    public static boolean hasImports()
    {
        return import_list.size() > 0 ;
    }

    static void addGlobalNamesToImport()
    {
        for( Enumeration e = NameTable.getGlobalTypes(); 
                e.hasMoreElements(); )
        {
                String s = (String) e.nextElement();
                import_list.addElement( s );
                Environment.output(4,"Adding import for global name " + s );
        }       
    }


    /** 
     * Package replacements as requested
     * by compiler options
     */

    public static String pack_replace(String old)
    {
//        for( Enumeration e = pack_replace.keys(); e.hasMoreElements();)
//        {
//              String key = (String)e.nextElement();
//
//              Environment.output(4,"Comparing name " + old + " with key " + key );
//
//              if( old.startsWith( key ))
//              {
//                  String result = (String)pack_replace.get( key ) + 
//                                   old.substring( key.length() + 1 );
//                  return result;
//              }
//        }
//        return old;

        String n_str = (String)pack_replace.get(old);
        if( n_str == null )
            return old;
        else
            return n_str;
    }


};

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$actions {




  /** Constructor */
  CUP$actions() { }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.symbol CUP$do_action(
    int                        CUP$act_num,
    java_cup.runtime.lr_parser CUP$parser,
    java.util.Stack            CUP$stack,
    int                        CUP$top)
    throws java.lang.Exception
    {
      /* object for return from actions */
      java_cup.runtime.symbol CUP$result;

      /* select the action based on the action number */
      switch (CUP$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // empty ::= 
            {
              CUP$result = new java_cup.runtime.symbol(/*empty*/4);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // param_type_spec ::= scopename 
            {
              CUP$result = new TypeSpec(/*param_type_spec*/43);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // param_type_spec ::= string_type 
            {
              CUP$result = new TypeSpec(/*param_type_spec*/43);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(StringType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // param_type_spec ::= base_type_spec 
            {
              CUP$result = new TypeSpec(/*param_type_spec*/43);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(BaseType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // string_literal_list ::= string_literal COMMA string_literal_list 
            {
              CUP$result = new java_cup.runtime.symbol(/*string_literal_list*/3);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // string_literal_list ::= string_literal 
            {
              CUP$result = new java_cup.runtime.symbol(/*string_literal_list*/3);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // context_expr ::= empty 
            {
              CUP$result = new java_cup.runtime.symbol(/*context_expr*/2);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // context_expr ::= CONTEXT LPAREN string_literal_list RPAREN 
            {
              CUP$result = new java_cup.runtime.symbol(/*context_expr*/2);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // raises_expr ::= empty 
            {
              CUP$result = new RaisesExpr(/*raises_expr*/83);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // raises_expr ::= RAISES LPAREN scopename_list RPAREN 
            {
              CUP$result = new RaisesExpr(/*raises_expr*/83);
               
                ((RaisesExpr)CUP$result).nameList = (Vector)(/*snl*/(SymbolList)CUP$stack.elementAt(CUP$top-1)).v.clone(); 
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // param_attribute ::= INOUT 
            {
              CUP$result = new java_cup.runtime.int_token(/*param_attribute*/6);
               ((java_cup.runtime.int_token)CUP$result).int_val = 3; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // param_attribute ::= OUT 
            {
              CUP$result = new java_cup.runtime.int_token(/*param_attribute*/6);
               ((java_cup.runtime.int_token)CUP$result).int_val = 2; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // param_attribute ::= IN 
            {
              CUP$result = new java_cup.runtime.int_token(/*param_attribute*/6);
               ((java_cup.runtime.int_token)CUP$result).int_val = 1; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // param_dcl ::= param_attribute param_type_spec simple_declarator 
            {
              CUP$result = new ParamDecl(/*param_dcl*/82);
               
                ((ParamDecl)CUP$result).paramAttribute = (/*pa*/(java_cup.runtime.int_token)CUP$stack.elementAt(CUP$top-2)).int_val;
                ((ParamDecl)CUP$result).paramTypeSpec = (/*pts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                ((ParamDecl)CUP$result).simple_declarator = (/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0));
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // param_dcls ::= param_dcl 
            {
              CUP$result = new SymbolList(/*param_dcls*/88);
               
                        ((SymbolList)CUP$result).v.insertElementAt((/*pd*/(ParamDecl)CUP$stack.elementAt(CUP$top-0)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // param_dcls ::= param_dcl COMMA param_dcls 
            {
              CUP$result = new SymbolList(/*param_dcls*/88);
               
                        ((SymbolList)CUP$result).v = (Vector)(/*pds*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone(); 
                        ((SymbolList)CUP$result).v.insertElementAt((/*pd*/(ParamDecl)CUP$stack.elementAt(CUP$top-2)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // parameter_dcls ::= LPAREN RPAREN 
            {
              CUP$result = new SymbolList(/*parameter_dcls*/89);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // parameter_dcls ::= LPAREN param_dcls RPAREN 
            {
              CUP$result = new SymbolList(/*parameter_dcls*/89);
               
                        ((SymbolList)CUP$result).v = (Vector)(/*pds*/(SymbolList)CUP$stack.elementAt(CUP$top-1)).v.clone(); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // void_type_spec ::= VOID 
            {
              CUP$result = new VoidTypeSpec(/*void_type_spec*/70);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // op_type_spec ::= void_type_spec 
            {
              CUP$result = new TypeSpec(/*op_type_spec*/42);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(VoidTypeSpec)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // op_type_spec ::= param_type_spec 
            {
              CUP$result = new TypeSpec(/*op_type_spec*/42);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(TypeSpec)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // op_attribute ::= empty 
            {
              CUP$result = new java_cup.runtime.int_token(/*op_attribute*/5);
               ((java_cup.runtime.int_token)CUP$result).int_val = 0; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // op_attribute ::= ONEWAY 
            {
              CUP$result = new java_cup.runtime.int_token(/*op_attribute*/5);
               ((java_cup.runtime.int_token)CUP$result).int_val = 1; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // op_dcl ::= op_attribute op_type_spec ID parameter_dcls raises_expr context_expr 
            {
              CUP$result = new OpDecl(/*op_dcl*/84);
               
                        ((OpDecl)CUP$result).opAttribute = (/*oa*/(java_cup.runtime.int_token)CUP$stack.elementAt(CUP$top-5)).int_val;
                        ((OpDecl)CUP$result).opTypeSpec = (/*ots*/(TypeSpec)CUP$stack.elementAt(CUP$top-4));
                        ((OpDecl)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));    
                        ((OpDecl)CUP$result).paramDecls = (Vector)(/*pds*/(SymbolList)CUP$stack.elementAt(CUP$top-2)).v.clone();
                        ((OpDecl)CUP$result).raisesExpr = (/*re*/(RaisesExpr)CUP$stack.elementAt(CUP$top-1));
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // except_dcl ::= EXCEPTION ID LCBRACE member_list RCBRACE 
            {
              CUP$result = new StructType(/*except_dcl*/51);
               
                        ((StructType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));    
                        ((StructType)CUP$result).exc = true;
                        ((StructType)CUP$result).set_memberlist( (/*ml*/(MemberList)CUP$stack.elementAt(CUP$top-1)) );
                        ((StructType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((StructType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // except_dcl ::= EXCEPTION ID LCBRACE RCBRACE 
            {
              CUP$result = new StructType(/*except_dcl*/51);
               
                        ((StructType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)));    
                        ((StructType)CUP$result).exc = true;
                        ((StructType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((StructType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // simple_declarator_list ::= simple_declarator COMMA simple_declarator_list 
            {
              CUP$result = new SymbolList(/*simple_declarator_list*/91);
               
                        ((SymbolList)CUP$result).v = (Vector)(/*sdl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-2)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // simple_declarator_list ::= simple_declarator 
            {
              CUP$result = new SymbolList(/*simple_declarator_list*/91);
               
                        ((SymbolList)CUP$result).v.insertElementAt((/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // attr_dcl ::= ATTRIBUTE param_type_spec simple_declarator_list 
            {
              CUP$result = new AttrDecl(/*attr_dcl*/85);
              
                        ((AttrDecl)CUP$result).readOnly = false;
                        ((AttrDecl)CUP$result).param_type_spec = (/*pts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((AttrDecl)CUP$result).declarators = (/*sdl*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // attr_dcl ::= READONLY ATTRIBUTE param_type_spec simple_declarator_list 
            {
              CUP$result = new AttrDecl(/*attr_dcl*/85);
              
                        ((AttrDecl)CUP$result).readOnly = true;
                        ((AttrDecl)CUP$result).param_type_spec = (/*pts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((AttrDecl)CUP$result).declarators = (/*sdl*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // fixed_array_size ::= LSBRACE positive_int_const RSBRACE 
            {
              CUP$result = new FixedArraySize(/*fixed_array_size*/81);
               
                        ((FixedArraySize)CUP$result).pos_int_const = (/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // fixed_array_size_list ::= fixed_array_size fixed_array_size_list 
            {
              CUP$result = new SymbolList(/*fixed_array_size_list*/95);
               
                        ((SymbolList)CUP$result).v = (Vector)(/*fasl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*fas*/(FixedArraySize)CUP$stack.elementAt(CUP$top-1)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // fixed_array_size_list ::= fixed_array_size 
            {
              CUP$result = new SymbolList(/*fixed_array_size_list*/95);
               
                        ((SymbolList)CUP$result).v.insertElementAt((/*fas*/(FixedArraySize)CUP$stack.elementAt(CUP$top-0)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // array_declarator ::= ID fixed_array_size_list 
            {
              CUP$result = new ArrayDeclarator(/*array_declarator*/80);
               
                        ((ArrayDeclarator)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)));    
                        ((ArrayDeclarator)CUP$result).fixed_array_size_list = (/*fasl*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // fixed_point_type ::= FIXED LESSTHAN positive_int_const COMMA positive_int_const GREATERTHAN 
            {
              CUP$result = new FixedPointType(/*fixed_point_type*/73);
               
                ((FixedPointType)CUP$result).digit_expr = (/*digits*/(PosIntConst)CUP$stack.elementAt(CUP$top-3)).const_expr;
                ((FixedPointType)CUP$result).scale_expr = (/*scale*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr;
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // string_type ::= WSTRING 
            {
              CUP$result = new StringType(/*string_type*/71);
               ((StringType)CUP$result).setWide(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // string_type ::= STRING 
            {
              CUP$result = new StringType(/*string_type*/71);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // string_type ::= WSTRING LESSTHAN positive_int_const GREATERTHAN 
            {
              CUP$result = new StringType(/*string_type*/71);
               
                ((StringType)CUP$result).max = (/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr; 
                ((StringType)CUP$result).setWide();
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // string_type ::= STRING LESSTHAN positive_int_const GREATERTHAN 
            {
              CUP$result = new StringType(/*string_type*/71);
               ((StringType)CUP$result).max = (/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // sequence_type ::= SEQUENCE LESSTHAN simple_type_spec GREATERTHAN 
            {
              CUP$result = new SequenceType(/*sequence_type*/72);
              
                        ((SequenceType)CUP$result).setTypeSpec( (/*sts*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-1)) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // sequence_type ::= SEQUENCE LESSTHAN simple_type_spec COMMA positive_int_const GREATERTHAN 
            {
              CUP$result = new SequenceType(/*sequence_type*/72);
              
                        ((SequenceType)CUP$result).max = (/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr;
                        ((SequenceType)CUP$result).setTypeSpec( (/*sts*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-3)) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // native_type ::= NATIVE simple_declarator 
            {
              CUP$result = new NativeType(/*native_type*/53);
              
                        ((NativeType)CUP$result).declarator = (/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // enumerator_list ::= ID COMMA enumerator_list 
            {
              CUP$result = new SymbolList(/*enumerator_list*/94);
               
                        ((SymbolList)CUP$result).v = (Vector)(/*el*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)).str_val,0); 
                        ((SymbolList)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)));    
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // enumerator_list ::= ID 
            {
              CUP$result = new SymbolList(/*enumerator_list*/94);
               
                        ((SymbolList)CUP$result).v.insertElementAt((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val,0); 
                        ((SymbolList)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));    
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // enum_type ::= ENUM ID LCBRACE enumerator_list RCBRACE 
            {
              CUP$result = new EnumType(/*enum_type*/49);
               
                        ((EnumType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));    
                        ((EnumType)CUP$result).enumlist = (/*el*/(SymbolList)CUP$stack.elementAt(CUP$top-1));
                        ((EnumType)CUP$result).set_included( parser.include_state );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // element_spec ::= type_spec declarator 
            {
              CUP$result = new ElementSpec(/*element_spec*/56);
              
                        ((ElementSpec)CUP$result).t.type_spec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((ElementSpec)CUP$result).d = (/*dc*/(Declarator)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // case_label_list ::= DEFAULT COLON case_label_list 
            {
              CUP$result = new SymbolList(/*case_label_list*/87);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*cll*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.addElement(null);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // case_label_list ::= CASE const_expr COLON case_label_list 
            {
              CUP$result = new SymbolList(/*case_label_list*/87);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*cll*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.addElement((/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-2)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // case_label_list ::= DEFAULT COLON 
            {
              CUP$result = new SymbolList(/*case_label_list*/87);
               ((SymbolList)CUP$result).v.addElement( null ); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // case_label_list ::= CASE const_expr COLON 
            {
              CUP$result = new SymbolList(/*case_label_list*/87);
               ((SymbolList)CUP$result).v.addElement((/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // case ::= case_label_list element_spec SEMI 
            {
              CUP$result = new Case(/*case*/55);
              
                        ((Case)CUP$result).element_spec = (/*es*/(ElementSpec)CUP$stack.elementAt(CUP$top-1));
                        ((Case)CUP$result).case_label_list = (/*c*/(SymbolList)CUP$stack.elementAt(CUP$top-2));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // switch_body ::= case switch_body 
            {
              CUP$result = new SwitchBody(/*switch_body*/54);
              
                ((SwitchBody)CUP$result).v = (Vector)(/*sb*/(SwitchBody)CUP$stack.elementAt(CUP$top-0)).v.clone();
                ((SwitchBody)CUP$result).v.addElement((/*c*/(Case)CUP$stack.elementAt(CUP$top-1)));
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // switch_body ::= case 
            {
              CUP$result = new SwitchBody(/*switch_body*/54);
              
                ((SwitchBody)CUP$result).v.addElement((/*c*/(Case)CUP$stack.elementAt(CUP$top-0)));
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // switch_type_spec ::= scopename 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/44);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // switch_type_spec ::= enum_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/44);
               ((TypeSpec)CUP$result).set_constr((/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // switch_type_spec ::= bool_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/44);
               ((TypeSpec)CUP$result).type_spec = (/*b*/(BooleanType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // switch_type_spec ::= char_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/44);
               ((TypeSpec)CUP$result).type_spec = (/*c*/(CharType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // switch_type_spec ::= int_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/44);
               ((TypeSpec)CUP$result).type_spec = (/*i*/(IntType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // union_type ::= UNION ID SWITCH LPAREN switch_type_spec RPAREN LCBRACE switch_body RCBRACE 
            {
              CUP$result = new UnionType(/*union_type*/52);
               
                        ((UnionType)CUP$result).setSwitchType( (/*s*/(TypeSpec)CUP$stack.elementAt(CUP$top-4)) ); 
                        ((UnionType)CUP$result).setSwitchBody( (/*sb*/(SwitchBody)CUP$stack.elementAt(CUP$top-1)) ); 
                        ((UnionType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-7)));
                        ((UnionType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((UnionType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // member ::= type_spec declarators SEMI 
            {
              CUP$result = new Member(/*member*/77);
               
                        ((Member)CUP$result).type_spec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-2));
                        ((Member)CUP$result).declarators = (/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-1));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // member_list ::= member member_list 
            {
              CUP$result = new MemberList(/*member_list*/86);
               
                        ((MemberList)CUP$result).v = (Vector)(/*ml*/(MemberList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((MemberList)CUP$result).v.insertElementAt((/*m*/(Member)CUP$stack.elementAt(CUP$top-1)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // member_list ::= member 
            {
              CUP$result = new MemberList(/*member_list*/86);
               
                        ((MemberList)CUP$result).v.insertElementAt((/*m*/(Member)CUP$stack.elementAt(CUP$top-0)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // struct_type ::= STRUCT ID LCBRACE member_list RCBRACE 
            {
              CUP$result = new StructType(/*struct_type*/50);
               
                        ((StructType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));    
                        ((StructType)CUP$result).exc = false;
                        ((StructType)CUP$result).set_memberlist( (/*ml*/(MemberList)CUP$stack.elementAt(CUP$top-1)) );
                        ((StructType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((StructType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // any_type ::= ANY 
            {
              CUP$result = new AnyType(/*any_type*/69);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // octet_type ::= OCTET 
            {
              CUP$result = new OctetType(/*octet_type*/68);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // bool_type ::= BOOLEAN 
            {
              CUP$result = new BooleanType(/*bool_type*/67);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // char_type ::= WCHAR 
            {
              CUP$result = new CharType(/*char_type*/66);
               ((CharType)CUP$result).setWide(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // char_type ::= CHAR 
            {
              CUP$result = new CharType(/*char_type*/66);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // long_long_type ::= LONG LONG 
            {
              CUP$result = new LongLongType(/*long_long_type*/65);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // long_type ::= LONG 
            {
              CUP$result = new LongType(/*long_type*/64);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // short_type ::= SHORT 
            {
              CUP$result = new ShortType(/*short_type*/63);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // int_type ::= UNSIGNED short_type 
            {
              CUP$result = new IntType(/*int_type*/58);
               
                        ((IntType)CUP$result).type_spec = (/*s*/(ShortType)CUP$stack.elementAt(CUP$top-0)); 
                        ((IntType)CUP$result).setUnsigned();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // int_type ::= short_type 
            {
              CUP$result = new IntType(/*int_type*/58);
               
                        ((IntType)CUP$result).type_spec = (/*s*/(ShortType)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // int_type ::= UNSIGNED long_long_type 
            {
              CUP$result = new IntType(/*int_type*/58);
               
                        ((IntType)CUP$result).type_spec = (/*l*/(LongLongType)CUP$stack.elementAt(CUP$top-0)); 
                        ((IntType)CUP$result).setUnsigned();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // int_type ::= UNSIGNED long_type 
            {
              CUP$result = new IntType(/*int_type*/58);
               
                        ((IntType)CUP$result).type_spec = (/*l*/(LongType)CUP$stack.elementAt(CUP$top-0)); 
                        ((IntType)CUP$result).setUnsigned();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // int_type ::= long_long_type 
            {
              CUP$result = new IntType(/*int_type*/58);
               
                        ((IntType)CUP$result).type_spec = (/*ll*/(LongLongType)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // int_type ::= long_type 
            {
              CUP$result = new IntType(/*int_type*/58);
               
                        ((IntType)CUP$result).type_spec = (/*l*/(LongType)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // double_type ::= DOUBLE 
            {
              CUP$result = new DoubleType(/*double_type*/62);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // fixed_pt_const_type ::= FIXED 
            {
              CUP$result = new FixedPointConstType(/*fixed_pt_const_type*/61);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // float_type ::= FLOAT 
            {
              CUP$result = new FloatType(/*float_type*/60);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // float_pt_type ::= double_type 
            {
              CUP$result = new FloatPtType(/*float_pt_type*/59);
              ((FloatPtType)CUP$result).type_spec = (/*d*/(DoubleType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // float_pt_type ::= float_type 
            {
              CUP$result = new FloatPtType(/*float_pt_type*/59);
              ((FloatPtType)CUP$result).type_spec = (/*f*/(FloatType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // simple_declarator ::= ID 
            {
              CUP$result = new SimpleDeclarator(/*simple_declarator*/79);
               
                        ((SimpleDeclarator)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));    
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // declarator ::= array_declarator 
            {
              CUP$result = new Declarator(/*declarator*/78);
               ((Declarator)CUP$result).d = (/*s*/(ArrayDeclarator)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // declarator ::= simple_declarator 
            {
              CUP$result = new Declarator(/*declarator*/78);
               ((Declarator)CUP$result).d = (/*s*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // declarators ::= declarator 
            {
              CUP$result = new SymbolList(/*declarators*/92);
               
                        ((SymbolList)CUP$result).v.insertElementAt((/*d*/(Declarator)CUP$stack.elementAt(CUP$top-0)),0);
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // declarators ::= declarator COMMA declarators 
            {
              CUP$result = new SymbolList(/*declarators*/92);
               
                        ((SymbolList)CUP$result).v = (Vector)(/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*d*/(Declarator)CUP$stack.elementAt(CUP$top-2)),0); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // constr_type_spec ::= enum_type 
            {
              CUP$result = new ConstrTypeSpec(/*constr_type_spec*/48);
               
                        ((ConstrTypeSpec)CUP$result).c_type_spec = (/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0)); 
                        ((ConstrTypeSpec)CUP$result).set_token((/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // constr_type_spec ::= union_type 
            {
              CUP$result = new ConstrTypeSpec(/*constr_type_spec*/48);
               
                        ((ConstrTypeSpec)CUP$result).c_type_spec = (/*u*/(UnionType)CUP$stack.elementAt(CUP$top-0)); 
                        ((ConstrTypeSpec)CUP$result).set_token((/*u*/(UnionType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // constr_type_spec ::= struct_type 
            {
              CUP$result = new ConstrTypeSpec(/*constr_type_spec*/48);
               
                        ((ConstrTypeSpec)CUP$result).c_type_spec = (/*s*/(StructType)CUP$stack.elementAt(CUP$top-0)); 
                        ((ConstrTypeSpec)CUP$result).set_token((/*s*/(StructType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // template_type_spec ::= fixed_point_type 
            {
              CUP$result = new TemplateTypeSpec(/*template_type_spec*/47);
               
                        ((TemplateTypeSpec)CUP$result).type_spec = (/*f*/(FixedPointType)CUP$stack.elementAt(CUP$top-0)); 
                        ((TemplateTypeSpec)CUP$result).set_token((/*f*/(FixedPointType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // template_type_spec ::= string_type 
            {
              CUP$result = new TemplateTypeSpec(/*template_type_spec*/47);
               
                        ((TemplateTypeSpec)CUP$result).type_spec = (/*s*/(StringType)CUP$stack.elementAt(CUP$top-0)); 
                        ((TemplateTypeSpec)CUP$result).set_token((/*s*/(StringType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // template_type_spec ::= sequence_type 
            {
              CUP$result = new TemplateTypeSpec(/*template_type_spec*/47);
               
                        ((TemplateTypeSpec)CUP$result).type_spec = (/*s*/(SequenceType)CUP$stack.elementAt(CUP$top-0)); 
                        ((TemplateTypeSpec)CUP$result).set_token((/*s*/(SequenceType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // base_type_spec ::= VALUEBASE 
            {
              CUP$result = new BaseType(/*base_type_spec*/57);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // base_type_spec ::= any_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/57);
               ((BaseType)CUP$result).type_spec = (/*s*/(AnyType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // base_type_spec ::= octet_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/57);
               ((BaseType)CUP$result).type_spec = (/*s*/(OctetType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // base_type_spec ::= bool_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/57);
               ((BaseType)CUP$result).type_spec = (/*s*/(BooleanType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // base_type_spec ::= char_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/57);
               ((BaseType)CUP$result).type_spec = (/*s*/(CharType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // base_type_spec ::= int_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/57);
               
                        ((BaseType)CUP$result).type_spec = (/*s*/(IntType)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // base_type_spec ::= float_pt_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/57);
               ((BaseType)CUP$result).type_spec = (/*s*/(FloatPtType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // simple_type_spec ::= scopename 
            {
              CUP$result = new SimpleTypeSpec(/*simple_type_spec*/46);
               
                        ((SimpleTypeSpec)CUP$result).type_spec = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
                        ((SimpleTypeSpec)CUP$result).set_token((/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // simple_type_spec ::= template_type_spec 
            {
              CUP$result = new SimpleTypeSpec(/*simple_type_spec*/46);
               
                        ((SimpleTypeSpec)CUP$result).type_spec = (/*s*/(TemplateTypeSpec)CUP$stack.elementAt(CUP$top-0)); 
                        ((SimpleTypeSpec)CUP$result).set_token((/*s*/(TemplateTypeSpec)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // simple_type_spec ::= base_type_spec 
            {
              CUP$result = new SimpleTypeSpec(/*simple_type_spec*/46);
               
                        ((SimpleTypeSpec)CUP$result).type_spec = (/*s*/(BaseType)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // type_spec ::= constr_type_spec 
            {
              CUP$result = new TypeSpec(/*type_spec*/41);
               
                        ((TypeSpec)CUP$result).type_spec = (/*s*/(ConstrTypeSpec)CUP$stack.elementAt(CUP$top-0)); 
                        ((TypeSpec)CUP$result).set_token((/*s*/(ConstrTypeSpec)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // type_spec ::= simple_type_spec 
            {
              CUP$result = new TypeSpec(/*type_spec*/41);
               
                        ((TypeSpec)CUP$result).type_spec = (/*s*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-0)); 
                        ((TypeSpec)CUP$result).set_token((/*s*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // type_declarator ::= type_spec declarators 
            {
              CUP$result = new TypeDeclarator(/*type_declarator*/40);
              
                        ((TypeDeclarator)CUP$result).type_spec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((TypeDeclarator)CUP$result).declarators = (/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // type_def ::= TYPEDEF type_declarator 
            {
              CUP$result = new TypeDef(/*type_def*/45);
               
                ((TypeDef)CUP$result).type_declarator = (/*t*/(TypeDeclarator)CUP$stack.elementAt(CUP$top-0)); 
                ((TypeDef)CUP$result).set_included( parser.include_state );
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // type_dcl ::= native_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/39);
               ((TypeDeclaration)CUP$result).type_decl = (/*n*/(NativeType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // type_dcl ::= enum_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/39);
               ((TypeDeclaration)CUP$result).type_decl = (/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // type_dcl ::= union_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/39);
               ((TypeDeclaration)CUP$result).type_decl = (/*u*/(UnionType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // type_dcl ::= struct_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/39);
               ((TypeDeclaration)CUP$result).type_decl = (/*s*/(StructType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // type_dcl ::= type_def 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/39);
               ((TypeDeclaration)CUP$result).type_decl = (/*t*/(TypeDef)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // positive_int_const ::= const_expr 
            {
              CUP$result = new PosIntConst(/*positive_int_const*/30);
               ((PosIntConst)CUP$result).const_expr = (/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // string_literal ::= LDBLQUOTE DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/75);
               
                        ((Literal)CUP$result).string = "\"\"";
                        ((Literal)CUP$result).wide = true;
                  
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // string_literal ::= LDBLQUOTE ID DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/75);
               
                        ((Literal)CUP$result).string = "\"" + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)).str_val + "\"";
                        ((Literal)CUP$result).wide = true;
                  
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // string_literal ::= DBLQUOTE DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/75);
               ((Literal)CUP$result).string = "\"\""; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // string_literal ::= DBLQUOTE ID DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/75);
               ((Literal)CUP$result).string = "\"" + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)).str_val + "\""; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // literal ::= FALSE 
            {
              CUP$result = new Literal(/*literal*/74);
               
                        ((Literal)CUP$result).string = "false"; 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // literal ::= TRUE 
            {
              CUP$result = new Literal(/*literal*/74);
               
                        ((Literal)CUP$result).string = "true"; 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // literal ::= FLOAT_NUMBER 
            {
              CUP$result = new Literal(/*literal*/74);
               
                        ((Literal)CUP$result).string = "" + (/*n*/(java_cup.runtime.float_token)CUP$stack.elementAt(CUP$top-0)).float_val ; 
                        ((Literal)CUP$result).token = (/*n*/(java_cup.runtime.float_token)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // literal ::= FIXED_NUMBER 
            {
              CUP$result = new Literal(/*literal*/74);
               
                        ((Literal)CUP$result).string = "" + (/*f*/(fixed_token)CUP$stack.elementAt(CUP$top-0)).fixed_val; 
                        ((Literal)CUP$result).token = (/*f*/(fixed_token)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // literal ::= string_literal 
            {
              CUP$result = new Literal(/*literal*/74);
               
                        ((Literal)CUP$result).string = (/*s*/(Literal)CUP$stack.elementAt(CUP$top-0)).string;                 
                        ((Literal)CUP$result).wide = (/*s*/(Literal)CUP$stack.elementAt(CUP$top-0)).wide; 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // literal ::= QUOTE CH QUOTE 
            {
              CUP$result = new Literal(/*literal*/74);
              
                        ((Literal)CUP$result).string = "\'" + (/*c*/(java_cup.runtime.char_token)CUP$stack.elementAt(CUP$top-1)).char_val + "\'"; 
                        ((Literal)CUP$result).token = (/*c*/(java_cup.runtime.char_token)CUP$stack.elementAt(CUP$top-1));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // literal ::= NUMBER 
            {
              CUP$result = new Literal(/*literal*/74);
               
                        ((Literal)CUP$result).string = "" + (/*n*/(java_cup.runtime.int_token)CUP$stack.elementAt(CUP$top-0)).int_val; 
                        ((Literal)CUP$result).token = (/*n*/(java_cup.runtime.int_token)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // primary_expr ::= LPAREN const_expr RPAREN 
            {
              CUP$result = new PrimaryExpr(/*primary_expr*/38);
               ((PrimaryExpr)CUP$result).symbol = (/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-1)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // primary_expr ::= literal 
            {
              CUP$result = new PrimaryExpr(/*primary_expr*/38);
               ((PrimaryExpr)CUP$result).symbol = (/*l*/(Literal)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // primary_expr ::= scopename 
            {
              CUP$result = new PrimaryExpr(/*primary_expr*/38);
               ((PrimaryExpr)CUP$result).symbol = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // unary_op ::= TILDE 
            {
              CUP$result = new java_cup.runtime.str_token(/*unary_op*/8);
               ((java_cup.runtime.str_token)CUP$result).str_val = "~"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // unary_op ::= PLUS 
            {
              CUP$result = new java_cup.runtime.str_token(/*unary_op*/8);
               ((java_cup.runtime.str_token)CUP$result).str_val = "+"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // unary_op ::= MINUS 
            {
              CUP$result = new java_cup.runtime.str_token(/*unary_op*/8);
               ((java_cup.runtime.str_token)CUP$result).str_val = "-"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // unary_expr ::= primary_expr 
            {
              CUP$result = new UnaryExpr(/*unary_expr*/37);
               ((UnaryExpr)CUP$result).primary_expr = (/*p*/(PrimaryExpr)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // unary_expr ::= unary_op primary_expr 
            {
              CUP$result = new UnaryExpr(/*unary_expr*/37);
              
                        ((UnaryExpr)CUP$result).primary_expr = (/*p*/(PrimaryExpr)CUP$stack.elementAt(CUP$top-0));
                        ((UnaryExpr)CUP$result).unary_op = (/*u*/(java_cup.runtime.str_token)CUP$stack.elementAt(CUP$top-1)).str_val;
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // mult_expr ::= mult_expr PERCENT unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/36);
              
                        ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0)); 
                        ((MultExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-2));
                        ((MultExpr)CUP$result).operator = "%";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // mult_expr ::= mult_expr SLASH unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/36);
              
                        ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0)); 
                        ((MultExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-2));
                        ((MultExpr)CUP$result).operator = "/";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // mult_expr ::= mult_expr STAR unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/36);
              
                        ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0)); 
                        ((MultExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-2));
                        ((MultExpr)CUP$result).operator = "*";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // mult_expr ::= unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/36);
               ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // add_expr ::= add_expr MINUS mult_expr 
            {
              CUP$result = new AddExpr(/*add_expr*/35);
              
                        ((AddExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-2)); 
                        ((AddExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-0));
                        ((AddExpr)CUP$result).operator = "-";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // add_expr ::= add_expr PLUS mult_expr 
            {
              CUP$result = new AddExpr(/*add_expr*/35);
              
                        ((AddExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-2)); 
                        ((AddExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-0));
                        ((AddExpr)CUP$result).operator = "+";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // add_expr ::= mult_expr 
            {
              CUP$result = new AddExpr(/*add_expr*/35);
              
                        ((AddExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // shift_expr ::= shift_expr RSHIFT add_expr 
            {
              CUP$result = new ShiftExpr(/*shift_expr*/34);
              
                        ((ShiftExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-0)); 
                        ((ShiftExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-2));
                        ((ShiftExpr)CUP$result).operator = ">>";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // shift_expr ::= shift_expr LSHIFT add_expr 
            {
              CUP$result = new ShiftExpr(/*shift_expr*/34);
              
                        ((ShiftExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-0)); 
                        ((ShiftExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-2));
                        ((ShiftExpr)CUP$result).operator = "<<";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // shift_expr ::= add_expr 
            {
              CUP$result = new ShiftExpr(/*shift_expr*/34);
               
                        ((ShiftExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // and_expr ::= and_expr AMPERSAND shift_expr 
            {
              CUP$result = new AndExpr(/*and_expr*/33);
              
                        ((AndExpr)CUP$result).and_expr = (/*a*/(AndExpr)CUP$stack.elementAt(CUP$top-2)); 
                        ((AndExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // and_expr ::= shift_expr 
            {
              CUP$result = new AndExpr(/*and_expr*/33);
               
                        ((AndExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // xor_expr ::= xor_expr CIRCUM and_expr 
            {
              CUP$result = new XorExpr(/*xor_expr*/32);
              
                        ((XorExpr)CUP$result).and_expr = (/*a*/(AndExpr)CUP$stack.elementAt(CUP$top-0)); 
                        ((XorExpr)CUP$result).xor_expr = (/*x*/(XorExpr)CUP$stack.elementAt(CUP$top-2));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // xor_expr ::= and_expr 
            {
              CUP$result = new XorExpr(/*xor_expr*/32);
               
                        ((XorExpr)CUP$result).and_expr = (/*a*/(AndExpr)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // or_expr ::= or_expr BAR xor_expr 
            {
              CUP$result = new OrExpr(/*or_expr*/31);
              
                        ((OrExpr)CUP$result).or_expr = (/*o*/(OrExpr)CUP$stack.elementAt(CUP$top-2)); 
                        ((OrExpr)CUP$result).xor_expr = (/*x*/(XorExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // or_expr ::= xor_expr 
            {
              CUP$result = new OrExpr(/*or_expr*/31);
               
                        ((OrExpr)CUP$result).xor_expr = (/*x*/(XorExpr)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // const_expr ::= or_expr 
            {
              CUP$result = new ConstExpr(/*const_expr*/29);
               
                        ((ConstExpr)CUP$result).or_expr = (/*o*/(OrExpr)CUP$stack.elementAt(CUP$top-0)); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // const_type ::= scopename 
            {
              CUP$result = new ConstType(/*const_type*/28);
               
                        ((ConstType)CUP$result).symbol = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
                        ((ConstType)CUP$result).set_token((/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // const_type ::= octet_type 
            {
              CUP$result = new ConstType(/*const_type*/28);
               ((ConstType)CUP$result).symbol = (/*s*/(OctetType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // const_type ::= string_type 
            {
              CUP$result = new ConstType(/*const_type*/28);
               ((ConstType)CUP$result).symbol = (/*s*/(StringType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // const_type ::= fixed_pt_const_type 
            {
              CUP$result = new ConstType(/*const_type*/28);
               ((ConstType)CUP$result).symbol = (/*s*/(FixedPointConstType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // const_type ::= float_pt_type 
            {
              CUP$result = new ConstType(/*const_type*/28);
               ((ConstType)CUP$result).symbol = (/*s*/(FloatPtType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // const_type ::= bool_type 
            {
              CUP$result = new ConstType(/*const_type*/28);
               ((ConstType)CUP$result).symbol = (/*s*/(BooleanType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // const_type ::= char_type 
            {
              CUP$result = new ConstType(/*const_type*/28);
               ((ConstType)CUP$result).symbol = (/*s*/(CharType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // const_type ::= int_type 
            {
              CUP$result = new ConstType(/*const_type*/28);
               ((ConstType)CUP$result).symbol = (/*s*/(IntType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // const_dcl ::= CONST const_type ID EQUALS const_expr 
            {
              CUP$result = new ConstDecl(/*const_dcl*/27);
              
                        ((ConstDecl)CUP$result).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)).str_val);
                        ((ConstDecl)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)));    
                        ((ConstDecl)CUP$result).const_expr = (/*ce*/(ConstExpr)CUP$stack.elementAt(CUP$top-0));
                        ((ConstDecl)CUP$result).const_type = (ConstType)(/*ct*/(ConstType)CUP$stack.elementAt(CUP$top-3));
                        ((ConstDecl)CUP$result).set_included( parser.include_state );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // init_param_decl ::= IN param_type_spec simple_declarator 
            {
              CUP$result = new IdlSymbol(/*init_param_decl*/26);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // init_param_decls ::= init_param_decl COMMA init_param_decls 
            {
              CUP$result = new IdlSymbol(/*init_param_decls*/25);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // init_param_decls ::= init_param_decl 
            {
              CUP$result = new IdlSymbol(/*init_param_decls*/25);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // state_member ::= PRIVATE type_spec declarators SEMI 
            {
              CUP$result = new StateMember(/*state_member*/24);
              
                           ((StateMember)CUP$result).isPublic    = false;
                           ((StateMember)CUP$result).type_spec   = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-2));
                           ((StateMember)CUP$result).declarators = (/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-1));
                  
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // state_member ::= PUBLIC type_spec declarators SEMI 
            {
              CUP$result = new StateMember(/*state_member*/24);
              
                           ((StateMember)CUP$result).isPublic    = true;
                           ((StateMember)CUP$result).type_spec   = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-2));
                           ((StateMember)CUP$result).declarators = (/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-1));
                  
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // value_element ::= FACTORY ID LPAREN RPAREN SEMI 
            {
              CUP$result = new Definition(/*value_element*/23);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // value_element ::= FACTORY ID LPAREN init_param_decls RPAREN SEMI 
            {
              CUP$result = new Definition(/*value_element*/23);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // value_element ::= state_member 
            {
              CUP$result = new Definition(/*value_element*/23);
              
                        ((Definition)CUP$result).set_declaration ((/*sm*/(StateMember)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // value_element ::= export 
            {
              CUP$result = new Definition(/*value_element*/23);
              
                        ((Definition)CUP$result).set_declaration ((/*e*/(Definition)CUP$stack.elementAt(CUP$top-0)).get_declaration());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // value_elements ::= empty 
            {
              CUP$result = new Definitions(/*value_elements*/22);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // value_elements ::= value_element value_elements 
            {
              CUP$result = new Definitions(/*value_elements*/22);
              
                        ((Definitions)CUP$result).v = (Vector)(/*es*/(Definitions)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((Definitions)CUP$result).v.insertElementAt((/*e*/(Definition)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // truncatable ::= empty 
            {
              CUP$result = new java_cup.runtime.int_token(/*truncatable*/7);
               
                ((java_cup.runtime.int_token)CUP$result).int_val = 0; 
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // truncatable ::= TRUNCATABLE 
            {
              CUP$result = new java_cup.runtime.int_token(/*truncatable*/7);
               
                ((java_cup.runtime.int_token)CUP$result).int_val = 1; 
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // value_inheritance_spec ::= empty 
            {
              CUP$result = new IdlSymbol(/*value_inheritance_spec*/21);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // value_inheritance_spec ::= COLON truncatable scopename_list SUPPORTS scopename_list 
            {
              CUP$result = new IdlSymbol(/*value_inheritance_spec*/21);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // value_inheritance_spec ::= SUPPORTS scopename_list 
            {
              CUP$result = new IdlSymbol(/*value_inheritance_spec*/21);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // value_inheritance_spec ::= COLON truncatable scopename_list 
            {
              CUP$result = new IdlSymbol(/*value_inheritance_spec*/21);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // value_dcl ::= VALUETYPE ID value_inheritance_spec LCBRACE value_elements RCBRACE 
            {
              CUP$result = new ValueDecl(/*value_dcl*/19);
              
                        ((ValueDecl)CUP$result).set_token ((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                        // ((ValueDecl)CUP$result).setInheritanceSpec ((/*is*/(IdlSymbol)CUP$stack.elementAt(CUP$top-3)));
                        ((ValueDecl)CUP$result).setValueElements ((/*ve*/(Definitions)CUP$stack.elementAt(CUP$top-1)));
                        ((ValueDecl)CUP$result).isCustomMarshalled (false);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // value_dcl ::= CUSTOM VALUETYPE ID value_inheritance_spec LCBRACE value_elements RCBRACE 
            {
              CUP$result = new ValueDecl(/*value_dcl*/19);
              
                        ((ValueDecl)CUP$result).set_token ((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                        // ((ValueDecl)CUP$result).setInheritanceSpec ((/*is*/(IdlSymbol)CUP$stack.elementAt(CUP$top-3)));
                        ((ValueDecl)CUP$result).setValueElements ((/*ve*/(Definitions)CUP$stack.elementAt(CUP$top-1)));
                        ((ValueDecl)CUP$result).isCustomMarshalled (true);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // value_body ::= export 
            {
              CUP$result = new IdlSymbol(/*value_body*/20);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // value_body ::= export value_body 
            {
              CUP$result = new IdlSymbol(/*value_body*/20);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // value_box_dcl ::= VALUETYPE ID type_spec 
            {
              CUP$result = new ValueBoxDecl(/*value_box_dcl*/18);
               
                        ((ValueBoxDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)).str_val;
                        ((ValueBoxDecl)CUP$result).typeSpec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // value ::= VALUETYPE ID 
            {
              CUP$result = new Value(/*value*/17);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // value ::= ABSTRACT VALUETYPE ID 
            {
              CUP$result = new Value(/*value*/17);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // value ::= value_box_dcl 
            {
              CUP$result = new Value(/*value*/17);
               
                        ((Value)CUP$result).setValue ((/*vbx*/(ValueBoxDecl)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // value ::= value_dcl 
            {
              CUP$result = new Value(/*value*/17);
               
                        ((Value)CUP$result).setValue ((/*vd*/(ValueDecl)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // scopename ::= OBJECT 
            {
              CUP$result = new ScopedName(/*scopename*/16);
               
                        ((ScopedName)CUP$result).typeName = "org.omg.CORBA.Object";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // scopename ::= scopename DBLCOLON ID 
            {
              CUP$result = new ScopedName(/*scopename*/16);
               
                        ((ScopedName)CUP$result).setId( (/*sn*/(ScopedName)CUP$stack.elementAt(CUP$top-2)).typeName+ "." + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val );
                        ((ScopedName)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // scopename ::= DBLCOLON ID 
            {
              CUP$result = new ScopedName(/*scopename*/16);
               
                        ((ScopedName)CUP$result).setId( "." + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val);
                        ((ScopedName)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));    
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // scopename ::= ID 
            {
              CUP$result = new ScopedName(/*scopename*/16);
               
                        ((ScopedName)CUP$result).setId( (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val );
                        ((ScopedName)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));    
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // scopename_list ::= scopename 
            {
              CUP$result = new SymbolList(/*scopename_list*/90);
               ((SymbolList)CUP$result).v.insertElementAt((/*sn*/(ScopedName)CUP$stack.elementAt(CUP$top-0)),0); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // scopename_list ::= scopename COMMA scopename_list 
            {
              CUP$result = new SymbolList(/*scopename_list*/90);
               
                ((SymbolList)CUP$result).v = (Vector)(/*snl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone(); 
                ((SymbolList)CUP$result).v.insertElementAt((/*sn*/(ScopedName)CUP$stack.elementAt(CUP$top-2)),0); 
            
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // inheritance_spec ::= empty 
            {
              CUP$result = new SymbolList(/*inheritance_spec*/93);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // inheritance_spec ::= COLON scopename_list 
            {
              CUP$result = new SymbolList(/*inheritance_spec*/93);
               ((SymbolList)CUP$result).v = (Vector)(/*sl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // export ::= op_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/15);
               ((Definition)CUP$result).set_declaration((/*o*/(OpDecl)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // export ::= attr_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/15);
               ((Definition)CUP$result).set_declaration((/*a*/(AttrDecl)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // export ::= except_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/15);
               ((Definition)CUP$result).set_declaration((/*e*/(StructType)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // export ::= const_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/15);
               ((Definition)CUP$result).set_declaration((/*c*/(ConstDecl)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // export ::= type_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/15);
               ((Definition)CUP$result).set_declaration((/*t*/(TypeDeclaration)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // interface_body ::= empty 
            {
              CUP$result = new InterfaceBody(/*interface_body*/14);
               ((InterfaceBody)CUP$result).commit(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // interface_body ::= export interface_body 
            {
              CUP$result = new InterfaceBody(/*interface_body*/14);
               
                        ((InterfaceBody)CUP$result).v = (Vector)(/*i*/(InterfaceBody)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((InterfaceBody)CUP$result).v.insertElementAt((/*e*/(Definition)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // interface ::= PSEUDO INTERFACE ID 
            {
              CUP$result = new Interface(/*interface*/13);
              
                ((Interface)CUP$result).set_pseudo();
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));    
                ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // interface ::= ABSTRACT INTERFACE ID 
            {
              CUP$result = new Interface(/*interface*/13);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));    
                ((Interface)CUP$result).set_abstract();
                ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // interface ::= INTERFACE ID 
            {
              CUP$result = new Interface(/*interface*/13);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));    
                ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // interface ::= PSEUDO INTERFACE ID inheritance_spec LCBRACE interface_body RCBRACE 
            {
              CUP$result = new Interface(/*interface*/13);
               
                ((Interface)CUP$result).set_pseudo();
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                ((Interface)CUP$result).inheritanceSpec = (/*is*/(SymbolList)CUP$stack.elementAt(CUP$top-3));
                ((Interface)CUP$result).body = (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)); 
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_pseudo();
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
//              (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4))); 
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).my_interface = ((Interface)CUP$result);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Interface)CUP$result));
                ((Interface)CUP$result).set_included( parser.include_state );
                ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // interface ::= ABSTRACT INTERFACE ID inheritance_spec LCBRACE interface_body RCBRACE 
            {
              CUP$result = new Interface(/*interface*/13);
               
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                ((Interface)CUP$result).set_abstract();
                ((Interface)CUP$result).inheritanceSpec = (/*is*/(SymbolList)CUP$stack.elementAt(CUP$top-3));
                ((Interface)CUP$result).body = (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)) ;
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).my_interface = ((Interface)CUP$result);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Interface)CUP$result));
                ((Interface)CUP$result).set_included( parser.include_state );
                ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // interface ::= INTERFACE ID inheritance_spec LCBRACE interface_body RCBRACE 
            {
              CUP$result = new Interface(/*interface*/13);
               
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                ((Interface)CUP$result).inheritanceSpec = (/*is*/(SymbolList)CUP$stack.elementAt(CUP$top-3));
                ((Interface)CUP$result).body = (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)) ;
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).my_interface = ((Interface)CUP$result);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Interface)CUP$result));
                ((Interface)CUP$result).set_included( parser.include_state );
                ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // module ::= MODULE ID LCBRACE definitions RCBRACE 
            {
              CUP$result = new Module(/*module*/12);
               
                ((Module)CUP$result).spec = (/*d*/(Definitions)CUP$stack.elementAt(CUP$top-1));
                ((Module)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));
                ((Module)CUP$result).setPackage((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)).str_val );
                ((Module)CUP$result).set_included( parser.include_state );

                (/*d*/(Definitions)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Module)CUP$result));
                parser.closeScope( (Scope)((Module)CUP$result) );
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // definition ::= value SEMI 
            {
              CUP$result = new Definition(/*definition*/10);
               
                        ((Definition)CUP$result).set_declaration((/*m*/(Value)CUP$stack.elementAt(CUP$top-1)));
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // definition ::= module SEMI 
            {
              CUP$result = new Definition(/*definition*/10);
               
                        ((Definition)CUP$result).set_declaration((/*m*/(Module)CUP$stack.elementAt(CUP$top-1)));
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // definition ::= interface SEMI 
            {
              CUP$result = new Definition(/*definition*/10);
               
                        ((Definition)CUP$result).set_declaration((/*p*/(Interface)CUP$stack.elementAt(CUP$top-1))); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // definition ::= except_dcl SEMI 
            {
              CUP$result = new Definition(/*definition*/10);
               
                        ((Definition)CUP$result).set_declaration((/*e*/(StructType)CUP$stack.elementAt(CUP$top-1))); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // definition ::= const_dcl SEMI 
            {
              CUP$result = new Definition(/*definition*/10);
               
                        ((Definition)CUP$result).set_declaration((/*c*/(ConstDecl)CUP$stack.elementAt(CUP$top-1))); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // definition ::= type_dcl SEMI 
            {
              CUP$result = new Definition(/*definition*/10);
               
                        ((Definition)CUP$result).set_declaration((/*t*/(TypeDeclaration)CUP$stack.elementAt(CUP$top-1))); 
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // definitions ::= definition 
            {
              CUP$result = new Definitions(/*definitions*/11);
              
                        ((Definitions)CUP$result).v.insertElementAt((/*d*/(Definition)CUP$stack.elementAt(CUP$top-0)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // definitions ::= definition definitions 
            {
              CUP$result = new Definitions(/*definitions*/11);
              
                        ((Definitions)CUP$result).v = (Vector)(/*ds*/(Definitions)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((Definitions)CUP$result).v.insertElementAt((/*d*/(Definition)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // specification ::= empty 
            {
              CUP$result = new Spec(/*specification*/9);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // specification ::= NT$0 definitions 
            {
              CUP$result = new Spec(/*specification*/9);
              
                /* parsing */

                // open the global scope
                parser.openScope();

                ((Spec)CUP$result).definitions = (Vector)(/*ds*/(Definitions)CUP$stack.elementAt(CUP$top-0)).v.clone();

                if( ((org.jacorb.idl.parser)CUP$parser).package_prefix != null )
                        ((Spec)CUP$result).setPackage( ((org.jacorb.idl.parser)CUP$parser).package_prefix );

                ((Spec)CUP$result).parse();

                if ( lexer.error_count != 0 )
                {
                        System.err.println(lexer.error_count + " error(s).");
                        System.exit(1);
                }

                // if there are still interfaces to be parsed, wait until the
                // threads performing this have finished. The last one 
                // will call notify() :) 

                if( parser.pending_interfaces.size() > 0  )
                {                  
                   // give other threads a chance to start and signal
                   // that they're active
                   Thread.yield();
                      
                   boolean runnableFound = false;

                   // still no one seems to be active, but we'll call 
                   // round to be sure
                   if( parser.activeParseThreads() == 0 )
                   {
                        Environment.output(3,"Check for runnable threads");

                        for( int t = 0;
                             t < InterfaceBody.parseThreads.size() && !runnableFound; 
                             t++ )
                        {
                            runnableFound = 
                                ((InterfaceBody.ParseThread)InterfaceBody.parseThreads.elementAt(t)).isRunnable();
                        }
                   }

                   // only block waiting if we know that there are active or
                   // runnable threads and that there are still pending tasks

                   if( ( parser.activeParseThreads() > 1 || runnableFound ) && 
                         parser.pending_interfaces.size() > 0 )
                   {
                       synchronized( parser.pending_interfaces )
                       {
                           Environment.output(3,"Wait for pending_interfaces");
                           parser.pending_interfaces.wait();
                           Environment.output(3,"Waking up after wait for pending_interfaces");
                       }
                   } 
                }
 
                if( parser.pending_interfaces.size() > 0 && 
                    !parser.sloppy )
                {
                    parser.fatal_error("Undefined interface: " + 
                        (String)(parser.pending_interfaces.keys().nextElement()), null );
                }

                /* complete global import list */
                if( parser.global_import )
                {
                        Environment.output(3,"Preparing global import");
                        parser.addGlobalNamesToImport();
                }
                else
                        Environment.output(3,"No global import");

                /* code generation phase */

                try
                {

                   if (! ((org.jacorb.idl.parser)CUP$parser).parse_only  )
                   {
                        ((Spec)CUP$result).print(new java.io.PrintWriter( java.lang.System.out ));
                   }
                } 
                catch ( Exception e )
                {
                     Environment.output(1,e);
                }
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              CUP$result = new java_cup.runtime.token(/*NT$0*/96);
              
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= specification EOF 
            {
              CUP$result = new java_cup.runtime.token(/*$START*/0);
              
            }
          /* ACCEPT */
          CUP$parser.done_parsing();
          return CUP$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
};

