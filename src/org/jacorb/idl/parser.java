
//----------------------------------------------------
// The following code was generated by CUP v0.9e
// Tue May 14 11:18:29 BST 2002
//----------------------------------------------------

package org.jacorb.idl;

import java_cup.runtime.*;
import java.util.*;

public class parser extends java_cup.runtime.lr_parser {

  /** constructor */
  public parser() {super();}

  /** production table */
  protected static final short _production_table[][] = {
        {0, 2},     {98, 0},     {8, 2},     {8, 1},     {10, 2}, 
        {10, 1},     {9, 2},     {9, 2},     {9, 2},     {9, 2}, 
        {9, 2},     {9, 2},     {11, 5},     {12, 6},     {12, 7}, 
        {12, 7},     {12, 7},     {12, 2},     {12, 3},     {12, 3}, 
        {12, 3},     {13, 2},     {13, 1},     {14, 2},     {14, 2}, 
        {14, 2},     {14, 2},     {14, 2},     {95, 2},     {95, 1}, 
        {92, 3},     {92, 1},     {15, 1},     {15, 2},     {15, 3}, 
        {15, 1},     {17, 1},     {17, 1},     {17, 1},     {18, 3}, 
        {20, 7},     {20, 3},     {21, 2},     {21, 1},     {19, 7}, 
        {19, 2},     {19, 6},     {22, 3},     {22, 2},     {22, 2}, 
        {22, 5},     {22, 4},     {22, 1},     {16, 1},     {23, 2}, 
        {23, 1},     {24, 1},     {24, 1},     {24, 1},     {25, 4}, 
        {25, 4},     {26, 6},     {26, 5},     {90, 1},     {90, 3}, 
        {27, 3},     {28, 5},     {29, 1},     {29, 1},     {29, 1}, 
        {29, 1},     {29, 1},     {29, 1},     {29, 1},     {29, 1}, 
        {30, 1},     {32, 1},     {32, 3},     {33, 1},     {33, 3}, 
        {34, 1},     {34, 3},     {35, 1},     {35, 3},     {35, 3}, 
        {36, 1},     {36, 3},     {36, 3},     {37, 1},     {37, 3}, 
        {37, 3},     {37, 3},     {38, 2},     {38, 1},     {7, 1}, 
        {7, 1},     {7, 1},     {39, 1},     {39, 1},     {39, 3}, 
        {75, 1},     {75, 1},     {75, 3},     {75, 1},     {75, 1}, 
        {75, 1},     {75, 1},     {75, 1},     {76, 3},     {76, 2}, 
        {76, 3},     {76, 2},     {31, 1},     {40, 1},     {40, 1}, 
        {40, 1},     {40, 1},     {40, 1},     {46, 2},     {41, 2}, 
        {42, 1},     {42, 1},     {47, 1},     {47, 1},     {47, 1}, 
        {58, 1},     {58, 1},     {58, 1},     {58, 1},     {58, 1}, 
        {58, 1},     {58, 1},     {48, 1},     {48, 1},     {48, 1}, 
        {49, 1},     {49, 1},     {49, 1},     {94, 3},     {94, 1}, 
        {79, 1},     {79, 1},     {80, 1},     {60, 1},     {60, 1}, 
        {61, 1},     {62, 1},     {63, 1},     {59, 1},     {59, 1}, 
        {59, 2},     {59, 2},     {59, 1},     {59, 2},     {64, 1}, 
        {65, 1},     {66, 2},     {67, 1},     {67, 1},     {68, 1}, 
        {69, 1},     {70, 1},     {51, 5},     {51, 2},     {87, 1}, 
        {87, 2},     {78, 3},     {53, 9},     {53, 2},     {45, 1}, 
        {45, 1},     {45, 1},     {45, 1},     {45, 1},     {55, 1}, 
        {55, 2},     {56, 3},     {88, 3},     {88, 2},     {88, 4}, 
        {88, 3},     {57, 2},     {50, 5},     {96, 1},     {96, 3}, 
        {54, 2},     {73, 6},     {73, 4},     {72, 4},     {72, 4}, 
        {72, 1},     {72, 1},     {74, 6},     {81, 2},     {97, 1}, 
        {97, 2},     {82, 3},     {86, 4},     {86, 3},     {93, 1}, 
        {93, 3},     {52, 4},     {52, 5},     {85, 6},     {5, 1}, 
        {5, 1},     {43, 1},     {43, 1},     {71, 1},     {91, 3}, 
        {91, 2},     {89, 3},     {89, 1},     {83, 3},     {6, 1}, 
        {6, 1},     {6, 1},     {84, 4},     {84, 1},     {2, 4}, 
        {2, 1},     {3, 1},     {3, 3},     {44, 1},     {44, 1}, 
        {44, 1},     {4, 0}  };

  /** access to production table */
  public short[][] production_table() {return _production_table;}

  /** parse action table */
  protected static final short[][] _action_table = {
    /*0*/{0,-227,2,-2,8,-2,10,-2,13,-2,14,-2,21,-2,22,-2,24,-2,25,-2,32,-2,38,-2,43,-2,45,-2,47,-2,-1,0},
    /*1*/{2,30,8,27,10,8,13,28,14,11,21,29,22,14,24,21,25,13,32,23,38,12,43,25,45,26,47,17,-1,0},
    /*2*/{0,5,-1,0},
    /*3*/{0,-4,-1,0},
    /*4*/{0,-1,-1,0},
    /*5*/{51,397,-1,0},
    /*6*/{51,396,-1,0},
    /*7*/{47,390,-1,0},
    /*8*/{51,389,-1,0},
    /*9*/{51,-117,-1,0},
    /*10*/{80,384,-1,0},
    /*11*/{80,375,-1,0},
    /*12*/{80,195,-1,0},
    /*13*/{21,368,-1,0},
    /*14*/{0,-6,2,30,8,27,10,8,13,28,14,11,21,29,22,14,24,21,25,13,32,23,38,12,43,25,45,26,47,17,62,-6,-1,0},
    /*15*/{51,-37,-1,0},
    /*16*/{80,333,-1,0},
    /*17*/{51,-39,-1,0},
    /*18*/{51,332,-1,0},
    /*19*/{51,-118,-1,0},
    /*20*/{80,328,-1,0},
    /*21*/{51,327,-1,0},
    /*22*/{21,321,-1,0},
    /*23*/{51,320,-1,0},
    /*24*/{3,86,5,81,7,68,12,95,13,28,17,278,18,84,23,64,26,79,27,93,35,287,36,90,37,82,38,12,44,73,45,26,46,75,49,91,50,92,76,72,80,78,-1,0},
    /*25*/{80,254,-1,0},
    /*26*/{5,81,7,68,12,95,17,249,18,84,23,64,26,79,27,93,36,90,37,82,44,73,49,91,50,92,76,72,80,78,-1,0},
    /*27*/{80,234,-1,0},
    /*28*/{80,229,-1,0},
    /*29*/{21,36,47,37,-1,0},
    /*30*/{51,-38,-1,0},
    /*31*/{51,-116,-1,0},
    /*32*/{51,-114,-1,0},
    /*33*/{51,-115,-1,0},
    /*34*/{0,-3,-1,0},
    /*35*/{80,218,-1,0},
    /*36*/{80,38,-1,0},
    /*37*/{39,41,51,-42,55,39,61,-227,-1,0},
    /*38*/{26,79,42,210,76,72,80,78,-1,0},
    /*39*/{61,-53,-1,0},
    /*40*/{26,79,76,72,80,78,-1,0},
    /*41*/{61,43,-1,0},
    /*42*/{3,-227,4,46,5,-227,7,-227,8,27,12,-227,13,28,14,11,18,-227,23,-227,25,13,26,-227,27,-227,28,47,34,45,36,-227,37,-227,38,12,43,25,44,-227,45,26,46,-227,48,-227,49,-227,50,-227,62,-227,76,-227,80,-227,-1,0},
    /*43*/{51,208,-1,0},
    /*44*/{4,205,-1,0},
    /*45*/{3,86,5,81,7,68,12,95,18,84,23,64,26,79,27,93,36,90,37,82,44,73,46,75,49,91,50,92,76,72,80,78,-1,0},
    /*46*/{3,-205,5,-205,7,-205,12,-205,18,-205,23,-205,26,-205,27,-205,36,-205,37,-205,44,-205,46,-205,48,-205,49,-205,50,-205,76,-205,80,-205,-1,0},
    /*47*/{3,86,5,81,7,68,12,95,18,84,23,64,26,79,27,93,36,90,37,82,44,73,46,75,48,94,49,91,50,92,76,72,80,78,-1,0},
    /*48*/{51,61,-1,0},
    /*49*/{3,-206,5,-206,7,-206,12,-206,18,-206,23,-206,26,-206,27,-206,36,-206,37,-206,44,-206,46,-206,48,-206,49,-206,50,-206,62,-44,76,-206,80,-206,-1,0},
    /*50*/{51,60,-1,0},
    /*51*/{51,59,-1,0},
    /*52*/{51,58,-1,0},
    /*53*/{62,57,-1,0},
    /*54*/{3,-227,4,46,5,-227,7,-227,8,27,12,-227,13,28,14,11,18,-227,23,-227,25,13,26,-227,27,-227,28,47,34,45,36,-227,37,-227,38,12,43,25,44,-227,45,26,46,-227,48,-227,49,-227,50,-227,62,-227,76,-227,80,-227,-1,0},
    /*55*/{62,-43,-1,0},
    /*56*/{51,-41,-1,0},
    /*57*/{3,-26,4,-26,5,-26,7,-26,8,-26,12,-26,13,-26,14,-26,15,-26,18,-26,23,-26,25,-26,26,-26,27,-26,28,-26,30,-26,31,-26,34,-26,36,-26,37,-26,38,-26,43,-26,44,-26,45,-26,46,-26,48,-26,49,-26,50,-26,62,-26,76,-26,80,-26,-1,0},
    /*58*/{3,-28,4,-28,5,-28,7,-28,8,-28,12,-28,13,-28,14,-28,15,-28,18,-28,23,-28,25,-28,26,-28,27,-28,28,-28,30,-28,31,-28,34,-28,36,-28,37,-28,38,-28,43,-28,44,-28,45,-28,46,-28,48,-28,49,-28,50,-28,62,-28,76,-28,80,-28,-1,0},
    /*59*/{3,-25,4,-25,5,-25,7,-25,8,-25,12,-25,13,-25,14,-25,15,-25,18,-25,23,-25,25,-25,26,-25,27,-25,28,-25,30,-25,31,-25,34,-25,36,-25,37,-25,38,-25,43,-25,44,-25,45,-25,46,-25,48,-25,49,-25,50,-25,62,-25,76,-25,80,-25,-1,0},
    /*60*/{3,-27,4,-27,5,-27,7,-27,8,-27,12,-27,13,-27,14,-27,15,-27,18,-27,23,-27,25,-27,26,-27,27,-27,28,-27,30,-27,31,-27,34,-27,36,-27,37,-27,38,-27,43,-27,44,-27,45,-27,46,-27,48,-27,49,-27,50,-27,62,-27,76,-27,80,-27,-1,0},
    /*61*/{51,-130,52,-130,66,-130,80,-130,-1,0},
    /*62*/{80,-225,-1,0},
    /*63*/{23,199,51,-156,52,-156,60,-156,66,-156,80,-156,-1,0},
    /*64*/{51,-128,52,-128,66,-128,80,-128,-1,0},
    /*65*/{76,156,80,-226,-1,0},
    /*66*/{80,165,-1,0},
    /*67*/{51,-158,52,-158,60,-158,66,-158,80,-158,-1,0},
    /*68*/{51,-153,52,-153,60,-153,66,-153,80,-153,-1,0},
    /*69*/{80,-224,-1,0},
    /*70*/{80,-207,-1,0},
    /*71*/{80,164,-1,0},
    /*72*/{23,64,36,90,-1,0},
    /*73*/{51,-127,52,-127,66,-127,80,-127,-1,0},
    /*74*/{51,-132,52,-132,66,-132,80,-132,-1,0},
    /*75*/{80,-208,-1,0},
    /*76*/{51,-144,52,-144,66,-144,80,-144,-1,0},
    /*77*/{39,-33,51,-33,52,-33,53,-33,55,-33,57,-33,58,-33,60,-33,61,-33,64,-33,66,-33,70,-33,71,-33,72,-33,73,-33,74,-33,76,-33,77,-33,78,-33,80,-33,-1,0},
    /*78*/{39,-36,51,-36,52,-36,53,-36,55,-36,57,-36,58,-36,60,-36,61,-36,64,-36,66,-36,70,-36,71,-36,72,-36,73,-36,74,-36,76,-36,77,-36,78,-36,80,-36,-1,0},
    /*79*/{51,-129,52,-129,66,-129,80,-129,-1,0},
    /*80*/{51,-160,52,-160,60,-160,66,-160,80,-160,-1,0},
    /*81*/{51,-191,52,-191,65,158,66,-191,80,-191,-1,0},
    /*82*/{51,-131,52,-131,66,-131,80,-131,-1,0},
    /*83*/{51,-146,52,-146,66,-146,80,-146,-1,0},
    /*84*/{51,-145,52,-145,66,-145,80,-145,-1,0},
    /*85*/{51,-162,52,-162,66,-162,80,-162,-1,0},
    /*86*/{51,-150,52,-150,60,-150,66,-150,80,-150,-1,0},
    /*87*/{51,-149,52,-149,60,-149,66,-149,80,-149,-1,0},
    /*88*/{51,-126,52,-126,66,-126,80,-126,-1,0},
    /*89*/{51,-155,52,-155,60,-155,66,-155,80,-155,-1,0},
    /*90*/{51,-159,52,-159,60,-159,66,-159,80,-159,-1,0},
    /*91*/{51,-192,52,-192,65,96,66,-192,80,-192,-1,0},
    /*92*/{51,-161,52,-161,66,-161,80,-161,-1,0},
    /*93*/{80,-209,-1,0},
    /*94*/{51,-148,52,-148,66,-148,80,-148,-1,0},
    /*95*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*96*/{51,-77,52,-77,55,-77,60,-77,64,-77,66,-77,70,-77,71,146,-1,0},
    /*97*/{51,-106,52,-106,53,-106,55,-106,57,-106,58,-106,60,-106,64,-106,66,-106,70,-106,71,-106,72,-106,73,-106,74,-106,77,-106,78,-106,-1,0},
    /*98*/{16,-96,26,-96,41,-96,59,-96,67,-96,68,-96,76,-96,79,-96,80,-96,83,-96,84,-96,85,-96,86,-96,-1,0},
    /*99*/{51,-105,52,-105,53,-105,55,-105,57,-105,58,-105,60,-105,64,-105,66,-105,70,-105,71,-105,72,-105,73,-105,74,-105,77,-105,78,-105,-1,0},
    /*100*/{51,-102,52,-102,53,-102,55,-102,57,-102,58,-102,60,-102,64,-102,66,-102,70,-102,71,-102,72,-102,73,-102,74,-102,77,-102,78,-102,-1,0},
    /*101*/{51,-98,52,-98,53,-98,55,-98,57,-98,58,-98,60,-98,64,-98,66,-98,70,-98,71,-98,72,-98,73,-98,74,-98,76,156,77,-98,78,-98,-1,0},
    /*102*/{68,154,80,153,-1,0},
    /*103*/{51,-107,52,-107,53,-107,55,-107,57,-107,58,-107,60,-107,64,-107,66,-107,70,-107,71,-107,72,-107,73,-107,74,-107,77,-107,78,-107,-1,0},
    /*104*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*105*/{16,-97,26,-97,41,-97,59,-97,67,-97,68,-97,76,-97,79,-97,80,-97,83,-97,84,-97,85,-97,86,-97,-1,0},
    /*106*/{51,-83,52,-83,55,-83,57,128,58,129,60,-83,64,-83,66,-83,70,-83,71,-83,72,-83,77,-83,78,-83,-1,0},
    /*107*/{81,149,-1,0},
    /*108*/{51,-89,52,-89,53,-89,55,-89,57,-89,58,-89,60,-89,64,-89,66,-89,70,-89,71,-89,72,-89,73,-89,74,-89,77,-89,78,-89,-1,0},
    /*109*/{66,148,-1,0},
    /*110*/{51,-76,52,-76,55,-76,60,-76,64,-76,66,-76,70,144,-1,0},
    /*111*/{51,-101,52,-101,53,-101,55,-101,57,-101,58,-101,60,-101,64,-101,66,-101,70,-101,71,-101,72,-101,73,-101,74,-101,77,-101,78,-101,-1,0},
    /*112*/{51,-94,52,-94,53,-94,55,-94,57,-94,58,-94,60,-94,64,-94,66,-94,70,-94,71,-94,72,-94,73,-94,74,-94,77,-94,78,-94,-1,0},
    /*113*/{16,-95,26,-95,41,-95,59,-95,67,-95,68,-95,76,-95,79,-95,80,-95,83,-95,84,-95,85,-95,86,-95,-1,0},
    /*114*/{51,-108,52,-108,53,-108,55,-108,57,-108,58,-108,60,-108,64,-108,66,-108,70,-108,71,-108,72,-108,73,-108,74,-108,77,-108,78,-108,-1,0},
    /*115*/{51,-99,52,-99,53,-99,55,-99,57,-99,58,-99,60,-99,64,-99,66,-99,70,-99,71,-99,72,-99,73,-99,74,-99,77,-99,78,-99,-1,0},
    /*116*/{51,-104,52,-104,53,-104,55,-104,57,-104,58,-104,60,-104,64,-104,66,-104,70,-104,71,-104,72,-104,73,-104,74,-104,77,-104,78,-104,-1,0},
    /*117*/{51,-79,52,-79,55,-79,60,-79,64,-79,66,-79,70,-79,71,-79,72,142,-1,0},
    /*118*/{51,-86,52,-86,53,131,55,-86,57,-86,58,-86,60,-86,64,-86,66,-86,70,-86,71,-86,72,-86,73,133,74,132,77,-86,78,-86,-1,0},
    /*119*/{68,140,80,139,-1,0},
    /*120*/{52,-113,64,-113,66,-113,-1,0},
    /*121*/{51,-81,52,-81,55,-81,60,-81,64,-81,66,-81,70,-81,71,-81,72,-81,77,126,78,125,-1,0},
    /*122*/{16,115,26,79,41,104,59,105,67,108,68,103,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*123*/{51,-93,52,-93,53,-93,55,-93,57,-93,58,-93,60,-93,64,-93,66,-93,70,-93,71,-93,72,-93,73,-93,74,-93,77,-93,78,-93,-1,0},
    /*124*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*125*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*126*/{51,-85,52,-85,55,-85,57,128,58,129,60,-85,64,-85,66,-85,70,-85,71,-85,72,-85,77,-85,78,-85,-1,0},
    /*127*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*128*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*129*/{51,-88,52,-88,53,131,55,-88,57,-88,58,-88,60,-88,64,-88,66,-88,70,-88,71,-88,72,-88,73,133,74,132,77,-88,78,-88,-1,0},
    /*130*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*131*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*132*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*133*/{51,-91,52,-91,53,-91,55,-91,57,-91,58,-91,60,-91,64,-91,66,-91,70,-91,71,-91,72,-91,73,-91,74,-91,77,-91,78,-91,-1,0},
    /*134*/{51,-92,52,-92,53,-92,55,-92,57,-92,58,-92,60,-92,64,-92,66,-92,70,-92,71,-92,72,-92,73,-92,74,-92,77,-92,78,-92,-1,0},
    /*135*/{51,-90,52,-90,53,-90,55,-90,57,-90,58,-90,60,-90,64,-90,66,-90,70,-90,71,-90,72,-90,73,-90,74,-90,77,-90,78,-90,-1,0},
    /*136*/{51,-87,52,-87,53,131,55,-87,57,-87,58,-87,60,-87,64,-87,66,-87,70,-87,71,-87,72,-87,73,133,74,132,77,-87,78,-87,-1,0},
    /*137*/{51,-84,52,-84,55,-84,57,128,58,129,60,-84,64,-84,66,-84,70,-84,71,-84,72,-84,77,-84,78,-84,-1,0},
    /*138*/{68,141,-1,0},
    /*139*/{51,-112,52,-112,53,-112,55,-112,57,-112,58,-112,60,-112,64,-112,66,-112,70,-112,71,-112,72,-112,73,-112,74,-112,77,-112,78,-112,-1,0},
    /*140*/{51,-111,52,-111,53,-111,55,-111,57,-111,58,-111,60,-111,64,-111,66,-111,70,-111,71,-111,72,-111,73,-111,74,-111,77,-111,78,-111,-1,0},
    /*141*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*142*/{51,-82,52,-82,55,-82,60,-82,64,-82,66,-82,70,-82,71,-82,72,-82,77,126,78,125,-1,0},
    /*143*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*144*/{51,-78,52,-78,55,-78,60,-78,64,-78,66,-78,70,-78,71,146,-1,0},
    /*145*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*146*/{51,-80,52,-80,55,-80,60,-80,64,-80,66,-80,70,-80,71,-80,72,142,-1,0},
    /*147*/{51,-190,52,-190,66,-190,80,-190,-1,0},
    /*148*/{67,150,-1,0},
    /*149*/{51,-103,52,-103,53,-103,55,-103,57,-103,58,-103,60,-103,64,-103,66,-103,70,-103,71,-103,72,-103,73,-103,74,-103,77,-103,78,-103,-1,0},
    /*150*/{60,152,-1,0},
    /*151*/{51,-100,52,-100,53,-100,55,-100,57,-100,58,-100,60,-100,64,-100,66,-100,70,-100,71,-100,72,-100,73,-100,74,-100,77,-100,78,-100,-1,0},
    /*152*/{68,155,-1,0},
    /*153*/{51,-110,52,-110,53,-110,55,-110,57,-110,58,-110,60,-110,64,-110,66,-110,70,-110,71,-110,72,-110,73,-110,74,-110,77,-110,78,-110,-1,0},
    /*154*/{51,-109,52,-109,53,-109,55,-109,57,-109,58,-109,60,-109,64,-109,66,-109,70,-109,71,-109,72,-109,73,-109,74,-109,77,-109,78,-109,-1,0},
    /*155*/{80,157,-1,0},
    /*156*/{39,-35,51,-35,52,-35,53,-35,55,-35,57,-35,58,-35,60,-35,61,-35,64,-35,66,-35,70,-35,71,-35,72,-35,73,-35,74,-35,76,-35,77,-35,78,-35,80,-35,-1,0},
    /*157*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*158*/{66,160,-1,0},
    /*159*/{51,-189,52,-189,66,-189,80,-189,-1,0},
    /*160*/{51,-154,52,-154,60,-154,66,-154,80,-154,-1,0},
    /*161*/{51,-152,52,-152,60,-152,66,-152,80,-152,-1,0},
    /*162*/{51,-151,52,-151,60,-151,66,-151,80,-151,-1,0},
    /*163*/{39,-34,51,-34,52,-34,53,-34,55,-34,57,-34,58,-34,60,-34,61,-34,64,-34,66,-34,70,-34,71,-34,72,-34,73,-34,74,-34,76,-34,77,-34,78,-34,80,-34,-1,0},
    /*164*/{59,166,-1,0},
    /*165*/{19,187,20,190,29,186,60,188,-1,0},
    /*166*/{9,-227,33,168,51,-227,-1,0},
    /*167*/{59,180,-1,0},
    /*168*/{9,173,51,-227,-1,0},
    /*169*/{9,-219,51,-219,-1,0},
    /*170*/{51,-204,-1,0},
    /*171*/{51,-221,-1,0},
    /*172*/{59,174,-1,0},
    /*173*/{68,103,79,120,-1,0},
    /*174*/{52,178,60,-222,-1,0},
    /*175*/{60,177,-1,0},
    /*176*/{51,-220,-1,0},
    /*177*/{68,103,79,120,-1,0},
    /*178*/{60,-223,-1,0},
    /*179*/{26,79,76,72,80,78,-1,0},
    /*180*/{39,-32,52,184,60,-32,61,-32,76,156,-1,0},
    /*181*/{60,183,-1,0},
    /*182*/{9,-218,51,-218,-1,0},
    /*183*/{26,79,76,72,80,78,-1,0},
    /*184*/{39,-31,60,-31,61,-31,-1,0},
    /*185*/{3,-216,5,-216,7,-216,12,-216,18,-216,23,-216,26,-216,27,-216,36,-216,37,-216,44,-216,46,-216,49,-216,50,-216,76,-216,80,-216,-1,0},
    /*186*/{3,-215,5,-215,7,-215,12,-215,18,-215,23,-215,26,-215,27,-215,36,-215,37,-215,44,-215,46,-215,49,-215,50,-215,76,-215,80,-215,-1,0},
    /*187*/{9,-211,33,-211,51,-211,-1,0},
    /*188*/{60,198,-1,0},
    /*189*/{3,-217,5,-217,7,-217,12,-217,18,-217,23,-217,26,-217,27,-217,36,-217,37,-217,44,-217,46,-217,49,-217,50,-217,76,-217,80,-217,-1,0},
    /*190*/{52,196,60,-213,-1,0},
    /*191*/{3,86,5,81,7,68,12,95,18,84,23,64,26,79,27,93,36,90,37,82,44,73,46,75,49,91,50,92,76,72,80,78,-1,0},
    /*192*/{80,195,-1,0},
    /*193*/{52,-214,60,-214,-1,0},
    /*194*/{51,-143,52,-143,60,-143,-1,0},
    /*195*/{19,187,20,190,29,186,-1,0},
    /*196*/{60,-212,-1,0},
    /*197*/{9,-210,33,-210,51,-210,-1,0},
    /*198*/{51,-157,52,-157,60,-157,66,-157,80,-157,-1,0},
    /*199*/{80,195,-1,0},
    /*200*/{51,-200,52,203,-1,0},
    /*201*/{51,-199,-1,0},
    /*202*/{80,195,-1,0},
    /*203*/{51,-201,-1,0},
    /*204*/{3,86,5,81,7,68,12,95,18,84,23,64,26,79,27,93,36,90,37,82,44,73,46,75,49,91,50,92,76,72,80,78,-1,0},
    /*205*/{80,195,-1,0},
    /*206*/{51,-198,-1,0},
    /*207*/{3,-24,4,-24,5,-24,7,-24,8,-24,12,-24,13,-24,14,-24,15,-24,18,-24,23,-24,25,-24,26,-24,27,-24,28,-24,30,-24,31,-24,34,-24,36,-24,37,-24,38,-24,43,-24,44,-24,45,-24,46,-24,48,-24,49,-24,50,-24,62,-24,76,-24,80,-24,-1,0},
    /*208*/{61,-50,-1,0},
    /*209*/{26,-54,76,-54,80,-54,-1,0},
    /*210*/{26,79,76,72,80,78,-1,0},
    /*211*/{39,213,61,-49,-1,0},
    /*212*/{26,79,76,72,80,78,-1,0},
    /*213*/{61,-52,-1,0},
    /*214*/{39,216,61,-48,-1,0},
    /*215*/{26,79,76,72,80,78,-1,0},
    /*216*/{61,-51,-1,0},
    /*217*/{51,-19,55,220,61,-227,-1,0},
    /*218*/{61,223,-1,0},
    /*219*/{26,79,76,72,80,78,-1,0},
    /*220*/{61,-30,-1,0},
    /*221*/{61,-29,-1,0},
    /*222*/{3,-227,4,46,5,-227,7,-227,8,27,12,-227,13,28,14,11,18,-227,23,-227,25,13,26,-227,27,-227,28,47,34,45,36,-227,37,-227,38,12,43,25,44,-227,45,26,46,-227,48,-227,49,-227,50,-227,62,-227,76,-227,80,-227,-1,0},
    /*223*/{62,228,-1,0},
    /*224*/{3,-206,5,-206,7,-206,12,-206,18,-206,23,-206,26,-206,27,-206,36,-206,37,-206,44,-206,46,-206,48,-206,49,-206,50,-206,62,-23,76,-206,80,-206,-1,0},
    /*225*/{3,-227,4,46,5,-227,7,-227,8,27,12,-227,13,28,14,11,18,-227,23,-227,25,13,26,-227,27,-227,28,47,34,45,36,-227,37,-227,38,12,43,25,44,-227,45,26,46,-227,48,-227,49,-227,50,-227,62,-227,76,-227,80,-227,-1,0},
    /*226*/{62,-22,-1,0},
    /*227*/{51,-15,-1,0},
    /*228*/{51,-18,55,220,61,-227,-1,0},
    /*229*/{61,231,-1,0},
    /*230*/{3,-227,4,46,5,-227,7,-227,8,27,12,-227,13,28,14,11,18,-227,23,-227,25,13,26,-227,27,-227,28,47,34,45,36,-227,37,-227,38,12,43,25,44,-227,45,26,46,-227,48,-227,49,-227,50,-227,62,-227,76,-227,80,-227,-1,0},
    /*231*/{62,233,-1,0},
    /*232*/{51,-14,-1,0},
    /*233*/{61,235,-1,0},
    /*234*/{80,236,-1,0},
    /*235*/{52,239,62,-184,-1,0},
    /*236*/{62,238,-1,0},
    /*237*/{51,-183,60,-183,80,-183,-1,0},
    /*238*/{80,236,-1,0},
    /*239*/{62,-185,-1,0},
    /*240*/{80,-74,-1,0},
    /*241*/{80,-73,-1,0},
    /*242*/{80,-69,-1,0},
    /*243*/{76,156,80,-75,-1,0},
    /*244*/{80,-68,-1,0},
    /*245*/{80,-70,-1,0},
    /*246*/{80,-72,-1,0},
    /*247*/{80,-71,-1,0},
    /*248*/{80,-147,-1,0},
    /*249*/{80,251,-1,0},
    /*250*/{56,252,-1,0},
    /*251*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*252*/{51,-67,-1,0},
    /*253*/{40,255,51,-169,80,-169,-1,0},
    /*254*/{59,256,-1,0},
    /*255*/{5,81,7,68,13,28,23,64,26,79,36,90,44,73,49,91,76,72,80,78,-1,0},
    /*256*/{60,-173,-1,0},
    /*257*/{60,-171,-1,0},
    /*258*/{60,263,-1,0},
    /*259*/{60,-174,76,156,-1,0},
    /*260*/{60,-170,-1,0},
    /*261*/{60,-172,-1,0},
    /*262*/{61,264,-1,0},
    /*263*/{6,269,11,266,-1,0},
    /*264*/{62,313,-1,0},
    /*265*/{55,311,-1,0},
    /*266*/{6,269,11,266,62,-175,-1,0},
    /*267*/{3,86,5,81,7,68,12,95,13,28,17,278,18,84,23,64,26,79,27,93,35,287,36,90,37,82,38,12,44,73,45,26,46,75,49,91,50,92,76,72,80,78,-1,0},
    /*268*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*269*/{55,271,-1,0},
    /*270*/{3,-178,5,-178,6,269,7,-178,11,266,12,-178,13,-178,17,-178,18,-178,23,-178,26,-178,27,-178,35,-178,36,-178,37,-178,38,-178,44,-178,45,-178,46,-178,49,-178,50,-178,76,-178,80,-178,-1,0},
    /*271*/{3,-180,5,-180,7,-180,12,-180,13,-180,17,-180,18,-180,23,-180,26,-180,27,-180,35,-180,36,-180,37,-180,38,-180,44,-180,45,-180,46,-180,49,-180,50,-180,76,-180,80,-180,-1,0},
    /*272*/{51,-136,80,-136,-1,0},
    /*273*/{51,-138,80,-138,-1,0},
    /*274*/{51,309,-1,0},
    /*275*/{51,-121,80,-121,-1,0},
    /*276*/{51,-124,52,-124,66,-124,80,-124,-1,0},
    /*277*/{65,304,-1,0},
    /*278*/{51,-122,80,-122,-1,0},
    /*279*/{51,-137,80,-137,-1,0},
    /*280*/{51,-125,52,-125,66,-125,76,156,80,-125,-1,0},
    /*281*/{51,-134,52,-134,66,-134,80,-134,-1,0},
    /*282*/{80,294,-1,0},
    /*283*/{51,-133,52,-133,66,-133,80,-133,-1,0},
    /*284*/{51,-123,52,-123,66,-123,80,-123,-1,0},
    /*285*/{51,-135,52,-135,66,-135,80,-135,-1,0},
    /*286*/{65,288,-1,0},
    /*287*/{3,86,5,81,7,68,12,95,17,278,18,84,23,64,26,79,27,93,35,287,36,90,37,82,44,73,46,75,49,91,50,92,76,72,80,78,-1,0},
    /*288*/{52,290,66,291,-1,0},
    /*289*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*290*/{51,-188,52,-188,66,-188,80,-188,-1,0},
    /*291*/{66,293,-1,0},
    /*292*/{51,-187,52,-187,66,-187,80,-187,-1,0},
    /*293*/{51,-143,52,-143,63,300,-1,0},
    /*294*/{51,-141,52,-141,-1,0},
    /*295*/{51,-182,-1,0},
    /*296*/{51,-142,52,-142,-1,0},
    /*297*/{51,-195,52,-195,63,300,-1,0},
    /*298*/{51,-194,52,-194,-1,0},
    /*299*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*300*/{64,302,-1,0},
    /*301*/{51,-197,52,-197,63,-197,-1,0},
    /*302*/{51,-196,52,-196,-1,0},
    /*303*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*304*/{52,306,-1,0},
    /*305*/{16,115,26,79,41,104,57,99,58,114,59,105,67,108,68,103,75,106,76,72,79,120,80,78,83,112,84,101,85,98,86,100,-1,0},
    /*306*/{66,308,-1,0},
    /*307*/{51,-193,52,-193,66,-193,80,-193,-1,0},
    /*308*/{6,-177,11,-177,62,-177,-1,0},
    /*309*/{62,-176,-1,0},
    /*310*/{3,-179,5,-179,6,269,7,-179,11,266,12,-179,13,-179,17,-179,18,-179,23,-179,26,-179,27,-179,35,-179,36,-179,37,-179,38,-179,44,-179,45,-179,46,-179,49,-179,50,-179,76,-179,80,-179,-1,0},
    /*311*/{3,-181,5,-181,7,-181,12,-181,13,-181,17,-181,18,-181,23,-181,26,-181,27,-181,35,-181,36,-181,37,-181,38,-181,44,-181,45,-181,46,-181,49,-181,50,-181,76,-181,80,-181,-1,0},
    /*312*/{51,-168,80,-168,-1,0},
    /*313*/{51,-119,-1,0},
    /*314*/{80,294,-1,0},
    /*315*/{51,-140,52,318,-1,0},
    /*316*/{51,-120,-1,0},
    /*317*/{80,294,-1,0},
    /*318*/{51,-139,-1,0},
    /*319*/{0,-12,2,-12,8,-12,10,-12,13,-12,14,-12,21,-12,22,-12,24,-12,25,-12,32,-12,38,-12,43,-12,45,-12,47,-12,62,-12,-1,0},
    /*320*/{80,322,-1,0},
    /*321*/{51,-21,55,220,61,-227,-1,0},
    /*322*/{61,324,-1,0},
    /*323*/{3,-227,4,46,5,-227,7,-227,8,27,12,-227,13,28,14,11,18,-227,23,-227,25,13,26,-227,27,-227,28,47,34,45,36,-227,37,-227,38,12,43,25,44,-227,45,26,46,-227,48,-227,49,-227,50,-227,62,-227,76,-227,80,-227,-1,0},
    /*324*/{62,326,-1,0},
    /*325*/{51,-17,-1,0},
    /*326*/{0,-9,2,-9,8,-9,10,-9,13,-9,14,-9,21,-9,22,-9,24,-9,25,-9,32,-9,38,-9,43,-9,45,-9,47,-9,62,-9,-1,0},
    /*327*/{61,329,-1,0},
    /*328*/{2,30,8,27,10,8,13,28,14,11,21,29,22,14,24,21,25,13,32,23,38,12,43,25,45,26,47,17,-1,0},
    /*329*/{62,331,-1,0},
    /*330*/{51,-13,-1,0},
    /*331*/{0,-8,2,-8,8,-8,10,-8,13,-8,14,-8,21,-8,22,-8,24,-8,25,-8,32,-8,38,-8,43,-8,45,-8,47,-8,62,-8,-1,0},
    /*332*/{3,86,5,81,7,68,12,95,13,28,17,278,18,84,23,64,26,79,27,93,35,287,36,90,37,82,38,12,39,41,44,73,45,26,46,75,49,91,50,92,51,-46,55,39,61,-227,76,72,80,78,-1,0},
    /*333*/{61,336,-1,0},
    /*334*/{51,-40,-1,0},
    /*335*/{3,-227,4,46,5,-227,7,-227,8,27,12,-227,13,28,14,11,15,343,18,-227,23,-227,25,13,26,-227,27,-227,28,47,30,337,31,339,34,45,36,-227,37,-227,38,12,43,25,44,-227,45,26,46,-227,48,-227,49,-227,50,-227,62,-227,76,-227,80,-227,-1,0},
    /*336*/{3,86,5,81,7,68,12,95,13,28,17,278,18,84,23,64,26,79,27,93,35,287,36,90,37,82,38,12,44,73,45,26,46,75,49,91,50,92,76,72,80,78,-1,0},
    /*337*/{3,-58,4,-58,5,-58,7,-58,8,-58,12,-58,13,-58,14,-58,15,-58,18,-58,23,-58,25,-58,26,-58,27,-58,28,-58,30,-58,31,-58,34,-58,36,-58,37,-58,38,-58,43,-58,44,-58,45,-58,46,-58,48,-58,49,-58,50,-58,62,-58,76,-58,80,-58,-1,0},
    /*338*/{3,86,5,81,7,68,12,95,13,28,17,278,18,84,23,64,26,79,27,93,35,287,36,90,37,82,38,12,44,73,45,26,46,75,49,91,50,92,76,72,80,78,-1,0},
    /*339*/{3,-206,5,-206,7,-206,12,-206,18,-206,23,-206,26,-206,27,-206,36,-206,37,-206,44,-206,46,-206,48,-206,49,-206,50,-206,62,-56,76,-206,80,-206,-1,0},
    /*340*/{3,-59,4,-59,5,-59,7,-59,8,-59,12,-59,13,-59,14,-59,15,-59,18,-59,23,-59,25,-59,26,-59,27,-59,28,-59,30,-59,31,-59,34,-59,36,-59,37,-59,38,-59,43,-59,44,-59,45,-59,46,-59,48,-59,49,-59,50,-59,62,-59,76,-59,80,-59,-1,0},
    /*341*/{3,-57,4,-57,5,-57,7,-57,8,-57,12,-57,13,-57,14,-57,15,-57,18,-57,23,-57,25,-57,26,-57,27,-57,28,-57,30,-57,31,-57,34,-57,36,-57,37,-57,38,-57,43,-57,44,-57,45,-57,46,-57,48,-57,49,-57,50,-57,62,-57,76,-57,80,-57,-1,0},
    /*342*/{80,348,-1,0},
    /*343*/{62,347,-1,0},
    /*344*/{3,-227,4,46,5,-227,7,-227,8,27,12,-227,13,28,14,11,15,343,18,-227,23,-227,25,13,26,-227,27,-227,28,47,30,337,31,339,34,45,36,-227,37,-227,38,12,43,25,44,-227,45,26,46,-227,48,-227,49,-227,50,-227,62,-227,76,-227,80,-227,-1,0},
    /*345*/{62,-55,-1,0},
    /*346*/{51,-47,-1,0},
    /*347*/{59,349,-1,0},
    /*348*/{19,350,60,352,-1,0},
    /*349*/{3,86,5,81,7,68,12,95,18,84,23,64,26,79,27,93,36,90,37,82,44,73,46,75,49,91,50,92,76,72,80,78,-1,0},
    /*350*/{60,357,-1,0},
    /*351*/{51,356,-1,0},
    /*352*/{52,354,60,-64,-1,0},
    /*353*/{19,350,-1,0},
    /*354*/{60,-65,-1,0},
    /*355*/{3,-63,4,-63,5,-63,7,-63,8,-63,12,-63,13,-63,14,-63,15,-63,18,-63,23,-63,25,-63,26,-63,27,-63,28,-63,30,-63,31,-63,34,-63,36,-63,37,-63,38,-63,43,-63,44,-63,45,-63,46,-63,48,-63,49,-63,50,-63,62,-63,76,-63,80,-63,-1,0},
    /*356*/{51,358,-1,0},
    /*357*/{3,-62,4,-62,5,-62,7,-62,8,-62,12,-62,13,-62,14,-62,15,-62,18,-62,23,-62,25,-62,26,-62,27,-62,28,-62,30,-62,31,-62,34,-62,36,-62,37,-62,38,-62,43,-62,44,-62,45,-62,46,-62,48,-62,49,-62,50,-62,62,-62,76,-62,80,-62,-1,0},
    /*358*/{80,195,-1,0},
    /*359*/{52,-66,60,-66,-1,0},
    /*360*/{80,294,-1,0},
    /*361*/{51,363,-1,0},
    /*362*/{3,-60,4,-60,5,-60,7,-60,8,-60,12,-60,13,-60,14,-60,15,-60,18,-60,23,-60,25,-60,26,-60,27,-60,28,-60,30,-60,31,-60,34,-60,36,-60,37,-60,38,-60,43,-60,44,-60,45,-60,46,-60,48,-60,49,-60,50,-60,62,-60,76,-60,80,-60,-1,0},
    /*363*/{80,294,-1,0},
    /*364*/{51,366,-1,0},
    /*365*/{3,-61,4,-61,5,-61,7,-61,8,-61,12,-61,13,-61,14,-61,15,-61,18,-61,23,-61,25,-61,26,-61,27,-61,28,-61,30,-61,31,-61,34,-61,36,-61,37,-61,38,-61,43,-61,44,-61,45,-61,46,-61,48,-61,49,-61,50,-61,62,-61,76,-61,80,-61,-1,0},
    /*366*/{0,-5,62,-5,-1,0},
    /*367*/{80,369,-1,0},
    /*368*/{51,-20,55,220,61,-227,-1,0},
    /*369*/{61,371,-1,0},
    /*370*/{3,-227,4,46,5,-227,7,-227,8,27,12,-227,13,28,14,11,18,-227,23,-227,25,13,26,-227,27,-227,28,47,34,45,36,-227,37,-227,38,12,43,25,44,-227,45,26,46,-227,48,-227,49,-227,50,-227,62,-227,76,-227,80,-227,-1,0},
    /*371*/{62,373,-1,0},
    /*372*/{51,-16,-1,0},
    /*373*/{51,-186,-1,0},
    /*374*/{51,-164,61,376,80,-164,-1,0},
    /*375*/{3,86,5,81,7,68,12,95,13,28,17,278,18,84,23,64,26,79,27,93,35,287,36,90,37,82,38,12,44,73,45,26,46,75,49,91,50,92,76,72,80,78,-1,0},
    /*376*/{62,383,-1,0},
    /*377*/{80,294,-1,0},
    /*378*/{3,86,5,81,7,68,12,95,13,28,17,278,18,84,23,64,26,79,27,93,35,287,36,90,37,82,38,12,44,73,45,26,46,75,49,91,50,92,62,-165,76,72,80,78,-1,0},
    /*379*/{62,-166,-1,0},
    /*380*/{51,382,-1,0},
    /*381*/{3,-167,5,-167,7,-167,12,-167,13,-167,17,-167,18,-167,23,-167,26,-167,27,-167,35,-167,36,-167,37,-167,38,-167,44,-167,45,-167,46,-167,49,-167,50,-167,62,-167,76,-167,80,-167,-1,0},
    /*382*/{51,-163,80,-163,-1,0},
    /*383*/{61,385,-1,0},
    /*384*/{3,86,5,81,7,68,12,95,13,28,17,278,18,84,23,64,26,79,27,93,35,287,36,90,37,82,38,12,44,73,45,26,46,75,49,91,50,92,62,387,76,72,80,78,-1,0},
    /*385*/{62,388,-1,0},
    /*386*/{51,-202,-1,0},
    /*387*/{51,-203,-1,0},
    /*388*/{0,-11,2,-11,8,-11,10,-11,13,-11,14,-11,21,-11,22,-11,24,-11,25,-11,32,-11,38,-11,43,-11,45,-11,47,-11,62,-11,-1,0},
    /*389*/{80,391,-1,0},
    /*390*/{39,41,55,39,61,-227,-1,0},
    /*391*/{61,393,-1,0},
    /*392*/{3,-227,4,46,5,-227,7,-227,8,27,12,-227,13,28,14,11,15,343,18,-227,23,-227,25,13,26,-227,27,-227,28,47,30,337,31,339,34,45,36,-227,37,-227,38,12,43,25,44,-227,45,26,46,-227,48,-227,49,-227,50,-227,62,-227,76,-227,80,-227,-1,0},
    /*393*/{62,395,-1,0},
    /*394*/{51,-45,-1,0},
    /*395*/{0,-7,2,-7,8,-7,10,-7,13,-7,14,-7,21,-7,22,-7,24,-7,25,-7,32,-7,38,-7,43,-7,45,-7,47,-7,62,-7,-1,0},
    /*396*/{0,-10,2,-10,8,-10,10,-10,13,-10,14,-10,21,-10,22,-10,24,-10,25,-10,32,-10,38,-10,43,-10,45,-10,47,-10,62,-10,-1,0},
  };

  /** access to parse action table */
  public short[][] action_table() {return _action_table;}

  /** reduce_goto table */
  protected static final short[][] _reduce_table = {
    /*0*/{4,3,8,2,98,1,-1,-1},
    /*1*/{9,14,10,34,11,8,12,5,17,23,18,17,19,15,20,30,28,18,40,6,46,32,50,9,51,33,52,21,53,31,54,19,-1,-1},
    /*2*/{-1,-1},
    /*3*/{-1,-1},
    /*4*/{-1,-1},
    /*5*/{-1,-1},
    /*6*/{-1,-1},
    /*7*/{-1,-1},
    /*8*/{-1,-1},
    /*9*/{-1,-1},
    /*10*/{-1,-1},
    /*11*/{-1,-1},
    /*12*/{80,373,-1,-1},
    /*13*/{-1,-1},
    /*14*/{9,14,10,366,11,8,12,5,17,23,18,17,19,15,20,30,28,18,40,6,46,32,50,9,51,33,52,21,53,31,54,19,-1,-1},
    /*15*/{-1,-1},
    /*16*/{-1,-1},
    /*17*/{-1,-1},
    /*18*/{-1,-1},
    /*19*/{-1,-1},
    /*20*/{-1,-1},
    /*21*/{-1,-1},
    /*22*/{-1,-1},
    /*23*/{-1,-1},
    /*24*/{15,280,41,313,42,314,47,275,48,276,49,278,50,273,51,272,53,279,58,284,59,73,60,88,61,76,63,84,64,68,65,87,66,86,67,64,68,79,69,61,70,82,72,281,73,283,74,285,-1,-1},
    /*25*/{-1,-1},
    /*26*/{15,243,29,249,59,244,60,247,61,76,62,246,63,84,64,68,65,87,66,86,67,242,68,245,69,240,72,241,-1,-1},
    /*27*/{-1,-1},
    /*28*/{-1,-1},
    /*29*/{-1,-1},
    /*30*/{-1,-1},
    /*31*/{-1,-1},
    /*32*/{-1,-1},
    /*33*/{-1,-1},
    /*34*/{-1,-1},
    /*35*/{-1,-1},
    /*36*/{-1,-1},
    /*37*/{4,39,22,41,-1,-1},
    /*38*/{15,180,16,210,92,211,-1,-1},
    /*39*/{-1,-1},
    /*40*/{15,180,92,208,-1,-1},
    /*41*/{-1,-1},
    /*42*/{4,49,5,47,14,54,21,53,28,50,40,43,46,32,50,9,51,33,52,52,53,31,54,19,85,51,86,48,-1,-1},
    /*43*/{-1,-1},
    /*44*/{-1,-1},
    /*45*/{15,65,44,199,58,69,59,73,60,88,61,76,63,84,64,68,65,87,66,86,67,64,68,79,69,61,70,82,72,62,-1,-1},
    /*46*/{-1,-1},
    /*47*/{15,65,43,66,44,70,58,69,59,73,60,88,61,76,63,84,64,68,65,87,66,86,67,64,68,79,69,61,70,82,71,75,72,62,-1,-1},
    /*48*/{-1,-1},
    /*49*/{-1,-1},
    /*50*/{-1,-1},
    /*51*/{-1,-1},
    /*52*/{-1,-1},
    /*53*/{-1,-1},
    /*54*/{4,49,5,47,14,54,21,55,28,50,40,43,46,32,50,9,51,33,52,52,53,31,54,19,85,51,86,48,-1,-1},
    /*55*/{-1,-1},
    /*56*/{-1,-1},
    /*57*/{-1,-1},
    /*58*/{-1,-1},
    /*59*/{-1,-1},
    /*60*/{-1,-1},
    /*61*/{-1,-1},
    /*62*/{-1,-1},
    /*63*/{-1,-1},
    /*64*/{-1,-1},
    /*65*/{-1,-1},
    /*66*/{-1,-1},
    /*67*/{-1,-1},
    /*68*/{-1,-1},
    /*69*/{-1,-1},
    /*70*/{-1,-1},
    /*71*/{-1,-1},
    /*72*/{64,160,65,162,66,161,-1,-1},
    /*73*/{-1,-1},
    /*74*/{-1,-1},
    /*75*/{-1,-1},
    /*76*/{-1,-1},
    /*77*/{-1,-1},
    /*78*/{-1,-1},
    /*79*/{-1,-1},
    /*80*/{-1,-1},
    /*81*/{-1,-1},
    /*82*/{-1,-1},
    /*83*/{-1,-1},
    /*84*/{-1,-1},
    /*85*/{-1,-1},
    /*86*/{-1,-1},
    /*87*/{-1,-1},
    /*88*/{-1,-1},
    /*89*/{-1,-1},
    /*90*/{-1,-1},
    /*91*/{-1,-1},
    /*92*/{-1,-1},
    /*93*/{-1,-1},
    /*94*/{-1,-1},
    /*95*/{7,122,15,101,30,120,31,109,32,110,33,96,34,117,35,121,36,106,37,118,38,108,39,112,75,115,76,116,-1,-1},
    /*96*/{-1,-1},
    /*97*/{-1,-1},
    /*98*/{-1,-1},
    /*99*/{-1,-1},
    /*100*/{-1,-1},
    /*101*/{-1,-1},
    /*102*/{-1,-1},
    /*103*/{-1,-1},
    /*104*/{7,122,15,101,30,150,32,110,33,96,34,117,35,121,36,106,37,118,38,108,39,112,75,115,76,116,-1,-1},
    /*105*/{-1,-1},
    /*106*/{-1,-1},
    /*107*/{-1,-1},
    /*108*/{-1,-1},
    /*109*/{-1,-1},
    /*110*/{-1,-1},
    /*111*/{-1,-1},
    /*112*/{-1,-1},
    /*113*/{-1,-1},
    /*114*/{-1,-1},
    /*115*/{-1,-1},
    /*116*/{-1,-1},
    /*117*/{-1,-1},
    /*118*/{-1,-1},
    /*119*/{-1,-1},
    /*120*/{-1,-1},
    /*121*/{-1,-1},
    /*122*/{15,101,39,123,75,115,76,116,-1,-1},
    /*123*/{-1,-1},
    /*124*/{7,122,15,101,36,137,37,118,38,108,39,112,75,115,76,116,-1,-1},
    /*125*/{7,122,15,101,36,126,37,118,38,108,39,112,75,115,76,116,-1,-1},
    /*126*/{-1,-1},
    /*127*/{7,122,15,101,37,136,38,108,39,112,75,115,76,116,-1,-1},
    /*128*/{7,122,15,101,37,129,38,108,39,112,75,115,76,116,-1,-1},
    /*129*/{-1,-1},
    /*130*/{7,122,15,101,38,135,39,112,75,115,76,116,-1,-1},
    /*131*/{7,122,15,101,38,134,39,112,75,115,76,116,-1,-1},
    /*132*/{7,122,15,101,38,133,39,112,75,115,76,116,-1,-1},
    /*133*/{-1,-1},
    /*134*/{-1,-1},
    /*135*/{-1,-1},
    /*136*/{-1,-1},
    /*137*/{-1,-1},
    /*138*/{-1,-1},
    /*139*/{-1,-1},
    /*140*/{-1,-1},
    /*141*/{7,122,15,101,35,142,36,106,37,118,38,108,39,112,75,115,76,116,-1,-1},
    /*142*/{-1,-1},
    /*143*/{7,122,15,101,33,144,34,117,35,121,36,106,37,118,38,108,39,112,75,115,76,116,-1,-1},
    /*144*/{-1,-1},
    /*145*/{7,122,15,101,34,146,35,121,36,106,37,118,38,108,39,112,75,115,76,116,-1,-1},
    /*146*/{-1,-1},
    /*147*/{-1,-1},
    /*148*/{-1,-1},
    /*149*/{-1,-1},
    /*150*/{-1,-1},
    /*151*/{-1,-1},
    /*152*/{-1,-1},
    /*153*/{-1,-1},
    /*154*/{-1,-1},
    /*155*/{-1,-1},
    /*156*/{-1,-1},
    /*157*/{7,122,15,101,30,120,31,158,32,110,33,96,34,117,35,121,36,106,37,118,38,108,39,112,75,115,76,116,-1,-1},
    /*158*/{-1,-1},
    /*159*/{-1,-1},
    /*160*/{-1,-1},
    /*161*/{-1,-1},
    /*162*/{-1,-1},
    /*163*/{-1,-1},
    /*164*/{91,166,-1,-1},
    /*165*/{6,191,83,190,89,188,-1,-1},
    /*166*/{4,169,84,168,-1,-1},
    /*167*/{-1,-1},
    /*168*/{2,170,4,171,-1,-1},
    /*169*/{-1,-1},
    /*170*/{-1,-1},
    /*171*/{-1,-1},
    /*172*/{-1,-1},
    /*173*/{3,175,76,174,-1,-1},
    /*174*/{-1,-1},
    /*175*/{-1,-1},
    /*176*/{-1,-1},
    /*177*/{3,178,76,174,-1,-1},
    /*178*/{-1,-1},
    /*179*/{15,180,92,181,-1,-1},
    /*180*/{-1,-1},
    /*181*/{-1,-1},
    /*182*/{-1,-1},
    /*183*/{15,180,92,184,-1,-1},
    /*184*/{-1,-1},
    /*185*/{-1,-1},
    /*186*/{-1,-1},
    /*187*/{-1,-1},
    /*188*/{-1,-1},
    /*189*/{-1,-1},
    /*190*/{-1,-1},
    /*191*/{15,65,44,192,58,69,59,73,60,88,61,76,63,84,64,68,65,87,66,86,67,64,68,79,69,61,70,82,72,62,-1,-1},
    /*192*/{80,193,-1,-1},
    /*193*/{-1,-1},
    /*194*/{-1,-1},
    /*195*/{6,191,83,190,89,196,-1,-1},
    /*196*/{-1,-1},
    /*197*/{-1,-1},
    /*198*/{-1,-1},
    /*199*/{80,200,93,201,-1,-1},
    /*200*/{-1,-1},
    /*201*/{-1,-1},
    /*202*/{80,200,93,203,-1,-1},
    /*203*/{-1,-1},
    /*204*/{15,65,44,205,58,69,59,73,60,88,61,76,63,84,64,68,65,87,66,86,67,64,68,79,69,61,70,82,72,62,-1,-1},
    /*205*/{80,200,93,206,-1,-1},
    /*206*/{-1,-1},
    /*207*/{-1,-1},
    /*208*/{-1,-1},
    /*209*/{-1,-1},
    /*210*/{15,180,92,214,-1,-1},
    /*211*/{-1,-1},
    /*212*/{15,180,92,213,-1,-1},
    /*213*/{-1,-1},
    /*214*/{-1,-1},
    /*215*/{15,180,92,216,-1,-1},
    /*216*/{-1,-1},
    /*217*/{4,220,95,218,-1,-1},
    /*218*/{-1,-1},
    /*219*/{15,180,92,221,-1,-1},
    /*220*/{-1,-1},
    /*221*/{-1,-1},
    /*222*/{4,224,5,47,13,223,14,225,28,50,40,43,46,32,50,9,51,33,52,52,53,31,54,19,85,51,86,48,-1,-1},
    /*223*/{-1,-1},
    /*224*/{-1,-1},
    /*225*/{4,224,5,47,13,226,14,225,28,50,40,43,46,32,50,9,51,33,52,52,53,31,54,19,85,51,86,48,-1,-1},
    /*226*/{-1,-1},
    /*227*/{-1,-1},
    /*228*/{4,220,95,229,-1,-1},
    /*229*/{-1,-1},
    /*230*/{4,224,5,47,13,231,14,225,28,50,40,43,46,32,50,9,51,33,52,52,53,31,54,19,85,51,86,48,-1,-1},
    /*231*/{-1,-1},
    /*232*/{-1,-1},
    /*233*/{-1,-1},
    /*234*/{96,236,-1,-1},
    /*235*/{-1,-1},
    /*236*/{-1,-1},
    /*237*/{-1,-1},
    /*238*/{96,239,-1,-1},
    /*239*/{-1,-1},
    /*240*/{-1,-1},
    /*241*/{-1,-1},
    /*242*/{-1,-1},
    /*243*/{-1,-1},
    /*244*/{-1,-1},
    /*245*/{-1,-1},
    /*246*/{-1,-1},
    /*247*/{-1,-1},
    /*248*/{-1,-1},
    /*249*/{-1,-1},
    /*250*/{-1,-1},
    /*251*/{7,122,15,101,30,252,32,110,33,96,34,117,35,121,36,106,37,118,38,108,39,112,75,115,76,116,-1,-1},
    /*252*/{-1,-1},
    /*253*/{-1,-1},
    /*254*/{-1,-1},
    /*255*/{15,259,45,258,50,256,59,260,64,68,65,87,66,86,67,257,68,261,-1,-1},
    /*256*/{-1,-1},
    /*257*/{-1,-1},
    /*258*/{-1,-1},
    /*259*/{-1,-1},
    /*260*/{-1,-1},
    /*261*/{-1,-1},
    /*262*/{-1,-1},
    /*263*/{55,264,56,266,88,267,-1,-1},
    /*264*/{-1,-1},
    /*265*/{-1,-1},
    /*266*/{55,309,56,266,88,267,-1,-1},
    /*267*/{15,280,42,282,47,275,48,276,49,278,50,273,51,272,53,279,57,274,58,284,59,73,60,88,61,76,63,84,64,68,65,87,66,86,67,64,68,79,69,61,70,82,72,281,73,283,74,285,-1,-1},
    /*268*/{7,122,15,101,30,269,32,110,33,96,34,117,35,121,36,106,37,118,38,108,39,112,75,115,76,116,-1,-1},
    /*269*/{-1,-1},
    /*270*/{88,271,-1,-1},
    /*271*/{-1,-1},
    /*272*/{-1,-1},
    /*273*/{-1,-1},
    /*274*/{-1,-1},
    /*275*/{-1,-1},
    /*276*/{-1,-1},
    /*277*/{-1,-1},
    /*278*/{-1,-1},
    /*279*/{-1,-1},
    /*280*/{-1,-1},
    /*281*/{-1,-1},
    /*282*/{79,295,80,294,81,296,-1,-1},
    /*283*/{-1,-1},
    /*284*/{-1,-1},
    /*285*/{-1,-1},
    /*286*/{-1,-1},
    /*287*/{15,280,47,288,48,276,58,284,59,73,60,88,61,76,63,84,64,68,65,87,66,86,67,64,68,79,69,61,70,82,72,281,73,283,74,285,-1,-1},
    /*288*/{-1,-1},
    /*289*/{7,122,15,101,30,120,31,291,32,110,33,96,34,117,35,121,36,106,37,118,38,108,39,112,75,115,76,116,-1,-1},
    /*290*/{-1,-1},
    /*291*/{-1,-1},
    /*292*/{-1,-1},
    /*293*/{82,297,97,298,-1,-1},
    /*294*/{-1,-1},
    /*295*/{-1,-1},
    /*296*/{-1,-1},
    /*297*/{82,297,97,302,-1,-1},
    /*298*/{-1,-1},
    /*299*/{7,122,15,101,30,120,31,300,32,110,33,96,34,117,35,121,36,106,37,118,38,108,39,112,75,115,76,116,-1,-1},
    /*300*/{-1,-1},
    /*301*/{-1,-1},
    /*302*/{-1,-1},
    /*303*/{7,122,15,101,30,120,31,304,32,110,33,96,34,117,35,121,36,106,37,118,38,108,39,112,75,115,76,116,-1,-1},
    /*304*/{-1,-1},
    /*305*/{7,122,15,101,30,120,31,306,32,110,33,96,34,117,35,121,36,106,37,118,38,108,39,112,75,115,76,116,-1,-1},
    /*306*/{-1,-1},
    /*307*/{-1,-1},
    /*308*/{-1,-1},
    /*309*/{-1,-1},
    /*310*/{88,311,-1,-1},
    /*311*/{-1,-1},
    /*312*/{-1,-1},
    /*313*/{-1,-1},
    /*314*/{79,315,80,294,81,296,94,316,-1,-1},
    /*315*/{-1,-1},
    /*316*/{-1,-1},
    /*317*/{79,315,80,294,81,296,94,318,-1,-1},
    /*318*/{-1,-1},
    /*319*/{-1,-1},
    /*320*/{-1,-1},
    /*321*/{4,220,95,322,-1,-1},
    /*322*/{-1,-1},
    /*323*/{4,224,5,47,13,324,14,225,28,50,40,43,46,32,50,9,51,33,52,52,53,31,54,19,85,51,86,48,-1,-1},
    /*324*/{-1,-1},
    /*325*/{-1,-1},
    /*326*/{-1,-1},
    /*327*/{-1,-1},
    /*328*/{9,14,10,329,11,8,12,5,17,23,18,17,19,15,20,30,28,18,40,6,46,32,50,9,51,33,52,21,53,31,54,19,-1,-1},
    /*329*/{-1,-1},
    /*330*/{-1,-1},
    /*331*/{-1,-1},
    /*332*/{4,39,15,280,22,333,42,334,47,275,48,276,49,278,50,273,51,272,53,279,58,284,59,73,60,88,61,76,63,84,64,68,65,87,66,86,67,64,68,79,69,61,70,82,72,281,73,283,74,285,-1,-1},
    /*333*/{-1,-1},
    /*334*/{-1,-1},
    /*335*/{4,339,5,47,14,341,23,343,24,344,25,337,26,340,28,50,40,43,46,32,50,9,51,33,52,52,53,31,54,19,85,51,86,48,-1,-1},
    /*336*/{15,280,42,363,47,275,48,276,49,278,50,273,51,272,53,279,58,284,59,73,60,88,61,76,63,84,64,68,65,87,66,86,67,64,68,79,69,61,70,82,72,281,73,283,74,285,-1,-1},
    /*337*/{-1,-1},
    /*338*/{15,280,42,360,47,275,48,276,49,278,50,273,51,272,53,279,58,284,59,73,60,88,61,76,63,84,64,68,65,87,66,86,67,64,68,79,69,61,70,82,72,281,73,283,74,285,-1,-1},
    /*339*/{-1,-1},
    /*340*/{-1,-1},
    /*341*/{-1,-1},
    /*342*/{-1,-1},
    /*343*/{-1,-1},
    /*344*/{4,339,5,47,14,341,23,345,24,344,25,337,26,340,28,50,40,43,46,32,50,9,51,33,52,52,53,31,54,19,85,51,86,48,-1,-1},
    /*345*/{-1,-1},
    /*346*/{-1,-1},
    /*347*/{-1,-1},
    /*348*/{27,352,90,350,-1,-1},
    /*349*/{15,65,44,358,58,69,59,73,60,88,61,76,63,84,64,68,65,87,66,86,67,64,68,79,69,61,70,82,72,62,-1,-1},
    /*350*/{-1,-1},
    /*351*/{-1,-1},
    /*352*/{-1,-1},
    /*353*/{27,352,90,354,-1,-1},
    /*354*/{-1,-1},
    /*355*/{-1,-1},
    /*356*/{-1,-1},
    /*357*/{-1,-1},
    /*358*/{80,359,-1,-1},
    /*359*/{-1,-1},
    /*360*/{79,315,80,294,81,296,94,361,-1,-1},
    /*361*/{-1,-1},
    /*362*/{-1,-1},
    /*363*/{79,315,80,294,81,296,94,364,-1,-1},
    /*364*/{-1,-1},
    /*365*/{-1,-1},
    /*366*/{-1,-1},
    /*367*/{-1,-1},
    /*368*/{4,220,95,369,-1,-1},
    /*369*/{-1,-1},
    /*370*/{4,224,5,47,13,371,14,225,28,50,40,43,46,32,50,9,51,33,52,52,53,31,54,19,85,51,86,48,-1,-1},
    /*371*/{-1,-1},
    /*372*/{-1,-1},
    /*373*/{-1,-1},
    /*374*/{-1,-1},
    /*375*/{15,280,42,377,47,275,48,276,49,278,50,273,51,272,53,279,58,284,59,73,60,88,61,76,63,84,64,68,65,87,66,86,67,64,68,79,69,61,70,82,72,281,73,283,74,285,78,378,87,376,-1,-1},
    /*376*/{-1,-1},
    /*377*/{79,315,80,294,81,296,94,380,-1,-1},
    /*378*/{15,280,42,377,47,275,48,276,49,278,50,273,51,272,53,279,58,284,59,73,60,88,61,76,63,84,64,68,65,87,66,86,67,64,68,79,69,61,70,82,72,281,73,283,74,285,78,378,87,379,-1,-1},
    /*379*/{-1,-1},
    /*380*/{-1,-1},
    /*381*/{-1,-1},
    /*382*/{-1,-1},
    /*383*/{-1,-1},
    /*384*/{15,280,42,377,47,275,48,276,49,278,50,273,51,272,53,279,58,284,59,73,60,88,61,76,63,84,64,68,65,87,66,86,67,64,68,79,69,61,70,82,72,281,73,283,74,285,78,378,87,385,-1,-1},
    /*385*/{-1,-1},
    /*386*/{-1,-1},
    /*387*/{-1,-1},
    /*388*/{-1,-1},
    /*389*/{-1,-1},
    /*390*/{4,39,22,391,-1,-1},
    /*391*/{-1,-1},
    /*392*/{4,339,5,47,14,341,23,393,24,344,25,337,26,340,28,50,40,43,46,32,50,9,51,33,52,52,53,31,54,19,85,51,86,48,-1,-1},
    /*393*/{-1,-1},
    /*394*/{-1,-1},
    /*395*/{-1,-1},
    /*396*/{-1,-1},
  };

  /** access to reduce_goto table */
  public short[][] reduce_table() {return _reduce_table;}

  /** instance of action encapsulation class */
  protected CUP$actions action_obj;

  /** action encapsulation object initializer */
  protected void init_actions()
    {
      action_obj = new CUP$actions();
    }

  /** invoke a user supplied parse action */
  public java_cup.runtime.symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$do_action(act_num, parser, stack, top);
  }

  /** start state */
  public int start_state() {return 0;}
  /** start production */
  public int start_production() {return 0;}

  /** EOF symbol index */
  public int EOF_sym() {return 0;}

  /** error symbol index */
  public int error_sym() {return 1;}


  /** user initialization */
  public void user_init() throws java.lang.Exception
    {

        lexer.init();

    }

  /** scan to get the next token */
  public java_cup.runtime.token scan()
    throws java.lang.Exception
    {

        return lexer.next_token();

    }


    static String command_line[] = null;

    public static Vector import_list = new Vector();
    public static Hashtable pack_replace = new Hashtable();
    public static Stack scopes = new Stack();

    public static String currentVersion = "";
    public static String compiler_version = "1.4 beta 5, May 2002";

    private static final String yearString = "1997-2002";

    static String out_dir = ".";
    static String package_prefix = null;

    static boolean parse_only = false;
    static boolean global_import = false;

    /** used for internal checking that name conversion
        to mapped Java names is done only after parsing */
    public static boolean done_parsing = false;

    /** compiler flags */
    public static boolean include_state = false;
    public static boolean strict_names = true;

    public static boolean generateIR = false;
    public static boolean generate_skeletons = true;
    public static boolean generate_stubs = true;

    protected static boolean generateIncluded = false;
    protected static boolean inhibitionState = false;
    protected static boolean localityContraint = false;

    private static int activeParseThreads;

    /*  a la CORBA 2.4, allow forward declarations that remain undefined */
    public static boolean sloppy = false;

    /**
     *  allows reinitialization if compiler is not
     *  run from a command-line
     */

    protected static void init()
    {
        command_line = null;
        import_list = new Vector();
        pack_replace = new Hashtable();
        scopes = new Stack();

        out_dir = ".";
        package_prefix = null;

        parse_only = false;
        global_import = false;

        include_state = false;
        generateIR = false;
        generate_skeletons = true;

        generateIncluded = false;
        inhibitionState = false;
        localityContraint = false;
    }

    public static void main( String argv[] )
    {
        boolean result = compile( argv );
    }


    public static boolean compile( String argv[] )
    {
        init();
        Hashtable tmpDefines = new Hashtable();
        Hashtable tmpUnDefines = new Hashtable();
        try
        {
            command_line = argv;
            if( argv.length > 0 )
            {
                int i;
                for( i = 0; i < argv.length; i++ )
                {
                    if( argv[i].equals("-syntax"))
                    {
                        parse_only = true;
                        continue;
                    }
                    if( argv[i].equals("-global_import"))
                    {
                        global_import = true;
                        continue;
                    }
                    if( argv[i].equals("-noskel"))
                    {
                        generate_skeletons = false;
                        continue;
                    }
                    if( argv[i].equals("-nostub"))
                    {
                        generate_stubs = false;
                        continue;
                    }
                    if( argv[i].equals("-sloppy_forward"))
                    {
                        sloppy = true;
                        continue;
                    }
                    if( argv[i].equals("-sloppy_names"))
                    {
                        strict_names = false;
                        continue;
                    }
                    if( argv[i].equals("-d"))
                    {
                        if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                            usage(argv, "-d");
                        out_dir = argv[++i];
                        continue;
                    }
                    if( argv[i].equals("-W"))
                    {
                        if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                            usage(argv, "-W");
                        org.jacorb.idl.Environment.verbosityLevel(Integer.parseInt( argv[++i]));
                        continue;
                    }
                    if( argv[i].startsWith("-D"))
                    {
                        String def = argv[i].substring(2);
                        String val;

                        if( def.indexOf('=') > 0 )
                        {
                            val = def.substring( def.indexOf('=') + 1);
                            def = def.substring( 0, def.indexOf('='));
                        }
                        else
                            val = "1";
                        tmpDefines.put( def, val );
                        continue;
                    }
                    if( argv[i].startsWith("-U"))
                    {
                        tmpUnDefines.put( argv[i].substring(2), "" );
                        continue;
                    }
                    if( argv[i].equals("-p"))
                    {
                        if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                            usage(argv, "-p");
                        package_prefix = argv[++i];
                        continue;
                    }
                    if( argv[i].equals("-i2jpackage"))
                    {
                        if( i+1 == argv.length || argv[i+1].charAt(0)=='-')
                            usage(argv, "-i2jpackage");

                        int split_idx = argv[i+1].indexOf(':');
                        if( split_idx  < 0 )
                            usage(argv, "-i2jpackage");
                        String idlp = argv[i+1].substring(0,split_idx);
                        String jp = argv[i+1].substring(split_idx+1);

                        pack_replace.put( idlp, jp );
                        Environment.output(3,"Replace pack " + idlp + " with " + jp );
                        i++;
                        continue;
                    }
                    if( argv[i].equals("-ir"))
                    {
                        generateIR = true;
                        continue;
                    }
                    if( argv[i].equals("-i"))
                    {
                        if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                            usage(argv, "-i");
                        import_list.addElement( argv[++i]) ;
                        continue;
                    }
                    if( argv[i].startsWith("-I"))
                    {
                        GlobalInputStream.setIncludePath(argv[i].substring(2));
                        continue;
                    }
                    if( argv[i].equals("-h") || argv[i].equals("-help") )
                    {
                        help();
                        System.exit(0);
                    }
                    if( argv[i].equals("-all"))
                    {
                        generateIncluded = true;
                        continue;
                    }
                    if( argv[i].equals("-v") || argv[i].equals("-version"))
                    {
                        version();
                        System.exit(0);
                    }
                    if( argv[i].endsWith(".idl"))
                    {
                        break;
                    }

                    // else:
                    usage(argv, "Unrecognized option");

                }
                for( int j=i; j < argv.length; j++)
                {
                    if( argv[j].endsWith(".idl"))
                    {
                        Environment.output( 4, argv[j] );
                        GlobalInputStream.init();
                        try
                        {
                            GlobalInputStream.setInput( argv[j] );
                        }
                        catch (java.io.IOException io )
                        {
                            System.err.println("Could not find file " + argv[j]);
                            parser.help();
                        }
                                /* reset tables everywhere */
                        lexer.reset();
                        NameTable.init();
                        ConstDecl.init();
                        TypeMap.init();

                                /* define/undefine symbols */
                        for( Enumeration e = tmpDefines.keys(); e.hasMoreElements(); )
                        {
                            String key = (String)e.nextElement();
                            lexer.define( key, (String)tmpDefines.get( key ));
                        }
                        for( Enumeration e = tmpUnDefines.keys(); e.hasMoreElements(); )
                        {
                            lexer.undefine( (String)e.nextElement() );
                        }
                        new parser().parse();
                    }
                    else
                    {
                        System.err.println("Not an IDL file:" + argv[j]);
                    }
                }
            }
        }
        catch( org.jacorb.idl.ParseException e )
        {
            return false;
        }
        catch( Exception e )
        {
            System.err.println( "Error: " + e.getMessage());
            org.jacorb.idl.Environment.output( 2, e );
            usage(argv, e.getMessage());
        }
        return true;
    }

    public static void usage(String [] argv, String msg)
    {
        // debug:
        for( int i = 0; i < argv.length; i++)
            System.out.print( argv[i] + " " );
        System.out.println(" : " + msg);

        System.out.println("Usage: idl [-h|-help][-v|-version][-syntax][-all][-Idir][-Dsymbol[=value]][-U <symbol>][-noskel][-nostub][-ir][-sloppy_names] [-i2jpackage x:y][-d <Output Dir>][-p <package_prefix>][-i <import_package][-W debug_level] <filelist>");
        System.exit(1);
    }

    private static void help()
    {
        System.out.println("\t-syntax\tsyntax check only, no code generation, implies -no_ir");
//ystem.out.println("\t-no_ir\tdo not generate information for the Interface Repository");
        System.out.println("\t-noskel\tdisables generation of POA skeletons");
        System.out.println("\t-nostub\tdisables generation of client stubs");
        System.out.println("\t-Idir\tset include path for idl files");
        System.out.println("\t-sloppy_forward\tallow forward declarations wo. later definitions");
        System.out.println("\t-sloppy_names\tless strict checking of names for backward compatibility");
        System.out.println("\t-Dx\tdefine preprocessor symbol x with value 1");
        System.out.println("\t-Dx=y\tdefine preprocessor symbol x with value y");
        System.out.println("\t-U\tundefine preprocessor symbol");
        System.out.println("\t-p pack\tapply pack as prefix to all names in generated Java code");
        System.out.println("\t\t\tand put code into package <pack>");
        System.out.println("\t-i2jpackage x:a.b.c\t replace IDL package name x by a.b.c in generated Java code (e.g. CORBA:org.omg.CORBA)");
        System.out.println("\t-i <x>\tgenerated Java code will include \"import <x>;\"");
        System.out.println("\t-ir <x>\tgenerate information required by the Interface Repository");
        System.out.println("\t-global_import \tgenerated Java code will include import statements for all global types");
        System.out.println("\t-d dir\troot of directory tree for output");
        System.out.println("\t-W [1..4]\tdebug level");
        System.out.println("\t-all generate code for all IDL files, even included ones");
        System.out.println("\t-v|version \tprint version information");
        System.out.println("\t-h|help \tthese few lines of help");
        System.out.println("\t<filelist>\t");
  }

    private static void version()
    {
        System.out.println("JacORB IDL compiler V" + compiler_version + ",\n   (C) Gerald Brose, FU Berlin, " + yearString + ".");
    }

    /* override error routines */

    public void report_fatal_error( String message, Object info)
        throws ParseException
    {
       done_parsing();
       lexer.emit_error(message);
       System.err.println("Can't recover from previous error(s), giving up.");
       throw new ParseException();
       // System.exit(1);
    }

    public static void fatal_error(String message, str_token p_info)
        throws ParseException
    {
       //done_parsing();
       lexer.emit_error(message, p_info);
       System.err.println("Can't recover from previous error(s), giving up.");
       throw new ParseException();
       // System.exit(1);
    }

    public void report_error(String message, Object info)
    {
       lexer.emit_error(message);
    }

    public static void error(String message, str_token p_info)
    {
       lexer.emit_error(message, p_info);
    }

    public static void error( String message )
    {
       lexer.emit_error( message );
    }

    /* bookkeeping with IDL scopes */

    /** called from the lexer/scanner whenever a scope opening
        symbol is encountered */

    public static void openScope()
    {
        scopes.push(new ScopeData());
    }

    /** called from within the parser whenever parsing a scope
        symbol is complete */

    public static void closeScope(Scope symbol)
    {
            ScopeData data = (ScopeData) scopes.pop();
            symbol.setScopeData( data );
    }

    public static ScopeData currentScopeData()
    {
            return (ScopeData)scopes.peek();
    }


    // an interface inheriting from an forward declared interface
    // needs to wait on an object until the ancestor has been parsed
    // if get_pending returns null, the ancestor was not forward
    // declared and thus has already been parsed

    // forward declared interfaces are put into this list

    public static java.util.Hashtable pending_interfaces = new java.util.Hashtable();

    public static synchronized void set_pending( String name )
    {
         // name will only be marked pending if it has not already been
         // parsed before and if is not already pending

         if( ! ( pending_interfaces.containsKey(name) ||
                 NameTable.parsed_interfaces.containsKey(name)) )
         {
                 pending_interfaces.put(name, new Object());
         }
    }

    public static synchronized void remove_pending( String name )
    {
         Object o = pending_interfaces.remove(name);
         if( o != null)
         {
             synchronized( o )
             {
                  o.notifyAll();
             }
         }
         if( pending_interfaces.size() == 0 )
         {
             // notify the main thread that the parsing phase is complete
             synchronized( pending_interfaces )
             {
                  pending_interfaces.notifyAll();
             }
         }
    }

    public static Object get_pending( String name )
    {
        return pending_interfaces.get(name);
    }

    public static synchronized void decActiveParseThreads()
    {
        Environment.output(3,"decActiveParseThreads");
        activeParseThreads--;
    }

    public static synchronized void incActiveParseThreads()
    {
        Environment.output(3,"incActiveParseThreads");
        activeParseThreads++;
    }

    public static synchronized int activeParseThreads()
    {
        Environment.output(3,"activeParseThreads returns "+activeParseThreads );
        return activeParseThreads;
    }

    public static boolean generateIncluded()
    {
        return generateIncluded;
    }

    public static boolean getInhibitionState()
    {
        return inhibitionState;
    }

    public static void setInhibitionState(boolean flag)
    {
        inhibitionState = flag;
    }

    public static void set_included( boolean i )
    {
        include_state = i;
    }

    public static boolean hasImports()
    {
        return import_list.size() > 0 ;
    }

    static void addGlobalNamesToImport()
    {
        for( Enumeration e = NameTable.getGlobalTypes();
                e.hasMoreElements(); )
        {
                String s = (String) e.nextElement();
                import_list.addElement( s );
                Environment.output(4,"Adding import for global name " + s );
        }
    }


    /**
     * Package replacements as requested
     * by compiler options
     */

    public static String pack_replace(String old)
    {
        String n_str = (String)pack_replace.get(old);
        if( n_str == null )
            return old;
        else
            return n_str;
    }


};

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$actions {




  /** Constructor */
  CUP$actions() { }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.symbol CUP$do_action(
    int                        CUP$act_num,
    java_cup.runtime.lr_parser CUP$parser,
    java.util.Stack            CUP$stack,
    int                        CUP$top)
    throws java.lang.Exception
    {
      /* object for return from actions */
      java_cup.runtime.symbol CUP$result;

      /* select the action based on the action number */
      switch (CUP$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 226: // empty ::= 
            {
              CUP$result = new java_cup.runtime.symbol(/*empty*/4);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 225: // param_type_spec ::= scopename 
            {
              CUP$result = new TypeSpec(/*param_type_spec*/44);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 224: // param_type_spec ::= string_type 
            {
              CUP$result = new TypeSpec(/*param_type_spec*/44);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(StringType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 223: // param_type_spec ::= base_type_spec 
            {
              CUP$result = new TypeSpec(/*param_type_spec*/44);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(BaseType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 222: // string_literal_list ::= string_literal COMMA string_literal_list 
            {
              CUP$result = new java_cup.runtime.symbol(/*string_literal_list*/3);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 221: // string_literal_list ::= string_literal 
            {
              CUP$result = new java_cup.runtime.symbol(/*string_literal_list*/3);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 220: // context_expr ::= empty 
            {
              CUP$result = new java_cup.runtime.symbol(/*context_expr*/2);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 219: // context_expr ::= CONTEXT LPAREN string_literal_list RPAREN 
            {
              CUP$result = new java_cup.runtime.symbol(/*context_expr*/2);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // raises_expr ::= empty 
            {
              CUP$result = new RaisesExpr(/*raises_expr*/84);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // raises_expr ::= RAISES LPAREN scopename_list RPAREN 
            {
              CUP$result = new RaisesExpr(/*raises_expr*/84);
              
                ((RaisesExpr)CUP$result).nameList = (Vector)(/*snl*/(SymbolList)CUP$stack.elementAt(CUP$top-1)).v.clone();
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // param_attribute ::= INOUT 
            {
              CUP$result = new java_cup.runtime.int_token(/*param_attribute*/6);
               ((java_cup.runtime.int_token)CUP$result).int_val = 3; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // param_attribute ::= OUT 
            {
              CUP$result = new java_cup.runtime.int_token(/*param_attribute*/6);
               ((java_cup.runtime.int_token)CUP$result).int_val = 2; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // param_attribute ::= IN 
            {
              CUP$result = new java_cup.runtime.int_token(/*param_attribute*/6);
               ((java_cup.runtime.int_token)CUP$result).int_val = 1; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // param_dcl ::= param_attribute param_type_spec simple_declarator 
            {
              CUP$result = new ParamDecl(/*param_dcl*/83);
              
                ((ParamDecl)CUP$result).paramAttribute = (/*pa*/(java_cup.runtime.int_token)CUP$stack.elementAt(CUP$top-2)).int_val;
                ((ParamDecl)CUP$result).paramTypeSpec = (/*pts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                ((ParamDecl)CUP$result).simple_declarator = (/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0));
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // param_dcls ::= param_dcl 
            {
              CUP$result = new SymbolList(/*param_dcls*/89);
              
                        ((SymbolList)CUP$result).v.insertElementAt((/*pd*/(ParamDecl)CUP$stack.elementAt(CUP$top-0)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // param_dcls ::= param_dcl COMMA param_dcls 
            {
              CUP$result = new SymbolList(/*param_dcls*/89);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*pds*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*pd*/(ParamDecl)CUP$stack.elementAt(CUP$top-2)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // parameter_dcls ::= LPAREN RPAREN 
            {
              CUP$result = new SymbolList(/*parameter_dcls*/91);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // parameter_dcls ::= LPAREN param_dcls RPAREN 
            {
              CUP$result = new SymbolList(/*parameter_dcls*/91);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*pds*/(SymbolList)CUP$stack.elementAt(CUP$top-1)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // void_type_spec ::= VOID 
            {
              CUP$result = new VoidTypeSpec(/*void_type_spec*/71);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // op_type_spec ::= void_type_spec 
            {
              CUP$result = new TypeSpec(/*op_type_spec*/43);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(VoidTypeSpec)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // op_type_spec ::= param_type_spec 
            {
              CUP$result = new TypeSpec(/*op_type_spec*/43);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(TypeSpec)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // op_attribute ::= empty 
            {
              CUP$result = new java_cup.runtime.int_token(/*op_attribute*/5);
               ((java_cup.runtime.int_token)CUP$result).int_val = 0; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // op_attribute ::= ONEWAY 
            {
              CUP$result = new java_cup.runtime.int_token(/*op_attribute*/5);
               ((java_cup.runtime.int_token)CUP$result).int_val = 1; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // op_dcl ::= op_attribute op_type_spec ID parameter_dcls raises_expr context_expr 
            {
              CUP$result = new OpDecl(/*op_dcl*/85);
              
                        ((OpDecl)CUP$result).opAttribute = (/*oa*/(java_cup.runtime.int_token)CUP$stack.elementAt(CUP$top-5)).int_val;
                        ((OpDecl)CUP$result).opTypeSpec = (/*ots*/(TypeSpec)CUP$stack.elementAt(CUP$top-4));
                        ((OpDecl)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));
                        ((OpDecl)CUP$result).paramDecls = (Vector)(/*pds*/(SymbolList)CUP$stack.elementAt(CUP$top-2)).v.clone();
                        ((OpDecl)CUP$result).raisesExpr = (/*re*/(RaisesExpr)CUP$stack.elementAt(CUP$top-1));
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // except_dcl ::= EXCEPTION ID LCBRACE member_list RCBRACE 
            {
              CUP$result = new StructType(/*except_dcl*/52);
              
                        ((StructType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));
                        ((StructType)CUP$result).exc = true;
                        ((StructType)CUP$result).set_memberlist( (/*ml*/(MemberList)CUP$stack.elementAt(CUP$top-1)) );
                        ((StructType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((StructType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // except_dcl ::= EXCEPTION ID LCBRACE RCBRACE 
            {
              CUP$result = new StructType(/*except_dcl*/52);
              
                        ((StructType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)));
                        ((StructType)CUP$result).exc = true;
                        ((StructType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((StructType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // simple_declarator_list ::= simple_declarator COMMA simple_declarator_list 
            {
              CUP$result = new SymbolList(/*simple_declarator_list*/93);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*sdl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-2)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // simple_declarator_list ::= simple_declarator 
            {
              CUP$result = new SymbolList(/*simple_declarator_list*/93);
              
                        ((SymbolList)CUP$result).v.insertElementAt((/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // attr_dcl ::= ATTRIBUTE param_type_spec simple_declarator_list 
            {
              CUP$result = new AttrDecl(/*attr_dcl*/86);
              
                        ((AttrDecl)CUP$result).readOnly = false;
                        ((AttrDecl)CUP$result).param_type_spec = (/*pts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((AttrDecl)CUP$result).declarators = (/*sdl*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // attr_dcl ::= READONLY ATTRIBUTE param_type_spec simple_declarator_list 
            {
              CUP$result = new AttrDecl(/*attr_dcl*/86);
              
                        ((AttrDecl)CUP$result).readOnly = true;
                        ((AttrDecl)CUP$result).param_type_spec = (/*pts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((AttrDecl)CUP$result).declarators = (/*sdl*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // fixed_array_size ::= LSBRACE positive_int_const RSBRACE 
            {
              CUP$result = new FixedArraySize(/*fixed_array_size*/82);
              
                        ((FixedArraySize)CUP$result).pos_int_const = (/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // fixed_array_size_list ::= fixed_array_size fixed_array_size_list 
            {
              CUP$result = new SymbolList(/*fixed_array_size_list*/97);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*fasl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*fas*/(FixedArraySize)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // fixed_array_size_list ::= fixed_array_size 
            {
              CUP$result = new SymbolList(/*fixed_array_size_list*/97);
              
                        ((SymbolList)CUP$result).v.insertElementAt((/*fas*/(FixedArraySize)CUP$stack.elementAt(CUP$top-0)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // array_declarator ::= ID fixed_array_size_list 
            {
              CUP$result = new ArrayDeclarator(/*array_declarator*/81);
              
                        ((ArrayDeclarator)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)));
                        ((ArrayDeclarator)CUP$result).fixed_array_size_list = (/*fasl*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // fixed_point_type ::= FIXED LESSTHAN positive_int_const COMMA positive_int_const GREATERTHAN 
            {
              CUP$result = new FixedPointType(/*fixed_point_type*/74);
              
                ((FixedPointType)CUP$result).digit_expr = (/*digits*/(PosIntConst)CUP$stack.elementAt(CUP$top-3)).const_expr;
                ((FixedPointType)CUP$result).scale_expr = (/*scale*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr;
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // string_type ::= WSTRING 
            {
              CUP$result = new StringType(/*string_type*/72);
               ((StringType)CUP$result).setWide(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // string_type ::= STRING 
            {
              CUP$result = new StringType(/*string_type*/72);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // string_type ::= WSTRING LESSTHAN positive_int_const GREATERTHAN 
            {
              CUP$result = new StringType(/*string_type*/72);
              
                ((StringType)CUP$result).max = (/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr;
                ((StringType)CUP$result).setWide();
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // string_type ::= STRING LESSTHAN positive_int_const GREATERTHAN 
            {
              CUP$result = new StringType(/*string_type*/72);
               ((StringType)CUP$result).max = (/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // sequence_type ::= SEQUENCE LESSTHAN simple_type_spec GREATERTHAN 
            {
              CUP$result = new SequenceType(/*sequence_type*/73);
              
                        ((SequenceType)CUP$result).setTypeSpec( (/*sts*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-1)) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // sequence_type ::= SEQUENCE LESSTHAN simple_type_spec COMMA positive_int_const GREATERTHAN 
            {
              CUP$result = new SequenceType(/*sequence_type*/73);
              
                        ((SequenceType)CUP$result).max = (/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr;
                        ((SequenceType)CUP$result).setTypeSpec( (/*sts*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-3)) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // native_type ::= NATIVE simple_declarator 
            {
              CUP$result = new NativeType(/*native_type*/54);
              
                        ((NativeType)CUP$result).declarator = (/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // enumerator_list ::= ID COMMA enumerator_list 
            {
              CUP$result = new SymbolList(/*enumerator_list*/96);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*el*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)).str_val,0);
                        ((SymbolList)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // enumerator_list ::= ID 
            {
              CUP$result = new SymbolList(/*enumerator_list*/96);
              
                        ((SymbolList)CUP$result).v.insertElementAt((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val,0);
                        ((SymbolList)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // enum_type ::= ENUM ID LCBRACE enumerator_list RCBRACE 
            {
              CUP$result = new EnumType(/*enum_type*/50);
              
                        ((EnumType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));
                        ((EnumType)CUP$result).enumlist = (/*el*/(SymbolList)CUP$stack.elementAt(CUP$top-1));
                        ((EnumType)CUP$result).set_included( parser.include_state );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // element_spec ::= type_spec declarator 
            {
              CUP$result = new ElementSpec(/*element_spec*/57);
              
                        ((ElementSpec)CUP$result).t.type_spec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((ElementSpec)CUP$result).d = (/*dc*/(Declarator)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // case_label_list ::= DEFAULT COLON case_label_list 
            {
              CUP$result = new SymbolList(/*case_label_list*/88);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*cll*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.addElement(null);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // case_label_list ::= CASE const_expr COLON case_label_list 
            {
              CUP$result = new SymbolList(/*case_label_list*/88);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*cll*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.addElement((/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-2)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // case_label_list ::= DEFAULT COLON 
            {
              CUP$result = new SymbolList(/*case_label_list*/88);
               ((SymbolList)CUP$result).v.addElement( null ); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // case_label_list ::= CASE const_expr COLON 
            {
              CUP$result = new SymbolList(/*case_label_list*/88);
               ((SymbolList)CUP$result).v.addElement((/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // case ::= case_label_list element_spec SEMI 
            {
              CUP$result = new Case(/*case*/56);
              
                        ((Case)CUP$result).element_spec = (/*es*/(ElementSpec)CUP$stack.elementAt(CUP$top-1));
                        ((Case)CUP$result).case_label_list = (/*c*/(SymbolList)CUP$stack.elementAt(CUP$top-2));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // switch_body ::= case switch_body 
            {
              CUP$result = new SwitchBody(/*switch_body*/55);
              
                ((SwitchBody)CUP$result).caseListVector = (Vector)(/*sb*/(SwitchBody)CUP$stack.elementAt(CUP$top-0)).caseListVector.clone();
                ((SwitchBody)CUP$result).caseListVector.addElement( (/*c*/(Case)CUP$stack.elementAt(CUP$top-1)) );
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // switch_body ::= case 
            {
              CUP$result = new SwitchBody(/*switch_body*/55);
              
                ((SwitchBody)CUP$result).caseListVector.addElement((/*c*/(Case)CUP$stack.elementAt(CUP$top-0)));
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // switch_type_spec ::= scopename 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // switch_type_spec ::= enum_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).set_constr((/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // switch_type_spec ::= bool_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).type_spec = (/*b*/(BooleanType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // switch_type_spec ::= char_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).type_spec = (/*c*/(CharType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // switch_type_spec ::= int_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).type_spec = (/*i*/(IntType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // union_type ::= UNION ID 
            {
              CUP$result = new UnionType(/*union_type*/53);
              
                        ((UnionType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                        parser.closeScope( (Scope)((UnionType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // union_type ::= UNION ID SWITCH LPAREN switch_type_spec RPAREN LCBRACE switch_body RCBRACE 
            {
              CUP$result = new UnionType(/*union_type*/53);
              
                        ((UnionType)CUP$result).setSwitchType( (/*s*/(TypeSpec)CUP$stack.elementAt(CUP$top-4)) );
                        ((UnionType)CUP$result).setSwitchBody( (/*sb*/(SwitchBody)CUP$stack.elementAt(CUP$top-1)) );
                        ((UnionType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-7)));
                        ((UnionType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((UnionType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // member ::= type_spec declarators SEMI 
            {
              CUP$result = new Member(/*member*/78);
              
                        ((Member)CUP$result).type_spec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-2));
                        ((Member)CUP$result).declarators = (/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-1));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // member_list ::= member member_list 
            {
              CUP$result = new MemberList(/*member_list*/87);
              
                        ((MemberList)CUP$result).v = (Vector)(/*ml*/(MemberList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((MemberList)CUP$result).v.insertElementAt((/*m*/(Member)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // member_list ::= member 
            {
              CUP$result = new MemberList(/*member_list*/87);
              
                        ((MemberList)CUP$result).v.insertElementAt((/*m*/(Member)CUP$stack.elementAt(CUP$top-0)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // struct_type ::= STRUCT ID 
            {
              CUP$result = new StructType(/*struct_type*/51);
              
                        ((StructType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                        parser.closeScope( (Scope)((StructType)CUP$result) );
               
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // struct_type ::= STRUCT ID LCBRACE member_list RCBRACE 
            {
              CUP$result = new StructType(/*struct_type*/51);
              
                        ((StructType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));
                        ((StructType)CUP$result).exc = false;
                        ((StructType)CUP$result).set_memberlist( (/*ml*/(MemberList)CUP$stack.elementAt(CUP$top-1)) );
                        ((StructType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((StructType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // any_type ::= ANY 
            {
              CUP$result = new AnyType(/*any_type*/70);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // octet_type ::= OCTET 
            {
              CUP$result = new OctetType(/*octet_type*/69);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // bool_type ::= BOOLEAN 
            {
              CUP$result = new BooleanType(/*bool_type*/68);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // char_type ::= WCHAR 
            {
              CUP$result = new CharType(/*char_type*/67);
               ((CharType)CUP$result).setWide(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // char_type ::= CHAR 
            {
              CUP$result = new CharType(/*char_type*/67);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // long_long_type ::= LONG LONG 
            {
              CUP$result = new LongLongType(/*long_long_type*/66);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // long_type ::= LONG 
            {
              CUP$result = new LongType(/*long_type*/65);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // short_type ::= SHORT 
            {
              CUP$result = new ShortType(/*short_type*/64);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // int_type ::= UNSIGNED short_type 
            {
              CUP$result = new IntType(/*int_type*/59);
              
                        ((IntType)CUP$result).type_spec = (/*s*/(ShortType)CUP$stack.elementAt(CUP$top-0));
                        ((IntType)CUP$result).setUnsigned();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // int_type ::= short_type 
            {
              CUP$result = new IntType(/*int_type*/59);
              
                        ((IntType)CUP$result).type_spec = (/*s*/(ShortType)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // int_type ::= UNSIGNED long_long_type 
            {
              CUP$result = new IntType(/*int_type*/59);
              
                        ((IntType)CUP$result).type_spec = (/*l*/(LongLongType)CUP$stack.elementAt(CUP$top-0));
                        ((IntType)CUP$result).setUnsigned();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // int_type ::= UNSIGNED long_type 
            {
              CUP$result = new IntType(/*int_type*/59);
              
                        ((IntType)CUP$result).type_spec = (/*l*/(LongType)CUP$stack.elementAt(CUP$top-0));
                        ((IntType)CUP$result).setUnsigned();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // int_type ::= long_long_type 
            {
              CUP$result = new IntType(/*int_type*/59);
              
                        ((IntType)CUP$result).type_spec = (/*ll*/(LongLongType)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // int_type ::= long_type 
            {
              CUP$result = new IntType(/*int_type*/59);
              
                        ((IntType)CUP$result).type_spec = (/*l*/(LongType)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // double_type ::= DOUBLE 
            {
              CUP$result = new DoubleType(/*double_type*/63);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // fixed_pt_const_type ::= FIXED 
            {
              CUP$result = new FixedPointConstType(/*fixed_pt_const_type*/62);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // float_type ::= FLOAT 
            {
              CUP$result = new FloatType(/*float_type*/61);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // float_pt_type ::= double_type 
            {
              CUP$result = new FloatPtType(/*float_pt_type*/60);
              ((FloatPtType)CUP$result).type_spec = (/*d*/(DoubleType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // float_pt_type ::= float_type 
            {
              CUP$result = new FloatPtType(/*float_pt_type*/60);
              ((FloatPtType)CUP$result).type_spec = (/*f*/(FloatType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // simple_declarator ::= ID 
            {
              CUP$result = new SimpleDeclarator(/*simple_declarator*/80);
              
                        ((SimpleDeclarator)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // declarator ::= array_declarator 
            {
              CUP$result = new Declarator(/*declarator*/79);
               ((Declarator)CUP$result).d = (/*s*/(ArrayDeclarator)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // declarator ::= simple_declarator 
            {
              CUP$result = new Declarator(/*declarator*/79);
               ((Declarator)CUP$result).d = (/*s*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // declarators ::= declarator 
            {
              CUP$result = new SymbolList(/*declarators*/94);
              
                        ((SymbolList)CUP$result).v.insertElementAt((/*d*/(Declarator)CUP$stack.elementAt(CUP$top-0)),0);
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // declarators ::= declarator COMMA declarators 
            {
              CUP$result = new SymbolList(/*declarators*/94);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*d*/(Declarator)CUP$stack.elementAt(CUP$top-2)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // constr_type_spec ::= enum_type 
            {
              CUP$result = new ConstrTypeSpec(/*constr_type_spec*/49);
              
                        ((ConstrTypeSpec)CUP$result).c_type_spec = (/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0));
                        ((ConstrTypeSpec)CUP$result).set_token((/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // constr_type_spec ::= union_type 
            {
              CUP$result = new ConstrTypeSpec(/*constr_type_spec*/49);
              
                        ((ConstrTypeSpec)CUP$result).c_type_spec = (/*u*/(UnionType)CUP$stack.elementAt(CUP$top-0));
                        ((ConstrTypeSpec)CUP$result).set_token((/*u*/(UnionType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // constr_type_spec ::= struct_type 
            {
              CUP$result = new ConstrTypeSpec(/*constr_type_spec*/49);
              
                        ((ConstrTypeSpec)CUP$result).c_type_spec = (/*s*/(StructType)CUP$stack.elementAt(CUP$top-0));
                        ((ConstrTypeSpec)CUP$result).set_token((/*s*/(StructType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // template_type_spec ::= fixed_point_type 
            {
              CUP$result = new TemplateTypeSpec(/*template_type_spec*/48);
              
                        ((TemplateTypeSpec)CUP$result).type_spec = (/*f*/(FixedPointType)CUP$stack.elementAt(CUP$top-0));
                        ((TemplateTypeSpec)CUP$result).set_token((/*f*/(FixedPointType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // template_type_spec ::= string_type 
            {
              CUP$result = new TemplateTypeSpec(/*template_type_spec*/48);
              
                        ((TemplateTypeSpec)CUP$result).type_spec = (/*s*/(StringType)CUP$stack.elementAt(CUP$top-0));
                        ((TemplateTypeSpec)CUP$result).set_token((/*s*/(StringType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // template_type_spec ::= sequence_type 
            {
              CUP$result = new TemplateTypeSpec(/*template_type_spec*/48);
              
                        ((TemplateTypeSpec)CUP$result).type_spec = (/*s*/(SequenceType)CUP$stack.elementAt(CUP$top-0));
                        ((TemplateTypeSpec)CUP$result).set_token((/*s*/(SequenceType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // base_type_spec ::= VALUEBASE 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // base_type_spec ::= any_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(AnyType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // base_type_spec ::= octet_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(OctetType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // base_type_spec ::= bool_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(BooleanType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // base_type_spec ::= char_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(CharType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // base_type_spec ::= int_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
              
                        ((BaseType)CUP$result).type_spec = (/*s*/(IntType)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // base_type_spec ::= float_pt_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(FloatPtType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // simple_type_spec ::= scopename 
            {
              CUP$result = new SimpleTypeSpec(/*simple_type_spec*/47);
              
                        ((SimpleTypeSpec)CUP$result).type_spec = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0));
                        ((SimpleTypeSpec)CUP$result).set_token((/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // simple_type_spec ::= template_type_spec 
            {
              CUP$result = new SimpleTypeSpec(/*simple_type_spec*/47);
              
                        ((SimpleTypeSpec)CUP$result).type_spec = (/*s*/(TemplateTypeSpec)CUP$stack.elementAt(CUP$top-0));
                        ((SimpleTypeSpec)CUP$result).set_token((/*s*/(TemplateTypeSpec)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // simple_type_spec ::= base_type_spec 
            {
              CUP$result = new SimpleTypeSpec(/*simple_type_spec*/47);
              
                        ((SimpleTypeSpec)CUP$result).type_spec = (/*s*/(BaseType)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // type_spec ::= constr_type_spec 
            {
              CUP$result = new TypeSpec(/*type_spec*/42);
              
                        ((TypeSpec)CUP$result).type_spec = (/*s*/(ConstrTypeSpec)CUP$stack.elementAt(CUP$top-0));
                        ((TypeSpec)CUP$result).set_token((/*s*/(ConstrTypeSpec)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // type_spec ::= simple_type_spec 
            {
              CUP$result = new TypeSpec(/*type_spec*/42);
              
                        ((TypeSpec)CUP$result).type_spec = (/*s*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-0));
                        ((TypeSpec)CUP$result).set_token((/*s*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // type_declarator ::= type_spec declarators 
            {
              CUP$result = new TypeDeclarator(/*type_declarator*/41);
              
                        ((TypeDeclarator)CUP$result).type_spec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((TypeDeclarator)CUP$result).declarators = (/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // type_def ::= TYPEDEF type_declarator 
            {
              CUP$result = new TypeDef(/*type_def*/46);
              
                ((TypeDef)CUP$result).type_declarator = (/*t*/(TypeDeclarator)CUP$stack.elementAt(CUP$top-0));
                ((TypeDef)CUP$result).set_included( parser.include_state );
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // type_dcl ::= native_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*n*/(NativeType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // type_dcl ::= enum_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // type_dcl ::= union_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*u*/(UnionType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // type_dcl ::= struct_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*s*/(StructType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // type_dcl ::= type_def 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*t*/(TypeDef)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // positive_int_const ::= const_expr 
            {
              CUP$result = new PosIntConst(/*positive_int_const*/31);
               ((PosIntConst)CUP$result).const_expr = (/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // string_literal ::= LDBLQUOTE DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/76);
              
                        ((Literal)CUP$result).string = "\"\"";
                        ((Literal)CUP$result).wide = true;
                  
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // string_literal ::= LDBLQUOTE ID DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/76);
              
                        ((Literal)CUP$result).string = "\"" + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)).str_val + "\"";
                        ((Literal)CUP$result).wide = true;
                  
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // string_literal ::= DBLQUOTE DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/76);
               ((Literal)CUP$result).string = "\"\""; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // string_literal ::= DBLQUOTE ID DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/76);
               ((Literal)CUP$result).string = "\"" + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)).str_val + "\""; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // literal ::= FALSE 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = "false";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // literal ::= TRUE 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = "true";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // literal ::= FLOAT_NUMBER 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = "" + (/*n*/(java_cup.runtime.float_token)CUP$stack.elementAt(CUP$top-0)).float_val ;
                        ((Literal)CUP$result).token = (/*n*/(java_cup.runtime.float_token)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // literal ::= FIXED_NUMBER 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = "" + (/*f*/(fixed_token)CUP$stack.elementAt(CUP$top-0)).fixed_val;
                        ((Literal)CUP$result).token = (/*f*/(fixed_token)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // literal ::= string_literal 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = (/*s*/(Literal)CUP$stack.elementAt(CUP$top-0)).string;
                        ((Literal)CUP$result).wide = (/*s*/(Literal)CUP$stack.elementAt(CUP$top-0)).wide;
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // literal ::= QUOTE CH QUOTE 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = "\'" + (/*c*/(java_cup.runtime.char_token)CUP$stack.elementAt(CUP$top-1)).char_val + "\'";
                        ((Literal)CUP$result).token = (/*c*/(java_cup.runtime.char_token)CUP$stack.elementAt(CUP$top-1));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // literal ::= LONG_NUMBER 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = "" + (/*l*/(java_cup.runtime.long_token)CUP$stack.elementAt(CUP$top-0)).long_val;
                        ((Literal)CUP$result).token = (/*l*/(java_cup.runtime.long_token)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // literal ::= NUMBER 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = "" + (/*n*/(java_cup.runtime.int_token)CUP$stack.elementAt(CUP$top-0)).int_val;
                        ((Literal)CUP$result).token = (/*n*/(java_cup.runtime.int_token)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // primary_expr ::= LPAREN const_expr RPAREN 
            {
              CUP$result = new PrimaryExpr(/*primary_expr*/39);
               ((PrimaryExpr)CUP$result).symbol = (/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-1)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // primary_expr ::= literal 
            {
              CUP$result = new PrimaryExpr(/*primary_expr*/39);
               ((PrimaryExpr)CUP$result).symbol = (/*l*/(Literal)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // primary_expr ::= scopename 
            {
              CUP$result = new PrimaryExpr(/*primary_expr*/39);
               ((PrimaryExpr)CUP$result).symbol = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // unary_op ::= TILDE 
            {
              CUP$result = new java_cup.runtime.str_token(/*unary_op*/7);
               ((java_cup.runtime.str_token)CUP$result).str_val = "~"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // unary_op ::= PLUS 
            {
              CUP$result = new java_cup.runtime.str_token(/*unary_op*/7);
               ((java_cup.runtime.str_token)CUP$result).str_val = "+"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // unary_op ::= MINUS 
            {
              CUP$result = new java_cup.runtime.str_token(/*unary_op*/7);
               ((java_cup.runtime.str_token)CUP$result).str_val = "-"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // unary_expr ::= primary_expr 
            {
              CUP$result = new UnaryExpr(/*unary_expr*/38);
               ((UnaryExpr)CUP$result).primary_expr = (/*p*/(PrimaryExpr)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // unary_expr ::= unary_op primary_expr 
            {
              CUP$result = new UnaryExpr(/*unary_expr*/38);
              
                        ((UnaryExpr)CUP$result).primary_expr = (/*p*/(PrimaryExpr)CUP$stack.elementAt(CUP$top-0));
                        ((UnaryExpr)CUP$result).unary_op = (/*u*/(java_cup.runtime.str_token)CUP$stack.elementAt(CUP$top-1)).str_val;
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // mult_expr ::= mult_expr PERCENT unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/37);
              
                        ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0));
                        ((MultExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-2));
                        ((MultExpr)CUP$result).operator = "%";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // mult_expr ::= mult_expr SLASH unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/37);
              
                        ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0));
                        ((MultExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-2));
                        ((MultExpr)CUP$result).operator = "/";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // mult_expr ::= mult_expr STAR unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/37);
              
                        ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0));
                        ((MultExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-2));
                        ((MultExpr)CUP$result).operator = "*";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // mult_expr ::= unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/37);
               ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // add_expr ::= add_expr MINUS mult_expr 
            {
              CUP$result = new AddExpr(/*add_expr*/36);
              
                        ((AddExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-2));
                        ((AddExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-0));
                        ((AddExpr)CUP$result).operator = "-";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // add_expr ::= add_expr PLUS mult_expr 
            {
              CUP$result = new AddExpr(/*add_expr*/36);
              
                        ((AddExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-2));
                        ((AddExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-0));
                        ((AddExpr)CUP$result).operator = "+";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // add_expr ::= mult_expr 
            {
              CUP$result = new AddExpr(/*add_expr*/36);
              
                        ((AddExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // shift_expr ::= shift_expr RSHIFT add_expr 
            {
              CUP$result = new ShiftExpr(/*shift_expr*/35);
              
                        ((ShiftExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-0));
                        ((ShiftExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-2));
                        ((ShiftExpr)CUP$result).operator = ">>";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // shift_expr ::= shift_expr LSHIFT add_expr 
            {
              CUP$result = new ShiftExpr(/*shift_expr*/35);
              
                        ((ShiftExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-0));
                        ((ShiftExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-2));
                        ((ShiftExpr)CUP$result).operator = "<<";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // shift_expr ::= add_expr 
            {
              CUP$result = new ShiftExpr(/*shift_expr*/35);
              
                        ((ShiftExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // and_expr ::= and_expr AMPERSAND shift_expr 
            {
              CUP$result = new AndExpr(/*and_expr*/34);
              
                        ((AndExpr)CUP$result).and_expr = (/*a*/(AndExpr)CUP$stack.elementAt(CUP$top-2));
                        ((AndExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // and_expr ::= shift_expr 
            {
              CUP$result = new AndExpr(/*and_expr*/34);
              
                        ((AndExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // xor_expr ::= xor_expr CIRCUM and_expr 
            {
              CUP$result = new XorExpr(/*xor_expr*/33);
              
                        ((XorExpr)CUP$result).and_expr = (/*a*/(AndExpr)CUP$stack.elementAt(CUP$top-0));
                        ((XorExpr)CUP$result).xor_expr = (/*x*/(XorExpr)CUP$stack.elementAt(CUP$top-2));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // xor_expr ::= and_expr 
            {
              CUP$result = new XorExpr(/*xor_expr*/33);
              
                        ((XorExpr)CUP$result).and_expr = (/*a*/(AndExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // or_expr ::= or_expr BAR xor_expr 
            {
              CUP$result = new OrExpr(/*or_expr*/32);
              
                        ((OrExpr)CUP$result).or_expr = (/*o*/(OrExpr)CUP$stack.elementAt(CUP$top-2));
                        ((OrExpr)CUP$result).xor_expr = (/*x*/(XorExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // or_expr ::= xor_expr 
            {
              CUP$result = new OrExpr(/*or_expr*/32);
              
                        ((OrExpr)CUP$result).xor_expr = (/*x*/(XorExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // const_expr ::= or_expr 
            {
              CUP$result = new ConstExpr(/*const_expr*/30);
              
                        ((ConstExpr)CUP$result).or_expr = (/*o*/(OrExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // const_type ::= scopename 
            {
              CUP$result = new ConstType(/*const_type*/29);
              
                        ((ConstType)CUP$result).symbol = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0));
                        ((ConstType)CUP$result).set_token((/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // const_type ::= octet_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(OctetType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // const_type ::= string_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(StringType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // const_type ::= fixed_pt_const_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(FixedPointConstType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // const_type ::= float_pt_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(FloatPtType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // const_type ::= bool_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(BooleanType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // const_type ::= char_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(CharType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // const_type ::= int_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(IntType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // const_dcl ::= CONST const_type ID EQUALS const_expr 
            {
              CUP$result = new ConstDecl(/*const_dcl*/28);
              
                        ((ConstDecl)CUP$result).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)).str_val);
                        ((ConstDecl)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)));
                        ((ConstDecl)CUP$result).const_expr = (/*ce*/(ConstExpr)CUP$stack.elementAt(CUP$top-0));
                        ((ConstDecl)CUP$result).const_type = (ConstType)(/*ct*/(ConstType)CUP$stack.elementAt(CUP$top-3));
                        ((ConstDecl)CUP$result).set_included( parser.include_state );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // init_param_decl ::= IN param_type_spec simple_declarator 
            {
              CUP$result = new InitParamDecl(/*init_param_decl*/27);
              
                        ((InitParamDecl)CUP$result).paramTypeSpec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((InitParamDecl)CUP$result).simple_declarator = (/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0));
                  
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // init_param_decls ::= init_param_decl COMMA init_param_decls 
            {
              CUP$result = new SymbolList(/*init_param_decls*/90);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*ipdcls*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt( (/*ip*/(InitParamDecl)CUP$stack.elementAt(CUP$top-2)), 0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // init_param_decls ::= init_param_decl 
            {
              CUP$result = new SymbolList(/*init_param_decls*/90);
              
                        ((SymbolList)CUP$result).v.insertElementAt( (/*ip*/(InitParamDecl)CUP$stack.elementAt(CUP$top-0)), 0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // init_dcl ::= FACTORY ID LPAREN RPAREN SEMI 
            {
              CUP$result = new InitDecl(/*init_dcl*/26);
              
                        ((InitDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)).str_val;
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // init_dcl ::= FACTORY ID LPAREN init_param_decls RPAREN SEMI 
            {
              CUP$result = new InitDecl(/*init_dcl*/26);
              
                        ((InitDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val;
                        ((InitDecl)CUP$result).paramDecls = (Vector)(/*ipd*/(SymbolList)CUP$stack.elementAt(CUP$top-2)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // state_member ::= PRIVATE type_spec declarators SEMI 
            {
              CUP$result = new StateMember(/*state_member*/25);
              
                           ((StateMember)CUP$result).isPublic    = false;
                           ((StateMember)CUP$result).type_spec   = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-2));
                           ((StateMember)CUP$result).declarators = (/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-1));
                  
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // state_member ::= PUBLIC type_spec declarators SEMI 
            {
              CUP$result = new StateMember(/*state_member*/25);
              
                           ((StateMember)CUP$result).isPublic    = true;
                           ((StateMember)CUP$result).type_spec   = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-2));
                           ((StateMember)CUP$result).declarators = (/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-1));
                  
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // value_element ::= init_dcl 
            {
              CUP$result = new Definition(/*value_element*/24);
              
                        ((Definition)CUP$result).set_declaration ((/*id*/(InitDecl)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // value_element ::= state_member 
            {
              CUP$result = new Definition(/*value_element*/24);
              
                        ((Definition)CUP$result).set_declaration ((/*sm*/(StateMember)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // value_element ::= export 
            {
              CUP$result = new Definition(/*value_element*/24);
              
                        ((Definition)CUP$result).set_declaration ((/*e*/(Definition)CUP$stack.elementAt(CUP$top-0)).get_declaration());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // value_elements ::= empty 
            {
              CUP$result = new Definitions(/*value_elements*/23);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // value_elements ::= value_element value_elements 
            {
              CUP$result = new Definitions(/*value_elements*/23);
              
                        ((Definitions)CUP$result).v = (Vector)(/*es*/(Definitions)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((Definitions)CUP$result).v.insertElementAt((/*e*/(Definition)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // truncatable ::= TRUNCATABLE 
            {
              CUP$result = new Truncatable(/*truncatable*/16);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // value_inheritance_spec ::= empty 
            {
              CUP$result = new ValueInheritanceSpec(/*value_inheritance_spec*/22);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // value_inheritance_spec ::= COLON scopename_list SUPPORTS scopename_list 
            {
              CUP$result = new ValueInheritanceSpec(/*value_inheritance_spec*/22);
              
                        ((ValueInheritanceSpec)CUP$result).v = (Vector)(/*vn*/(SymbolList)CUP$stack.elementAt(CUP$top-2)).v.clone();
                        ((ValueInheritanceSpec)CUP$result).supports = (Vector)(/*interface_names*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // value_inheritance_spec ::= COLON truncatable scopename_list SUPPORTS scopename_list 
            {
              CUP$result = new ValueInheritanceSpec(/*value_inheritance_spec*/22);
              
                        ((ValueInheritanceSpec)CUP$result).truncatable = (/*t*/(Truncatable)CUP$stack.elementAt(CUP$top-3));
                        ((ValueInheritanceSpec)CUP$result).truncatable.scopedName = (ScopedName)(/*vn*/(SymbolList)CUP$stack.elementAt(CUP$top-2)).v.remove(0);
                        ((ValueInheritanceSpec)CUP$result).v = (Vector)(/*vn*/(SymbolList)CUP$stack.elementAt(CUP$top-2)).v.clone();
                        ((ValueInheritanceSpec)CUP$result).supports = (Vector)(/*interface_names*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // value_inheritance_spec ::= SUPPORTS scopename_list 
            {
              CUP$result = new ValueInheritanceSpec(/*value_inheritance_spec*/22);
              
                        ((ValueInheritanceSpec)CUP$result).supports = (Vector)(/*interface_names*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // value_inheritance_spec ::= COLON scopename_list 
            {
              CUP$result = new ValueInheritanceSpec(/*value_inheritance_spec*/22);
              
                        ((ValueInheritanceSpec)CUP$result).v = (Vector)(/*vn*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // value_inheritance_spec ::= COLON truncatable scopename_list 
            {
              CUP$result = new ValueInheritanceSpec(/*value_inheritance_spec*/22);
              
                        ((ValueInheritanceSpec)CUP$result).truncatable = (/*t*/(Truncatable)CUP$stack.elementAt(CUP$top-1));
                        ((ValueInheritanceSpec)CUP$result).truncatable.scopedName = (ScopedName)(/*vn*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.remove(0);
                        ((ValueInheritanceSpec)CUP$result).v = (Vector)(/*vn*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // value_dcl ::= VALUETYPE ID value_inheritance_spec LCBRACE value_elements RCBRACE 
            {
              CUP$result = new ValueDecl(/*value_dcl*/19);
              
                        ((ValueDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val;
                        ((ValueDecl)CUP$result).set_token ((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                        ((ValueDecl)CUP$result).setInheritanceSpec ((/*is*/(ValueInheritanceSpec)CUP$stack.elementAt(CUP$top-3)));
                        ((ValueDecl)CUP$result).setValueElements ((/*ve*/(Definitions)CUP$stack.elementAt(CUP$top-1)));
                        ((ValueDecl)CUP$result).isCustomMarshalled (false);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // value_dcl ::= VALUETYPE ID 
            {
              CUP$result = new ValueDecl(/*value_dcl*/19);
              
                        ((ValueDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val;
                        ((ValueDecl)CUP$result).set_token ((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                        ((ValueDecl)CUP$result).isCustomMarshalled (false);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // value_dcl ::= CUSTOM VALUETYPE ID value_inheritance_spec LCBRACE value_elements RCBRACE 
            {
              CUP$result = new ValueDecl(/*value_dcl*/19);
              
                        ((ValueDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val;
                        ((ValueDecl)CUP$result).set_token ((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                        ((ValueDecl)CUP$result).setInheritanceSpec ((/*is*/(ValueInheritanceSpec)CUP$stack.elementAt(CUP$top-3)));
                        ((ValueDecl)CUP$result).setValueElements ((/*ve*/(Definitions)CUP$stack.elementAt(CUP$top-1)));
                        ((ValueDecl)CUP$result).isCustomMarshalled (true);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // value_body ::= empty 
            {
              CUP$result = new ValueBody(/*value_body*/21);
               ((ValueBody)CUP$result).commit(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // value_body ::= export value_body 
            {
              CUP$result = new ValueBody(/*value_body*/21);
              
                        ((ValueBody)CUP$result).v = (Vector)(/*vb*/(ValueBody)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((ValueBody)CUP$result).v.insertElementAt((/*e*/(Definition)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // value_abs_dcl ::= ABSTRACT VALUETYPE ID 
            {
              CUP$result = new ValueAbsDecl(/*value_abs_dcl*/20);
              
                        ((ValueAbsDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val;
                        ((ValueAbsDecl)CUP$result).set_token ((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // value_abs_dcl ::= ABSTRACT VALUETYPE ID value_inheritance_spec LCBRACE value_body RCBRACE 
            {
              CUP$result = new ValueAbsDecl(/*value_abs_dcl*/20);
              
                        ((ValueAbsDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val;
                        ((ValueAbsDecl)CUP$result).setInheritanceSpec( (/*is*/(ValueInheritanceSpec)CUP$stack.elementAt(CUP$top-3)) );
                        ((ValueAbsDecl)CUP$result).body = (/*b*/(ValueBody)CUP$stack.elementAt(CUP$top-1));
                        (/*b*/(ValueBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
                        (/*b*/(ValueBody)CUP$stack.elementAt(CUP$top-1)).myAbsValue = ((ValueAbsDecl)CUP$result);
                        (/*b*/(ValueBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((ValueAbsDecl)CUP$result));
                        ((ValueAbsDecl)CUP$result).set_token ((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // value_box_dcl ::= VALUETYPE ID type_spec 
            {
              CUP$result = new ValueBoxDecl(/*value_box_dcl*/18);
              
                        ((ValueBoxDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)).str_val;
                        ((ValueBoxDecl)CUP$result).typeSpec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // value ::= value_box_dcl 
            {
              CUP$result = new Value(/*value*/17);
              
                        ((Value)CUP$result).setValue ((/*vbx*/(ValueBoxDecl)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // value ::= value_abs_dcl 
            {
              CUP$result = new Value(/*value*/17);
              
                        ((Value)CUP$result).setValue ((/*vad*/(ValueAbsDecl)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // value ::= value_dcl 
            {
              CUP$result = new Value(/*value*/17);
              
                        ((Value)CUP$result).setValue ((/*vd*/(ValueDecl)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // scopename ::= OBJECT 
            {
              CUP$result = new ScopedName(/*scopename*/15);
              
                        ((ScopedName)CUP$result).typeName = "org.omg.CORBA.Object";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // scopename ::= scopename DBLCOLON ID 
            {
              CUP$result = new ScopedName(/*scopename*/15);
              
                        ((ScopedName)CUP$result).setId( (/*sn*/(ScopedName)CUP$stack.elementAt(CUP$top-2)).typeName+ "." + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val );
                        ((ScopedName)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // scopename ::= DBLCOLON ID 
            {
              CUP$result = new ScopedName(/*scopename*/15);
              
                        ((ScopedName)CUP$result).setId( "." + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val);
                        ((ScopedName)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // scopename ::= ID 
            {
              CUP$result = new ScopedName(/*scopename*/15);
              
                        ((ScopedName)CUP$result).setId( (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val );
                        ((ScopedName)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // scopename_list ::= scopename 
            {
              CUP$result = new SymbolList(/*scopename_list*/92);
               ((SymbolList)CUP$result).v.insertElementAt((/*sn*/(ScopedName)CUP$stack.elementAt(CUP$top-0)),0); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // scopename_list ::= scopename COMMA scopename_list 
            {
              CUP$result = new SymbolList(/*scopename_list*/92);
              
                ((SymbolList)CUP$result).v = (Vector)(/*snl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                ((SymbolList)CUP$result).v.insertElementAt((/*sn*/(ScopedName)CUP$stack.elementAt(CUP$top-2)),0);
            
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // inheritance_spec ::= empty 
            {
              CUP$result = new SymbolList(/*inheritance_spec*/95);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // inheritance_spec ::= COLON scopename_list 
            {
              CUP$result = new SymbolList(/*inheritance_spec*/95);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*sl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // export ::= op_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/14);
               ((Definition)CUP$result).set_declaration((/*o*/(OpDecl)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // export ::= attr_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/14);
               ((Definition)CUP$result).set_declaration((/*a*/(AttrDecl)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // export ::= except_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/14);
               ((Definition)CUP$result).set_declaration((/*e*/(StructType)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // export ::= const_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/14);
               ((Definition)CUP$result).set_declaration((/*c*/(ConstDecl)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // export ::= type_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/14);
               ((Definition)CUP$result).set_declaration((/*t*/(TypeDeclaration)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // interface_body ::= empty 
            {
              CUP$result = new InterfaceBody(/*interface_body*/13);
               ((InterfaceBody)CUP$result).commit(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // interface_body ::= export interface_body 
            {
              CUP$result = new InterfaceBody(/*interface_body*/13);
              
                        ((InterfaceBody)CUP$result).v = (Vector)(/*i*/(InterfaceBody)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((InterfaceBody)CUP$result).v.insertElementAt((/*e*/(Definition)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // interface ::= PSEUDO INTERFACE ID 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_pseudo();
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                // ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // interface ::= LOCAL INTERFACE ID 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                ((Interface)CUP$result).set_abstract();
                ((Interface)CUP$result).set_locality( true );
                parser.closeScope( (Scope)((Interface)CUP$result) );
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // interface ::= ABSTRACT INTERFACE ID 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                ((Interface)CUP$result).set_abstract();
                // ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // interface ::= INTERFACE ID 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                // ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // interface ::= PSEUDO INTERFACE ID inheritance_spec LCBRACE interface_body RCBRACE 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_pseudo();
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                ((Interface)CUP$result).inheritanceSpec = (/*is*/(SymbolList)CUP$stack.elementAt(CUP$top-3));
                ((Interface)CUP$result).body = (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1));
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_pseudo();
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
//              (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).my_interface = ((Interface)CUP$result);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Interface)CUP$result));
                ((Interface)CUP$result).set_included( parser.include_state );
                // ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // interface ::= LOCAL INTERFACE ID inheritance_spec LCBRACE interface_body RCBRACE 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                ((Interface)CUP$result).inheritanceSpec = (/*is*/(SymbolList)CUP$stack.elementAt(CUP$top-3));
                ((Interface)CUP$result).body = (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)) ;
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).my_interface = ((Interface)CUP$result);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Interface)CUP$result));
                ((Interface)CUP$result).set_included( parser.include_state );
                ((Interface)CUP$result).set_locality( true );
                parser.closeScope( (Scope)((Interface)CUP$result) );
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // interface ::= ABSTRACT INTERFACE ID inheritance_spec LCBRACE interface_body RCBRACE 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                ((Interface)CUP$result).set_abstract();
                ((Interface)CUP$result).inheritanceSpec = (/*is*/(SymbolList)CUP$stack.elementAt(CUP$top-3));
                ((Interface)CUP$result).body = (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)) ;
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).my_interface = ((Interface)CUP$result);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Interface)CUP$result));
                ((Interface)CUP$result).set_included( parser.include_state );
                // ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // interface ::= INTERFACE ID inheritance_spec LCBRACE interface_body RCBRACE 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                ((Interface)CUP$result).inheritanceSpec = (/*is*/(SymbolList)CUP$stack.elementAt(CUP$top-3));
                ((Interface)CUP$result).body = (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)) ;
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).my_interface = ((Interface)CUP$result);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Interface)CUP$result));
                ((Interface)CUP$result).set_included( parser.include_state );
                // ((Interface)CUP$result).set_locality( parser.getLocalityContraint());
                parser.closeScope( (Scope)((Interface)CUP$result) );
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // module ::= MODULE ID LCBRACE definitions RCBRACE 
            {
              CUP$result = new Module(/*module*/11);
              
                ((Module)CUP$result).spec = (/*d*/(Definitions)CUP$stack.elementAt(CUP$top-1));
                ((Module)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));
                ((Module)CUP$result).setPackage((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)).str_val );
                ((Module)CUP$result).set_included( parser.include_state );

                (/*d*/(Definitions)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Module)CUP$result));
                parser.closeScope( (Scope)((Module)CUP$result) );
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // definition ::= value SEMI 
            {
              CUP$result = new Definition(/*definition*/9);
              
                        ((Definition)CUP$result).set_declaration((/*m*/(Value)CUP$stack.elementAt(CUP$top-1)));
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // definition ::= module SEMI 
            {
              CUP$result = new Definition(/*definition*/9);
              
                        ((Definition)CUP$result).set_declaration((/*m*/(Module)CUP$stack.elementAt(CUP$top-1)));
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // definition ::= interface SEMI 
            {
              CUP$result = new Definition(/*definition*/9);
              
                        ((Definition)CUP$result).set_declaration((/*p*/(Interface)CUP$stack.elementAt(CUP$top-1)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // definition ::= except_dcl SEMI 
            {
              CUP$result = new Definition(/*definition*/9);
              
                        ((Definition)CUP$result).set_declaration((/*e*/(StructType)CUP$stack.elementAt(CUP$top-1)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // definition ::= const_dcl SEMI 
            {
              CUP$result = new Definition(/*definition*/9);
              
                        ((Definition)CUP$result).set_declaration((/*c*/(ConstDecl)CUP$stack.elementAt(CUP$top-1)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // definition ::= type_dcl SEMI 
            {
              CUP$result = new Definition(/*definition*/9);
              
                        ((Definition)CUP$result).set_declaration((/*t*/(TypeDeclaration)CUP$stack.elementAt(CUP$top-1)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // definitions ::= definition 
            {
              CUP$result = new Definitions(/*definitions*/10);
              
                        ((Definitions)CUP$result).v.insertElementAt((/*d*/(Definition)CUP$stack.elementAt(CUP$top-0)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // definitions ::= definition definitions 
            {
              CUP$result = new Definitions(/*definitions*/10);
              
                        ((Definitions)CUP$result).v = (Vector)(/*ds*/(Definitions)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((Definitions)CUP$result).v.insertElementAt((/*d*/(Definition)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // specification ::= empty 
            {
              CUP$result = new Spec(/*specification*/8);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // specification ::= NT$0 definitions 
            {
              CUP$result = new Spec(/*specification*/8);
              
                /* parsing */

                // open the global scope
                parser.openScope();

                ((Spec)CUP$result).definitions = (Vector)(/*ds*/(Definitions)CUP$stack.elementAt(CUP$top-0)).v.clone();

                if( ((org.jacorb.idl.parser)CUP$parser).package_prefix != null )
                        ((Spec)CUP$result).setPackage( ((org.jacorb.idl.parser)CUP$parser).package_prefix );

                ((Spec)CUP$result).parse();

                if ( lexer.error_count != 0 )
                {
                        System.err.println(lexer.error_count + " error(s).");
                        System.exit(1);
                }

                // if there are still interfaces to be parsed, wait until the
                // threads performing this have finished. The last one
                // will call notify() :)

                if( parser.pending_interfaces.size() > 0  )
                {
                   // give other threads a chance to start and signal
                   // that they're active
                   Thread.yield();

                   boolean runnableFound = false;

                   // still no one seems to be active, but we'll call
                   // round to be sure
                   if( parser.activeParseThreads() == 0 )
                   {
                        Environment.output(3,"Check for runnable threads");

                        for( int t = 0;
                             t < InterfaceBody.parseThreads.size() && !runnableFound;
                             t++ )
                        {
                            runnableFound =
                                ((InterfaceBody.ParseThread)InterfaceBody.parseThreads.elementAt(t)).isRunnable();
                        }
                   }

                   // only block waiting if we know that there are active or
                   // runnable threads and that there are still pending tasks

                   if( ( parser.activeParseThreads() > 1 || runnableFound ) &&
                         parser.pending_interfaces.size() > 0 )
                   {
                       synchronized( parser.pending_interfaces )
                       {
                           Environment.output(3,"Wait for pending_interfaces");
                           parser.pending_interfaces.wait();
                           Environment.output(3,"Waking up after wait for pending_interfaces");
                       }
                   }
                }

                if( parser.pending_interfaces.size() > 0 &&
                    !parser.sloppy )
                {
                    parser.fatal_error("Undefined interface: " +
                        (String)(parser.pending_interfaces.keys().nextElement()), null );
                }

                /* complete global import list */
                if( parser.global_import )
                {
                        Environment.output(3,"Preparing global import");
                        parser.addGlobalNamesToImport();
                }
                else
                        Environment.output(3,"No global import");

                parser.done_parsing = true;

                /* code generation phase */

                try
                {

                   if (! ((org.jacorb.idl.parser)CUP$parser).parse_only  )
                   {
                        ((Spec)CUP$result).print(new java.io.PrintWriter( java.lang.System.out ));
                   }
                }
                catch ( Exception e )
                {
                     Environment.output(1,e);
                }
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              CUP$result = new java_cup.runtime.token(/*NT$0*/98);
              
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= specification EOF 
            {
              CUP$result = new java_cup.runtime.token(/*$START*/0);
              
            }
          /* ACCEPT */
          CUP$parser.done_parsing();
          return CUP$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
};

