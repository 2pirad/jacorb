
package org.jacorb.ir.gui.typesystem;


import java.util.*;
import javax.swing.tree.*;
/**
 * This class was generated by a SmartGuide.
 * 
 */
public abstract class ModelParticipant 
{
    private Hashtable modelRepresentants = new Hashtable();
    private static ModelBuilder modelBuilder = ModelBuilder.getSingleton();	// Abkürzung



    /**
     * This method was created by a SmartGuide.
     * @param treeModel javax.swing.tree.DefaultTreeModel
     * @param parent javax.swing.tree.DefaultMutableTreeNode
     */
    public void addToParent(DefaultTreeModel treeModel, DefaultMutableTreeNode parentTreeNode) {
	DefaultMutableTreeNode treeNode;

	if (parentTreeNode!=null) {  // bei root ist es null
            treeNode =  new DefaultMutableTreeNode(this);
            int i = 0;
            while ((i<parentTreeNode.getChildCount()) && 
                   ((ModelParticipant)((DefaultMutableTreeNode)treeModel.getChild(parentTreeNode,i)).getUserObject()).compareTo(this)<0) {
                i++;
            }
            treeModel.insertNodeInto(treeNode,parentTreeNode,i);
            /*		int[] indices = new int[1];
                        indices[0] = i;
                        treeModel.nodesWereInserted(parentTreeNode, indices);*/
            //		treeModel.insertNodeInto(treeNode,parentTreeNode,parentTreeNode.getChildCount());
	}	
	else {
            // wir sind root; unsere TreeNode wurde (bzw. mußte!) dem Konstruktor 
            // von DefaultTreeModel mitgegeben werden, wir müssen uns also nicht mehr inserten
            treeNode = (DefaultMutableTreeNode)treeModel.getRoot();
	}	
	setModelRepresentant(treeModel, treeNode);
	if (this instanceof AbstractContainer) {
            treeNode.setAllowsChildren(true);
	}
	else {
            treeNode.setAllowsChildren(false);
	}		
    }
    /**
     * Baut Tree für diese Node auf.
     * Kann leider nicht protected sein, weil Methode sonst selbst für Unterklassen in einem Unter-Package
     * nicht sichtbar ist.
     * @return DefaultMutableTreeNode
     * @param treeModel TreeModel
     */
    public void buildTree ( DefaultTreeModel treeModel, DefaultMutableTreeNode parentTreeNode ) {
	addToParent(treeModel,parentTreeNode);
	DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)modelRepresentants.get(treeModel);	
	if (this instanceof AbstractContainer) {
            ModelParticipant[] contents = ((AbstractContainer)this).contents();
            treeNode.setAllowsChildren(true);	
            for (int i=0; i<contents.length; i++) {
                if (contents[i]!=null) {	// solange nicht alles implementiert ist gibt's null-Einträge
                    contents[i].buildTree(treeModel,treeNode); 
                }	
            }		
	}

    }
    /**
     * This method was created by a SmartGuide.
     * @return int
     * @param other org.jacorb.ir.gui.typesystem.ModelParticipant
     */
    public abstract int compareTo(ModelParticipant other);
    /**
     * This method was created by a SmartGuide.
     * @param treeModel javax.swing.tree.DefaultTreeModel
     * @param parent javax.swing.tree.DefaultMutableTreeNode
     */
    public synchronized void expand(DefaultTreeModel treeModel) {
	boolean jTreeExpanded = false;	// Hack, damit man gleich sieht, wie die Nodes eintrudeln
	if (this instanceof AbstractContainer) {
            DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)modelRepresentants.get(treeModel);
            ModelParticipant[] contents = ((AbstractContainer)this).contents();
            for (int i=0; i<contents.length; i++) {
                if (contents[i]!=null) {	// solange nicht alles implementiert ist gibt's null-Einträge
                    contents[i].addToParent(treeModel,treeNode); 
                }	
                if (!jTreeExpanded) {
                    javax.swing.JTree jTree = (javax.swing.JTree)modelBuilder.treeViewsToUpdate.get(treeNode);
                    if (jTree!=null) {
                        jTree.expandPath(new TreePath(treeNode.getPath()));
                    }	
                }	
            }		
            modelBuilder.expandedModParts.put(treeNode,treeNode);
	}
    }
    /**
     * This method was created by a SmartGuide.
     * @return java.lang.Object
     * @param model java.lang.Object
     */
    public Object getModelRepresentant(Object model) {
	return modelRepresentants.get(model);
    }
    /**
     * This method was created by a SmartGuide.
     * @param model java.lang.Object
     * @param representant java.lang.Object
     */
    protected void setModelRepresentant(Object model, Object representant) {
	modelRepresentants.put(model,representant);
    }
}


