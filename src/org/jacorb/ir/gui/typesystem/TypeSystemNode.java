package org.jacorb.ir.gui.typesystem;


/**
 * This class was generated by a SmartGuide.
 * 
 */
 
import java.util.*;
import javax.swing.tree.*;
import java.lang.reflect.*;
 
public abstract class TypeSystemNode 
    extends ModelParticipant
{
    protected DefaultMutableTreeNode treeNode;	
    protected String name = "";
    protected String absoluteName = "";

    /**
     */
    public TypeSystemNode ( ) {
    }

    /**
     * @param treeModel javax.swing.tree.DefaultTreeModel
     * @param parent javax.swing.tree.DefaultMutableTreeNode
     */
    protected TypeSystemNode ( DefaultMutableTreeNode treeNode) {
	this();
	this.treeNode = treeNode;
    }

    /**
     * @param name java.lang.String
     */

    public TypeSystemNode ( String name) {
	this();
	this.name = name;
    }

    /**
     * Gibt Array mit Strings zurück: die Node-Typen, die zu dieser Node
     * hinzugefügt werden können.
     * IRModule z.B. gibt "module", "interface" usw. zurück.
     * @return java.util.Enumeration
     */

    public String[] allowedToAdd ( ) 
    {
        return null;
    }

    /**
     * @return int
     * @param other org.jacorb.ir.gui.typesystem.ModelParticipant
     */
    public int compareTo(ModelParticipant other) {
	return this.toString().compareTo(other.toString());
    }

    /**
     * @return java.lang.String
     */

    public  String description() {
	return  getInstanceNodeTypeName() + " " + getAbsoluteName();
    }

    /**
     * @return java.lang.String
     */
    public String getAbsoluteName() {
	return absoluteName;
    }

    /**
     * @return java.lang.String
     */

    public String getInstanceNodeTypeName ( ) 
    {
	// Für die Textrepräsentation einer Node kann nodeTypeName abhängig vom Zustand sein,
	// z.B. bei IRAttribute: gegebenenfalls muß es dort "readonly attribute" heißen und nicht "attribute"
	// Dynamischen Lookup einer static Methode simulieren:
	Method nodeTypeNameMethod;
	String nodeTypeName = "";
	try {
            nodeTypeNameMethod = getClass().getMethod("nodeTypeName", new Class[0]);
            nodeTypeName = (String) nodeTypeNameMethod.invoke(null, new Object[0]) ;
	}
	catch (Exception e) {
            e.printStackTrace();
	}	
	return nodeTypeName;    
    }

    /**
     * @return java.lang.String
     */

    public String getName ( ) 
    {
        return name; 
    }

    /**
     * Füge neues Child zu Node hinzu. Wird nur von TypeSystem.insertChild(..) aufgerufen.
     * Macht hier nichts als Exception zu werfen, wenn newChild nicht zugelassen ist, muß also
     * von Unterklassen überschrieben werden, um z.B. entsprechende Methode auf IR aufzurufen.
     * Bei illegalem Child-Typ wird IllegalChildException geworfen.
     * @param newChild TypeSystemNode
     */

    protected void insertChild ( TypeSystemNode newChild) 
        throws IllegalChildException 
    {
	String[] allowedTypes = allowedToAdd();
	int i;
	for (i = 0;  
             i <allowedTypes.length && !allowedTypes[i].equals(newChild.nodeTypeName()); 
             i++);

	if (!allowedTypes[i].equals(newChild.nodeTypeName())) {
            throw new IllegalChildException();
	}	
	// Das eigentliche Einfügen der DefaultMutableTreeNode wird von TypeSystem vorgenommen,
	// um entsprechende Events des TreeModels wird sich dort gekümmert.
	// Unterklassen müssen Methode überschreiben (inkl. Aufruf von super.addChild(..)) und z.B.
	// entsprechende Methode auf dem InterfaceRepository aufrufen
    }

    /**
     * Gib den Namen des Typen der Node zurück, z.B. den IDL-Bezeichner "Module"
     * @return java.lang.String
     */

    public static String nodeTypeName ( ) {
	// static Methoden können nicht abstract sein
	return null;
    }

    /**
     */
    protected void setAbsoluteName(String absoluteName ) {
	this.absoluteName = absoluteName;
    }

    /**
     * wird von Unterklassen von TypeSystemNode aufgerufen, deswegen protected
     * @param name java.lang.String
     */

    protected void setName( String name) {
	this.name = name;
    }

    /**
     * Soll möglichst IDL-ähnliche komplette Textrepräsentation zurückgeben
     * aber nur der Node selbst.
     * @return java.lang.String
     */
    public String toString ( ) {
	return getInstanceNodeTypeName() + " " + getName();
    }
}







