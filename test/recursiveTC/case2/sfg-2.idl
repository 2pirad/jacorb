
// modifications to released version:
// added WKSGeometrySeq
// added GeometrySeq

#ifndef _sfg_idl
#define _sfg_idl

#pragma prefix "opengis.org"

module sfg
{
	interface Geometry;   // forward declarations

//----------------------------------------------------------------------
// WKSGeometry
//----------------------------------------------------------------------

	/**
	 * This represents a well known structure for point geometries.
	 * <dl>
	 * <dd><code>{@link #x}</code>The first ordinate of the point geometry.
	 * <dd><code>{@link #y}</code>The second ordinate of the point geometry.
	 * </dl>
	 */
	struct WKSPoint {
		double	x;
		double	y;
	};

	typedef	sequence<WKSPoint>		WKSPointSeq;
	typedef	sequence<WKSPoint>		WKSLineString;
	typedef	sequence<WKSLineString>	 WKSLineStringSeq;
	typedef	sequence<WKSPoint>		WKSLinearRing;
	typedef	sequence<WKSLinearRing>	WKSLinearRingSeq;

	/**
	 * This represents a well known structure for linear polygon geometries.
	 * <dl>
	 * <dd><code>{@link #externalBoundary}</code>
	 * <dd><code>{@link #internalBoundaries}</code>
	 * </dl>
	 */
	struct WKSLinearPolygon {
		WKSLinearRing		externalBoundary;
		WKSLinearRingSeq	internalBoundaries;
	};

	typedef sequence <WKSLinearPolygon> WKSLinearPolygonSeq;

	/**
	 * The type of geometry as used by WKSGeometry.
	 */
	enum WKSType {
		WKSPointType,
		WKSMultiPointType,
		WKSLineStringType,
		WKSMultiLineStringType,
		WKSLinearRingType,
		WKSLinearPolygonType,
		WKSMultiLinearPolygonType,
		WKSCollectionType
	};

	/**
	 * The Well-known Structures (WKS) allow for the sharing of linear
	 * coordinate geometries and collections of such geometries between
	 * interoperating applications.
	 */
	union WKSGeometry // near-equivalent to the 'CoordinateGeometry of the spec'

		switch (WKSType) {
		
			case	WKSPointType:
				WKSPoint point;

			case WKSMultiPointType:
				WKSPointSeq multi_point;

			case	WKSLineStringType:
				WKSLineString line_string;

			case WKSMultiLineStringType:
				WKSLineStringSeq multi_line_string;

			case	WKSLinearRingType:
				WKSLinearRing linear_ring;

			case	WKSLinearPolygonType:
				WKSLinearPolygon linear_polygon;
	     
			case WKSMultiLinearPolygonType:
				WKSLinearPolygonSeq multi_linear_polygon;

			case	WKSCollectionType:
				sequence<WKSGeometry> collection;	    
		};

	typedef sequence<WKSGeometry> WKSGeometrySeq;

	/**
	 * The minimum bounding box of a geometry.
	 */
	struct Envelope {
		WKSPoint		minm;
		WKSPoint		maxm;
	};

	typedef sequence<octet> OctetSeq;

//----------------------------------------------------------------------
// Exceptions
//----------------------------------------------------------------------
   /**
	* An exception meaning that this feature is currently not implemented.
	* <dl>
	* <dd><code>{@link #what}</code> A string describing the reason for this
	* exception.
	* <dd><code>{@link #data}</code> An any containing additional information
	* about this exception.
	* </dl>
	*/
	exception NotImplementedException
	{
		string what;
		any data;
	};

   /**
	* An exception of the {@link SpatialReferenceSystem} interface.
	* <dl>
	* <dd><code>{@link #what}</code> A string describing the reason for this
	* exception.
	* <dd><code>{@link #data}</code> An any containing additional information
	* about this exception.
	* </dl>
	*/
	exception SpatialReferenceSystemException
	{
		string what;
		any data;
	};

   /**
	* An exception of the {@link Geometry} interface.
	* <dl>
	* <dd><code>{@link #what}</code> A string describing the reason for this
	* exception.
	* <dd><code>{@link #data}</code> An any containing additional information
	* about this exception.
	* </dl>
	*/
	exception GeometryException
	{
		string what;
		any data;
	};

   /**
	* An exception of the {@link GeometryCollection} interface.
	* <dl>
	* <dd><code>{@link #what}</code> A string describing the reason for this
	* exception.
	* <dd><code>{@link #data}</code> An any containing additional information
	* about this exception.
	* </dl>
	*/
	exception GeometryCollectionException
	{
		string what;
		any data;
	};

//----------------------------------------------------------------------
// Spatial Reference Systems
//----------------------------------------------------------------------


//----------------------------------------------------------------------
// SpatialReferenceInfo 
//----------------------------------------------------------------------

	/**
	 * The SpatialReferenceInfo interface exposes a number of attributes
	 * common to all entities within the spatial reference systems definition.
	 * Most of the SRS interfaces inherit directly or indirectly from it.
	 */
	interface SpatialReferenceInfo {

		/**
		 * Gets the name of the Spatial Reference System component. This
		 * name is unique.
		 * <br><b>Note:</b> set method currently not implemented.
		 */
 		attribute string		name;

		/**
		 * Gets the organization, body or person who created the entity.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute string		authority;	

		/**
		 * Gets an unique code of the entity.
		 * <br><b>Note:</b> set method currently not implemented.
		 */
 		attribute long			code;

		/**
		 * Gets the alias of the Spatial Reference System component.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute string		alias;		

		/**
		 * Gets an abbreviation of the Spatial Reference System component.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute string		abbreviation; 

		/**
		 * Gets a natural language description of the entity.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute string		remarks;
 

		/**
		 * Gets a comma delimited textual representation of the parameters on
		 * the Spatial Reference System component.
		 * <br><b>Note:</b> method returns currently a default PCS
		 * @return textual representation of the parameters
		 */
 		readonly attribute string       well_known_text; 
	};


//----------------------------------------------------------------------
// Unit interface
//----------------------------------------------------------------------

	/**
	 * The Unit interface abstracts various coordinate units used by spatial
	 * reference systems.
	 */
	interface Unit : SpatialReferenceInfo {
	};

//----------------------------------------------------------------------
// AngularUnit interface
//----------------------------------------------------------------------

	/**
	 * The AngularUnit interface exposes the definition of the units used by
	 * the SRS entity to define angles. The angular units are defined with
	 * respect to radians. Name and identity information is inherited from the
	 * {@link SpatialReferenceInfo} interface.
	 */
	interface AngularUnit : Unit {

		/**
		 * Gets the number of radians per unit.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute double	radians_per_unit;
 	
	};

//----------------------------------------------------------------------
// LinearUnit interface
//----------------------------------------------------------------------

	/**
	 * The LinearUnit interface exposes the definition of the linear units used
	 * by an SRS entity, allowing the use of various standard and non-standard
	 * linear units. Name and identity information is inherited from the
	 * {@link SpatialReferenceInfo} interface.
	 */
	interface LinearUnit : Unit {
 
		/**
		 * Gets the value of a unit in metres.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
		attribute double	metres_per_unit;
  
	};

//----------------------------------------------------------------------
// Ellipsoid interface
//----------------------------------------------------------------------

	/**
	 * An abstraction of the earth's shape.
	 * Most Spatial Reference Systems use a mathematical abstraction of the
	 * earth's shape on which to base a coordinate system. Typically this
	 * surface is an ellipsoid of revolution.  The ellipsoid interface exposes
	 * the defining parameters of an ellipsoid. Identity parameters are
	 * inherited from the {@link SpatialReferenceInfo} interface.
	 */
	interface Ellipsoid : SpatialReferenceInfo {
 
		/**
		 * Gets the semi-major axis of the ellipsoid in {@link #axis_unit()}.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute double	semi_major_axis;

		/**
		 * Gets the semi-minor axis of the ellipsoid in {@link #axis_unit()}.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute double	semi_minor_axis;
 
		/**
		 * Gets the inverse flattening of the ellipsoid
		 * <code>(inverse_flattening = semi_major_axis /
		 * (semi_major_axis - semi_minor_axis))</code>.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute double	inverse_flattening;

		/**
		 * Gets the units used to define the axes of the ellipsoid. 
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute LinearUnit	axis_unit;
 
	};

//----------------------------------------------------------------------
// HorizontalDatum interface
//----------------------------------------------------------------------

	/**
	 * A horizontal datum provides a mapping between the surface of the earth
	 * and the surface of a base ellipsoid.
	 */
	interface HorizontalDatum : SpatialReferenceInfo {
 
		/**
		 * Gets the ellipsoid on which the HorizontalDatum is based.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute Ellipsoid	base_ellipsoid;
 
	};


//----------------------------------------------------------------------
// PrimeMeridian interface
//----------------------------------------------------------------------

	/**
	 * The PrimeMeridian interface provides access to the definition of a
	 * system's prime meridian. This allows the selection of an arbitrary
	 * standard for the SRS. The prime meridian is defined with respect to the
	 * Greenwich Prime Meridian. Identity and Descriptive attributes are
	 * inherited from the {@link SpatialReferenceInfo} interface.
	 */
	interface PrimeMeridian : SpatialReferenceInfo {
 
		/**
		 * Gets the longitude of the Prime Meridian relative to Greenwich
		 * in {@link #angular_units}.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute double	longitude;
 
		/**
		 * Gets the angular units in which {@link #longitude} is
		 * described. 
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute AngularUnit	angular_units;
 
	};

//----------------------------------------------------------------------
// SpatialReferenceSystem interface
//----------------------------------------------------------------------

	/**
	 * The <code>SpatialReferenceSystem</code> interface is an abstraction of
	 * all Spatial Reference Systems. These may include non-geodetic systems
	 * and local SRSs. Identity and descriptive attributes are inherited from
	 * {@link SpatialReferenceInfo}; type-specific attributes are specified in
	 * the various interfaces derived from <code>SpatialReferenceSystem</code>.
	 */
	interface SpatialReferenceSystem : SpatialReferenceInfo {
	};

//----------------------------------------------------------------------
// GeodeticSpatialReferenceSystem interface
//----------------------------------------------------------------------

	/**
	 * The <code>GeodeticSpatialReferenceSystem</code> interface is an
	 * abstraction of all geodetic Spatial Reference Systems including
	 * Geographic SRSs and Projected SRSs. Identity and descriptive attributes
	 * are inherited from {@link SpatialReferenceInfo} (through {@link
	 * SpatialReferenceSystem}); type-specific attributes are specified in the
	 * various interfaces derived from
	 * <code>GeodeticSpatialReferenceSystem</code>.
	 */
	interface GeodeticSpatialReferenceSystem : SpatialReferenceSystem {
	};

//----------------------------------------------------------------------
// GeographicCoordinateSystem interface
//----------------------------------------------------------------------

	/**
	 * A geographic coordinate system uses spherical or ellipsoidal coordinates
	 * (latitudes & longitudes). The <code>GeographicCoordinateSystem</code>
	 * interface exposes the defining parameters of a geographic coordinate
	 * system. It inherits from {@link GeodeticSpatialReferenceSystem}.
	 */
	interface GeographicCoordinateSystem : GeodeticSpatialReferenceSystem { 

		/**
		 * Gets a comment on the usage of the coordinate system.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
		attribute string		usage;

		/**
		 * Gets the horizontal datum on which the
		 * <code>GeographicCoordinateSystem</code> is based.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute HorizontalDatum	horizontal_datum;

		/**
		 * Gets the angular units used by the coordinates within the
		 * <code>GeographicCoordinateSystem</code>.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute AngularUnit		angular_unit;

		/**
		 * Gets the reference meridian of the
		 * <code>GeographicCoordinateSystem</code>.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute PrimeMeridian		prime_meridian;
 
	};

//----------------------------------------------------------------------
// Parameter interface
//----------------------------------------------------------------------

	/**
	 * Parameters for components of a SRS.
	 * Various components of spatial reference systems are defined using
	 * parameters. As the number and type of these parameters may vary with
	 * different components, a <code>Parameter</code> interface is used to
	 * expose this information to clients.
	 */
	interface Parameter : SpatialReferenceInfo {

		/**
		 * Exposes the units in which {@link #value} is expressed. This
		 * attribute provides the semantics of {@link #value}.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute Unit		units;

		/**
		 * Gets the parameter value in {@link #units}.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute double		value;
 
	};

	typedef sequence<Parameter>	ParameterSeq;

//----------------------------------------------------------------------
// ParameterList interface
//----------------------------------------------------------------------

	/**
	 * The <code>ParameterList</code> interface exposes the set of parameters
	 * that are used to define a particular component of a spatial reference
	 * system.
	 */
	interface ParameterList {

		/**
		 * Gets the number of parameters in the <code>ParameterList</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @return the number of parameters
		 */
		readonly attribute long	number_parameters;


		/**
		 * Returns a sequence of the default parameter values for the spatial
		 * reference system component.
		 * <br><b>Note:</b> method currently not implemented.
		 * @return the default parameters
		 */
 		ParameterSeq	get_default_parameters();
 

		/**
		 * Sets the values of the <code>ParameterList</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param parameters Parameters to set
		 */
 		void	      	set_parameters (in ParameterSeq parameters);

		/**
		 * Gets the current values of the <code>ParameterList</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @return current parameters
		 */
 		ParameterSeq	get_parameters ();
 
	};

//----------------------------------------------------------------------
// GeographicTransform interface
//----------------------------------------------------------------------

	/**
	 * The <code>GeographicTransform</code> interface provides access to
	 * transformation facilities capable of transforming coordinate geometries
	 * in the form of Well-known Structures from one coordinate system into
	 * another.
	 */
	interface GeographicTransform : SpatialReferenceInfo {

		/**
		 * Gets the source coordinate system of the transformation.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute	GeographicCoordinateSystem	source_gcs;

		/**
		 * Gets the destination coordinate system of the transformation.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute	GeographicCoordinateSystem	target_gcs;
 

		/**
		 * Transforms the <code>source_geometry</code> from the {@link
		 * #source_gcs} coordinate system to the {@link #target_gcs} coordinate
		 * system and returns the result.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param source_geometry geometry to transform
		 * @return transformed geometry
		 * @throws SpatialReferenceSystemException
		 */
 		WKSGeometry	forward (in WKSGeometry source_geometry)
			raises (SpatialReferenceSystemException);

		/**
		 * Transforms the <code>source_geometry</code> from the {@link
		 * #target_gcs} coordinate system to the {@link #source_gcs} coordinate
		 * system and returns the result.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param source_geometry geometry to transform
		 * @return transformed geometry
		 * @throws SpatialReferenceSystemException
		 */
 		WKSGeometry	inverse (in WKSGeometry source_geometry)
			raises (SpatialReferenceSystemException);
 
	};


//----------------------------------------------------------------------
// Projection interface
//----------------------------------------------------------------------

	/**
	 * A projection maps between an ellipsoid and a coordinate plane. The
	 * <code>Projection</code> interface provides access to the parameters that
	 * define this mapping.
	 */
	interface Projection : SpatialReferenceInfo {

		/**
		 * Gets a comment on the usage of the coordinate system.
		 * <br><b>Note:</b> method currently not implemented.
		 * @return the comment
		 */
 		readonly	attribute string    usage;

		/**
		 * Indicates the classification of the projection. 
		 * <br><b>Note:</b> method currently not implemented.
		 * @return the classification
		 */
 		readonly	attribute string    classification;
 

		/**
		 * Transforms the Well-known Structure <code>source_geometry</code>
		 * from geographic coordinates into projected (planar) coordinates and
		 * returns the result.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param source_geometry geometry to transform
		 * @return transformed geometry
		 * @throws SpatialReferenceSystemException
		 */
 		WKSGeometry	forward (in WKSGeometry source_geometry)
			raises (SpatialReferenceSystemException);

		/**
		 * Transforms the Well-known Structure <code>source_geometry</code>
		 * from projected (planar) coordinates into geographic coordinates and
		 * returns the result.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param source_geometry geometry to transform
		 * @return transformed geometry
		 * @throws SpatialReferenceSystemException
		 */
 		WKSGeometry	inverse (in WKSGeometry source_geometry)
			raises (SpatialReferenceSystemException);
 

		/**
		 * Returns the set of parameters that defines the projection. These
		 * parameters vary between collection classes.
		 * <br><b>Note:</b> method currently not implemented.
		 * @return the set of parameters
		 */
 		readonly attribute ParameterList    parameters;
 

		/**
		 * Gets the angular units used for geographic coordinates.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute AngularUnit	angular_units;

		/**
		 * Gets the linear units used for planar coordinates.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute LinearUnit	linear_units;

		/**
		 * Gets the base ellipsoid of the <code>Projection</code>.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
 		attribute Ellipsoid	base_ellipsoid;
 
	};

//----------------------------------------------------------------------
// ProjectedCoordinateSystem interface
//----------------------------------------------------------------------

	/**
	 * A projected coordinate system uses a geographic coordinate system and a
	 * projection to map from points on the earth's surface to those on a
	 * coordinate plane. The <code>ProjectedCoordinateSystem</code> interface
	 * exposes the defining parameters of a geographic coordinate system. It
	 * inherits from {@link GeodeticSpatialReferenceSystem}.
	 */
	interface ProjectedCoordinateSystem : GeodeticSpatialReferenceSystem {

		/**
		 * Gets a comment on the usage of the coordinate system.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
		attribute string		usage;

		/**
		 * Gets the underlying geographic coordinate system.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
		attribute GeographicCoordinateSystem    geographic_coordinate_system;

		/**
		 * Gets the linear units of the coordinate plane.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
		attribute LinearUnit	linear_units;

		/**
		 * Gets the projection used to project from the ellipsoid to the
		 * coordinate plane.
		 * <br><b>Note:</b> get/set method currently not implemented.
		 */
		attribute Projection	base_projection;
 

		/**
		 * Gets the set of parameters that defines the projected coordinate
		 * system.
		 * <br><b>Note:</b> method currently not implemented.
		 * @return the set of parameters
		 */
		readonly attribute ParameterList    parameters;
 

		/**
		 * Transforms the Well-known Structure <code>source_geometry</code>
		 * from geographic coordinates into projected (planar) coordinates and
		 * returns the result.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param source_geometry geometry to transform
		 * @return transformed geometry
		 * @throws SpatialReferenceSystemException
		 */
		WKSGeometry     forward (in WKSGeometry source_geometry)
			raises (SpatialReferenceSystemException);

		/**
		 * Transforms the Well-known Structure <code>source_geometry</code>
		 * from projected (planar) coordinates into geographic coordinates and
		 * returns the result.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param source_geometry geometry to transform
		 * @return transformed geometry
		 * @throws SpatialReferenceSystemException
		 */
		WKSGeometry     inverse (in WKSGeometry source_geometry)
			raises (SpatialReferenceSystemException);
 
	};


//----------------------------------------------------------------------
// SpatialReferenceSystemFactory interface
//----------------------------------------------------------------------

	/**
	 * The SpatialReferenceSystemFactory interface provides for the creation of
	 * a spatial reference system given a textual definition.
	 * The Well-known Text Representation of Spatial Reference Systems provides
	 * a standard textual representation for spatial reference system
	 * information.
	 */
	interface SpatialReferenceSystemFactory {
 
		/**
		 * creates a new {@link SpatialReferenceSystem} object from the text
		 * description <code>srs_wkt</code>.
		 * @param srs_wkt text description of a coordinate system
		 * @return a new spatial reference system
		 * @throws SpatialReferenceSystemException if the text representation
		 * is malformed
		 */
 		SpatialReferenceSystem	create_from_WKT (in string srs_wkt)
			raises (SpatialReferenceSystemException);
 
	};

//----------------------------------------------------------------------
// SpatialReferenceComponentFactory interface
//----------------------------------------------------------------------

	/**
	 * The <code>SpatialReferenceComponentFactory</code> interface provides for
	 * the creation of spatial reference system components from a standard
	 * identification code.
	 */
	interface SpatialReferenceComponentFactory {

		/**
		 * is the standards authority which defines the components created by
		 * the factory (e.g. 'EPSG').
		 * <br><b>Note:</b> method currently not implemented.
		 * @return the standards authority string
		 */
 		readonly attribute  string  authority;

		/**
		 * Creates the {@link ProjectedCoordinateSystem} with the identifier
		 * <code>code</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param code identifier for the PCS
		 * @return a new {@link ProjectedCoordinateSystem}
		 * @throws SpatialReferenceSystemException
		 */
 		ProjectedCoordinateSystem create_projected_coordinate_system (
			in long code)
			raises (SpatialReferenceSystemException);

		/**
		 * Creates the {@link GeographicCoordinateSystem} with the identifier
		 * <code>code</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param code identifier for the GCS
		 * @return a new {@link GeographicCoordinateSystem}
		 * @throws SpatialReferenceSystemException
		 */
 		GeographicCoordinateSystem create_geographic_coordinate_system (
			in long code)
			raises (SpatialReferenceSystemException);

		/**
		 * Creates the {@link Projection} with the identifier
		 * <code>code</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param code identifier for the {@link Projection}
		 * @return a new {@link Projection}
		 * @throws SpatialReferenceSystemException
		 */
 		Projection				create_projection (in long code)
			raises (SpatialReferenceSystemException);

		/**
		 * Creates the {@link GeographicTransform} with the identifier
		 * <code>code</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param code identifier for the {@link GeographicTransform}
		 * @return a new {@link GeographicTransform}
		 * @throws SpatialReferenceSystemException
		 */
 		GeographicTransform     	create_geographic_transform (in long code)
			raises (SpatialReferenceSystemException);

		/**
		 * Creates the {@link HorizontalDatum} with the identifier
		 * <code>code</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param code identifier for the {@link HorizontalDatum}
		 * @return a new {@link HorizontalDatum}
		 * @throws SpatialReferenceSystemException
		 */
 		HorizontalDatum			create_horizontal_datum	(in long code)
			raises (SpatialReferenceSystemException);

		/**
		 * Creates the {@link Ellipsoid} with the identifier
		 * <code>code</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param code identifier for the {@link Ellipsoid}
		 * @return a new {@link Ellipsoid}
		 * @throws SpatialReferenceSystemException
		 */
 		Ellipsoid					create_ellipsoid (in long code)
			raises (SpatialReferenceSystemException);

		/**
		 * Creates the {@link PrimeMeridian} with the identifier
		 * <code>code</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param code identifier for the {@link PrimeMeridian}
		 * @return a new {@link PrimeMeridian}
		 * @throws SpatialReferenceSystemException
		 */
 		PrimeMeridian				create_prime_meridian (in long code)
			raises (SpatialReferenceSystemException);

		/**
		 * Creates the {@link LinearUnit} with the identifier
		 * <code>code</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param code identifier for the {@link LinearUnit}
		 * @return a new {@link LinearUnit}
		 * @throws SpatialReferenceSystemException
		 */
 		LinearUnit				create_linear_unit (in long code)
			raises (SpatialReferenceSystemException);

		/**
		 * Creates the {@link AngularUnit} with the identifier
		 * <code>code</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param code identifier for the {@link AngularUnit}
		 * @return a new {@link AngularUnit}
		 * @throws SpatialReferenceSystemException
		 */
 		AngularUnit				create_angular_unit (in long code)
			raises (SpatialReferenceSystemException);
 
	};

//----------------------------------------------------------------------
// Geometry interface
//----------------------------------------------------------------------
	/**
	 * Any valid value of a geometric attribute of feature may be exposed through
	 * the Geometry interface. This interface provides access to the properties
	 * that are common to all geometric entities.
	 */
	interface Geometry {
 
		enum EgenhoferElement {
			Empty, NotEmpty, NoTest
		};
 
		struct EgenhoferOperator {
			EgenhoferElement elements[3][3];
		};

		/**
		 * Returns the dimension of the geometry. For a point this value will
		 * be 0, for a line string it will be 1, for a polygon 2. Note: this
		 * value is not the dimension of the coordinate space in which the
		 * geometry is defined, nor the dimension of the extent of the geometry.
		 * @return the dimension of the coordinates that define this geometry
		 */
 		readonly	attribute	short	dimension; // dimension of the geometry 

		/**
		 * Returns an envelope wholly containing the geometry.
		 * Usually this envelope will be the aligned Minimal Bounding Rectangle
		 * for this geometry.
		 * @return the envelope for this geometry
		 */
 		readonly	attribute	Envelope range_envelope; // minBoundBox in abstract spec 

		/**
		 * Returns a reference to the Geometry's Spatial Reference System. The
		 * SRS provides the semantics of the coordinates exposed by the
		 * Geometry through well-known structures (i.e. it locates the Geometry
		 * with respect to the earth).
		 * @return a SpatialReferenceSystem object
		 */
 		readonly	attribute	SpatialReferenceSystem	spatial_reference_system; 
 
 	// geometric characteristics

		/**
		 * Returns true if the Geometry is the empty set.
		 * @return <code>true</code> if this geometric object is empty;
		 * <code>false</code> otherwise
		 * @throws org.opengis.sfg.GeometryException
		 */
 		boolean		is_empty()		    
			raises (GeometryException);

		/**
		 * Returns true if the Geometry has no anomalous geometric points,
		 * such as self intersection or self tangency.
		 * @return <code>true</code> if this geometric object is simple;
		 * <code>false</code> otherwise
		 * @throws org.opengis.sfg.GeometryException
		 */
 		boolean		is_simple()		    
			raises (GeometryException);

		/**
		 * Returns true if the Geometry's boundary is the empty set.
		 * @return <code>true</code> if this geometric object is closed;
		 * <code>false</code> otherwise
		 * @throws org.opengis.sfg.GeometryException
		 */
 		boolean		is_closed()		    
			raises (GeometryException);
 
 	// constructive operators

		/**
		 * Creates a (deep) copy of the Geometry and returns a reference to it.
		 * The Geometry's associated Spatial Reference System is not copied (only
		 * a reference to it is copied).
		 * @return the new Geometry object
		 * @throws org.opengis.sfg.GeometryException if an invalid geometry
		 * was detected, if the native type is not supported
		 */
 		Geometry		copy()
			raises (GeometryException);

		/**
		 * Returns the closure of the combinatorial boundary of the Geometry.
		 * @return the closure of the combinatorial boundary
		 * @throws org.opengis.sfg.GeometryException
		 */
 		Geometry		boundary()
			raises (GeometryException);

		/**
		 * Returns a <code>Geometry</code> representing all points within
		 * <code>distance</code> of this.
		 * @param distance distance to the original geometry
		 * @return buffer geometry
		 * @throws org.opengis.sfg.GeometryException
		 */
 		Geometry		buffer (in double distance)
			raises (GeometryException);

		/**
		 * Returns a geometry representing the convex hull of this geometry.
		 * @return <code>Geometry</code> object of the convex hull
		 * @throws org.opengis.sfg.GeometryException
		 */
 		Geometry		convex_hull()
			raises (GeometryException);
 
 	// WKS operators

		/**
		 * Returns the coordinate geometry in the form of a Well-known
		 * Structure (WKS) of the Geometry.
		 * @return <code>WKSGeometry</code> object of this geometry
		 * @throws org.opengis.sfg.GeometryException
		 */
 		WKSGeometry	export()	        // export geometry to WKS
 			raises (GeometryException);

		/**
		 * Returns the coordinate geometry in the form of a Well-known Binary
		 * (WKB) representation of the Geometry.
		 * @return WKB representation of this geometry
		 * @throws org.opengis.sfg.GeometryException
		 * @throws org.opengis.sfg.NotImplementedException
		 */
 		OctetSeq		export_WKBGeometry()	// export geometry to WKB
 			raises (NotImplementedException, GeometryException);
 
 	// relational operators

		/**
		 * Returns <code>true</code> if <code>this</code> and
		 * <code>other</code> are equivalent geometries.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param other geometry to compare with
		 * @return <code>true</code> if <code>this</code> and
		 * <code>other</code> are equivalent geometries
		 * @throws org.opengis.sfg.GeometryException
		 */
 		boolean		equals (in Geometry other)
			raises (GeometryException);

		/**
		 * Returns <code>true</code> if <code>this</code> and
		 * <code>other</code> share part of their boundaries.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param other geometry to compare with
		 * @return <code>true</code> if <code>this</code> and
		 * <code>other</code> share part of their boundaries
		 * @throws org.opengis.sfg.GeometryException
		 */
 		boolean		touches (in Geometry other)
			raises (GeometryException);

		/**
		 * Returns <code>true</code> if <code>other</code> is wholly contained
		 * within <code>this</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param other geometry to compare with
		 * @return <code>true</code> if <code>other</code> is wholly contained
		 * within <code>this</code>
		 * @throws org.opengis.sfg.GeometryException
		 */
 		boolean		contains (in Geometry other)
			raises (GeometryException);

		/**
		 * Returns <code>true</code> if <code>this</code> is wholly contained
		 * by <code>other</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param other geometry to compare with
		 * @return <code>true</code> if <code>this</code> is wholly contained
		 * by <code>other</code>
		 * @throws org.opengis.sfg.GeometryException
		 */
 		boolean		within (in Geometry other)
			raises (GeometryException);

		/**
		 * Returns <code>true</code> if <code>this</code> and
		 * <code>other</code> are disjoint geometries.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param other geometry to compare with
		 * @return <code>true</code> if <code>this</code> and
		 * <code>other</code> are disjoint geometries
		 * @throws org.opengis.sfg.GeometryException
		 */
 		boolean		disjoint (in Geometry other)
			raises (GeometryException);

		/**
		 * Returns <code>true</code> if <code>this</code> crosses
		 * <code>other</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param other geometry to compare with
		 * @return <code>true</code> if <code>this</code> crosses
		 * <code>other</code>
		 * @throws org.opengis.sfg.GeometryException
		 */
 		boolean		crosses (in Geometry other)
			raises (GeometryException);

		/**
		 * Returns <code>true</code> if <code>this</code> overlaps
		 * <code>other</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param other geometry to compare with
		 * @return <code>true</code> if <code>this</code> overlaps
		 * <code>other</code>
		 * @throws org.opengis.sfg.GeometryException
		 */
 		boolean		overlaps (in Geometry other)
			raises (GeometryException);

		/**
		 * Returns <code>true</code> if <code>this</code> intersects
		 * <code>other</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param other geometry to compare with
		 * @return <code>true</code> if <code>this</code> intersects
		 * <code>other</code>
		 * @throws org.opengis.sfg.GeometryException
		 */
 		boolean		intersects (in Geometry other)
			raises (GeometryException);

		/**
		 * Returns <code>true</code> if the Egenhofer relationship specified by
		 * <code>operator</code> exists between <code>this</code> and
		 * <code>other</code>. The Egenhofer operator is specified through the
		 * EgenhoferOperator array. This is a 3 x 3 array of trinary elements
		 * that correspond to the nine sets of intersection between two
		 * geometries. Each element may have the value Empty,
		 * NotEmpty and NoTest. NoTest elements always return
		 * <code>true</code>. Empty elements will return <code>true</code> only
		 * if the corresponding intersection set is empty. NotEmpty elements
		 * will only return <code>true</code>
		 * if the corresponding intersection set is not empty. The relate
		 * operation will only return <code>true</code>, if all nine elements
		 * return <code>true</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param other geometry to compare with
		 * @param operator Egenhofer relationship to use
		 * @return boolean value of the Egenhofer relationship
		 * @throws org.opengis.sfg.GeometryException
		 */
 		boolean		relate (in Geometry other, in EgenhoferOperator operator)
			raises (GeometryException);
 
 	// metric operators

		/**
		 * Returns the minimum distance between <code>this</code> and
		 * <code>other</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param other geometry to compare with
		 * @return distance
		 * @throws org.opengis.sfg.GeometryException
		 */
 		double		distance (in Geometry other)
			raises (GeometryException);
 
 	// set operators

		/**
		 * Returns the point set intersection of <code>this</code> and
		 * <code>other</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param other geometry to compare with
		 * @return intersection of both geometries
		 * @throws org.opengis.sfg.GeometryException
		 */
 		Geometry		intersection (in Geometry other)
			raises (GeometryException);

		/**
		 * Returns the point set union of <code>this</code> and
		 * <code>other</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param other geometry to compare with
		 * @return union of both geometries
		 * @throws org.opengis.sfg.GeometryException
		 */
 		Geometry		union_op(in Geometry other)
			raises (GeometryException);

		/**
		 * Returns the point set difference of <code>this</code> and
		 * <code>other</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param other geometry to compare with
		 * @return difference of both geometries
		 * @throws org.opengis.sfg.GeometryException
		 */
 		Geometry		difference (in Geometry other)
			raises (GeometryException);

		/**
		 * Returns the point set symmetric difference of <code>this</code> and
		 * <code>other</code>.
		 * <br><b>Note:</b> method currently not implemented.
		 * @param other geometry to compare with
		 * @return symmetric difference of both geometries
		 * @throws org.opengis.sfg.GeometryException
		 */
 		Geometry		symmetric_difference (in Geometry other)
			raises (GeometryException);
 

		/**
		 * Destroys the Geometry.
		 * @throws org.opengis.sfg.GeometryException
		 */
		void			destroy()
			raises (GeometryException);
	};

	typedef sequence<Geometry> GeometrySeq;

//----------------------------------------------------------------------
// GeometryFactory interface
//----------------------------------------------------------------------

	/**
	 * The GeometryFactory interface allows client applications to create
	 * new <code>Geometry</code> objects which may then be assigned as values to
	 * geometric attributes of Features.
	 */
	interface GeometryFactory {
 
		/**
		 * Creates a new <code>Geometry</code> instance that is a deep-copy of
		 * <code>existing</code>.
		 * @param existing original geometry
		 * @return new <code>Geometry</code> instance
		 * @throws org.opengis.sfg.GeometryException if an invalid geometry was
		 * detected, if the native geometry type is not supported
		 */
 		Geometry  create(in Geometry existing)
			raises (GeometryException);
 
 		/**
		 * Creates a new Geometry instance given an spatial referencing system
		 * and a coordinate geometry encoded in the well-known structure (WKS).
		 * @param srs spatial referencing system to use
		 * @param geo original geometry
		 * @return new <code>Geometry</code> instance
		 * @throws org.opengis.sfg.GeometryException if an invalid geometry was
		 * detected, if the native geometry type is not supported
		 */
 		Geometry  create_from_WKS(in SpatialReferenceSystem srs,
			in WKSGeometry geo) 
			raises (GeometryException);
	 
 		/**
		 * Creates a new Geometry instance given an spatial referencing system
		 * and a coordinate geometry encoded in the well-known binary stream
		 * (WKB) representation format.
		 * @param srs spatial referencing system to use
		 * @param geo original geometry
		 * @return new <code>Geometry</code> instance
		 * @throws org.opengis.sfg.NotImplementedException
		 * @throws org.opengis.sfg.GeometryException
		 */
 		Geometry  create_from_WKB(in SpatialReferenceSystem srs,in OctetSeq geo) 
			raises (NotImplementedException, GeometryException);
	};


	interface GeometryCollection;
	interface GeometryIterator;

//----------------------------------------------------------------------
// GeometryCollection interface
//----------------------------------------------------------------------

	/**
	 * In many cases a single simple geometry is insufficient to represent a
	 * geometric entity. In others, it is desirable to group arbitrary
	 * geometries, and treat them as a single geometry for various purposes.
	 * The GeometryCollection interface allows the grouping of possibly
	 * arbitrary Geometries for subsequent simultaneous manipulation. A
	 * {@link GeometryIterator} interface allows client access to the
	 * components of
	 * such groups or composite geometries, while hiding the structure of the
	 * underlying collection implementation. Particular implementations of
	 * GeometryCollections may restrict membership to Geometries with
	 * particular characteristics (e.g. all elements must be co-planar, of a
	 * particular dimension or may not overlap).
	 */
	interface GeometryCollection : Geometry {

		/**
		 * Returns the number of geometries in the GeometryCollection.
		 * @return the number of elements in the collection
		 */
 		readonly  attribute	long	number_elements;
 
 	// these operations allowing for arbitrary collections 

		/**
		 * Adds the Geometry <code>element</code> to the GeometryCollection.
		 * @param element the element to add to the collection
		 * @throws GeometryCollectionException raised if <code>element</code>
		 * does not
		 * conform to the membership requirements of the GeometryCollection
		 */
 		void		add_element (in Geometry element)
			raises (GeometryCollectionException);

		/**
		 * Merges the GeometryCollection <code>elements</code> into the
		 * GeometryCollection.
		 * @param elements the collection to add to this collection
		 * @throws GeometryCollectionException raised if a component of
		 * elements does not adhere to the membership
		 * restrictions of the GeometryCollection
		 */
 		void		merge (in GeometryCollection elements)
			raises (GeometryCollectionException);

		/**
		 * Inserts the Geometry <code>element</code> at the position in the
		 * Collection indicated by the GeometryIterator <code>where</code>.
         * The iterator is revalidated and is set to the next element after the
         * inserted element.
		 * @param element the element to add to this collection
		 * @param where position where the element will be inserted
		 * @throws GeometryCollectionException raised if <code>element</code>
		 * does not
		 * conform to the membership requirements of the GeometryCollection
		 */
 		void		insert_element_at (in Geometry element,
			in GeometryIterator where)
			raises (GeometryCollectionException);

		/**
		 * Replaces the Geometry <code>element</code> at the position in the
		 * GeometryCollection indicated by the GeometryIterator
		 * <code>where</code>.
         * The iterator is revalidated and stays at the current position.
		 * @param element the element to add to this collection
		 * @param where position where the element will be replaced
		 * @throws GeometryCollectionException raised if <code>element</code>
		 * does not
		 * conform to the membership requirements of the GeometryCollection
		 */
 		void		replace_element_at (in Geometry element,
			in GeometryIterator where)
			raises (GeometryCollectionException);

		/**
		 * Removes the Geometry at the position in the GeometryCollection
		 * indicated by the GeometryIterator <code>where</code>. 
         * The iterator is revalidated and is set to the next element after the
         * deleted element.
		 * @param where position where the element will be removed
		 * @throws GeometryCollectionException
		 */
 		void		remove_element_at (in GeometryIterator where)
			raises (GeometryCollectionException);

		/**
		 * Empties the GeometryCollection.
		 * @throws GeometryCollectionException
		 */
 		void		remove_all_elements ()
			raises (GeometryCollectionException);
 
 	// retrieve a geometry from a collection

		/**
		 * Returns the Geometry at the position in the GeometryCollection
		 * indicated by the GeometryIterator <code>where</code>.
		 * @param where position where the element will be retrieved
		 * @return Geometry element of Collection at position
		 * <code>where</code>
		 * @throws GeometryCollectionException
		 */
 		Geometry retrieve_element_at (in GeometryIterator where)
			raises (GeometryCollectionException);
 
 	// create an iterator over the collection

		/**
		 * Returns an iterator of the GeometryCollection.
		 * @return GeometryIterator for this GeometryCollection
		 * @throws GeometryCollectionException
		 */
 		GeometryIterator    create_iterator()
			raises (GeometryCollectionException);
	};
 

//----------------------------------------------------------------------
// GeometryIterator interface
//----------------------------------------------------------------------

	/**
	 * The GeometryIterator provides clients with access into the components
	 * of a {@link GeometryCollection}, and permits them to specify a location
	 * within a GeometryCollection without being exposed to the implementation
	 * of the GeometryCollection.
	 */
	interface GeometryIterator {

		/**
		 * Returns the next Geometry in the GeometryCollection. Moves the
		 * Iterator on to the next element.
		 * @return Geometry element at next position
		 * @throws GeometryCollectionException raised when the Iterator is
		 * invalid or when the geometry element is not a valid geometry
		 */
 		Geometry		next ()
			raises (GeometryCollectionException);

		/**
		 * Returns the Geometry at the current position in the
		 * GeometryCollection.
		 * @return Geometry element at current position
		 * @throws GeometryCollectionException raised when the Iterator is
		 * invalid or when the geometry element is not a valid geometry
		 */
		Geometry		current ()
			raises (GeometryCollectionException);

		/**
		 * Moves the Iterator <code>howMany</code> elements on in the
		 * GeometryCollection.
		 * <p>
		 * <code>skip(1) + current() == next()</code>
		 * @param howMany munber of elements to skip
		 * @return <code>true</code> if the iterator points to a valid
		 * element in the collection after the skip
		 * @throws GeometryCollectionException raised when the Iterator is
		 * invalid
		 */
		boolean		skip(in long howMany)
			raises (GeometryCollectionException);

		/**
		 * Initializes the Iterator and resets the GeometryIterator to the
		 * beginning of the GeometryCollection.
		 * @throws GeometryCollectionException
		 */
 		void			reset()
			raises (GeometryCollectionException);

		/**
		 * Destroys the GeometryIterator.
		 */
 		void			destroy();
	};


//----------------------------------------------------------------------
// Point interface
//----------------------------------------------------------------------

	/**
	 * The Point interface exposes zero-dimensional geometries.  It inherits
	 * from Geometry.  The boundary of a Point is the empty set. All Points are
	 * simple and closed.
	 */
	interface Point : Geometry {     

		/**
		 * this attribute may be used to retrieve and to set the coordinates
		 * of a Point geometry using the WKSPoint well-known structure.
		 */
 		attribute 	WKSPoint	coordinates;
 
	};

//----------------------------------------------------------------------
// PointFactory interface
//----------------------------------------------------------------------

	/**
	 * This interface provides support for creating new Point objects. It
	 * enforces the geometric policies that a Point geometry must adhere to,
	 * given as input a Well-known Structure, a Well-known Binary
	 * representation, etc.
	 */
	interface PointFactory : GeometryFactory {

		/**
		 * Creates an new Point instance that is a deep-copy of existing.
		 * @param existing Point to be copied
		 * @return new Point instance
		 * @throws GeometryException
		 */
		Point		create_from_Point(in Point existing)
			raises (GeometryException);

		/**
		 * Creates a new Point instance given an spatial referencing system
		 * and a coordinate geometry encoded in the well-known structure (WKS).
		 * @param srs a spatial referencing system
		 * @param geo coordinate geometry as WKS
		 * @return new Point instance
		 * @throws GeometryException
		 */
		Point		create_from_WKSPoint(in SpatialReferenceSystem srs,
			in WKSPoint geo) 
			raises (GeometryException);


		/**
		 * Creates a new Point instance given an spatial referencing system and
		 * a coordinate geometry encoded in the well-known binary (WKB)
		 * representation format.
		 * @param srs a spatial referencing system
		 * @param geo coordinate geometry as WKB
		 * @return new Point instance
		 * @throws GeometryException
		 * @throws NotImplementedException
		 */
		Point		create_from_WKBPoint(in SpatialReferenceSystem srs,
			in OctetSeq geo) 
			raises (NotImplementedException, GeometryException);

	};

//----------------------------------------------------------------------
// MultiPoint interface
//----------------------------------------------------------------------

	/**
	 * The MultiPoint interface exposes a collection of zero-dimensional
	 * geometries (points).  It inherits from GeometryCollection.  The boundary
	 * of a MultiPoint is the empty set. A MultiPoint is simple if no two
	 * components are coincident. All MultiPoints are closed.
	 */
	interface MultiPoint : GeometryCollection {     
	};


//----------------------------------------------------------------------
// MultiPointFactory interface
//----------------------------------------------------------------------

	/**
	 * This interface provides support for creating new MultiPoint objects. It
	 * enforces the geometric policies that a MultiPoint geometry must adhere
	 * to, given as input a Well-known Structure, a Well-known Binary
	 * representation, etc.
	 */
	interface MultiPointFactory : GeometryFactory {

		/**
		 * Creates an new {@link MultiPoint} instance that is a deep-copy of
		 * <code>existing</code>.
		 * @param existing an existing MultiPoint instance
		 * @return new MultiPoint instance
		 * @throws GeometryCollectionException
		 */
 		MultiPoint	create_from_MultiPoint(in MultiPoint existing)
			raises (GeometryCollectionException);

		/**
		 * Creates a new {@link MultiPoint} instance given an spatial
		 * referencing system and a coordinate geometry encoded in the
		 * well-known structure (WKS).
		 * @param srs a spatial referencing system
		 * @param geo coordinate geometry as WKS
		 * @return new MultiPoint instance
		 * @throws GeometryCollectionException
		 */
 		MultiPoint	create_from_WKSMultiPoint(in SpatialReferenceSystem srs, 
			in WKSPointSeq geo) 
			raises (GeometryCollectionException);

		/**
		 * Creates a new {@link MultiPoint} instance given an spatial
		 * referencing system and a coordinate geometry encoded in the
		 * well-known binary (WKB) representation format.
		 * @param srs a spatial referencing system
		 * @param geo coordinate geometry as WKB
		 * @return new MultiPoint instance
		 * @throws GeometryCollectionException
		 * @throws NotImplementedException
		 */
 		MultiPoint	create_from_WKBMultiPoint(in SpatialReferenceSystem srs, 
			in OctetSeq geo) 
			raises (NotImplementedException, GeometryCollectionException);
 
	};


//----------------------------------------------------------------------
// Curve interface
//----------------------------------------------------------------------

	/**
	 * The Curve interface is supported by all one-dimensional continuous
	 * geometries.  It inherits from Geometry.  A Curve has a start point and
	 * end point. It is simple if it does not pass through the same point twice
	 * (except possibly at the start and end points). It is closed if the start
	 * point and the end point are the same. A Curve's boundary is a
	 * {@link MultiPoint} consisting of the start point and the end point for
	 * an unclosed Curve and the empty set for a closed Curve.
	 */
	interface Curve : Geometry {   

		/**
		 * Returns the length of the curve (in coordinate units).
		 * @return length of this curve
		 */
 		readonly  attribute  double 	length;

		/**
		 * Returns the starting {@link Point} of the curve.
		 * @return the starting Point of this curve
		 */
 		readonly  attribute  Point 	start_point;   

		/**
		 * Returns the end {@link Point} of the curve.
		 * @return the end Point of this curve
		 */
 		readonly  attribute  Point 	end_point;

		/**
		 * Returns the starting point of the curve as a {@link WKSPoint}
		 * Well-known Structure.
		 * @return the starting point of this curve
		 */
 		readonly  attribute  WKSPoint	start_point_as_WKS;

		/**
		 * Returns the end point of the curve as a {@link WKSPoint}
		 * Well-known Structure.
		 * @return the end point of this curve
		 */
 		readonly  attribute  WKSPoint	end_point_as_WKS;
 

		/**
		 * Returns <code>true</code> if the entire curve lies within a plane.
		 * @return <code>true</code> if the curve is planar
		 * @throws GeometryException
		 */
 		boolean	is_planar()
			raises (GeometryException);


		/**
		 * Returns the point <code>r</code> coordinate units along the curve
		 * from the start point. Note that since value(0.0) = start_point and
		 * value(length) = end_point, the start_point and end_point attributes
		 * are technically redundant.
		 * <br><b>Note:</b> method returns currently the start point.
		 * @param r coordinate units along the curve
		 * @return point on the curve 
		 * @throws GeometryException raised if <code>r</code> is less than 0 or
		 * greater than {@link #length() length}
		 */
 		Point  value (in double r)
			raises (GeometryException);

		/**
		 * Returns the coordinates of the point <code>r</code> coordinate units
		 * along the curve from the start point in the form of a {@link
		 * WKSPoint} Well-known Structure. Note that since value(0.0) =
		 * start_point and
		 * value(length) = end_point, the start_point and end_point attributes
		 * are technically redundant.
		 * <br><b>Note:</b> method returns currently the start point.
		 * @param r coordinate units along the curve
		 * @return point on the curve as WKS
		 * @throws GeometryException raised if <code>r</code> is less than 0 or
		 * greater than {@link #length() length}
		 */
		WKSPoint  value_as_WKS (in double r)
			raises (GeometryException);
 
	};

//----------------------------------------------------------------------
// LineString interface
//----------------------------------------------------------------------

	/**
	 * The <code>LineString</code> interface exposes linear geometries: curves
	 * defined by a series of points with linear interpolation between points.
	 * It inherits from {@link Curve}.
	 */
	interface LineString : Curve  {

		/**
		 * Returns the number of points in the line string.
		 * @return the number of points
		 */
		readonly	attribute		long		num_points;     


		/**
		 * Returns the <code>index</code>th point of the line string.
		 * @param index the index of the point
		 * @return the <code>index</code>th point of this line string
		 * @throws GeometryException
		 */
		Point	get_point_by_index (in long index)
			raises (GeometryException);

		/**
		 * Returns the <code>index</code>th point of the line string as WKS.
		 * @param index the index of the point
		 * @return the <code>index</code>th point of this line string as WKS
		 * @throws GeometryException
		 */
		WKSPoint	get_point_by_index_as_WKS (in long index)
			raises (GeometryException);


		/**
		 * Sets the <code>index</code>th point of the line string to
		 * <code>new_point</code>.
		 * @param new_point new point of the line string
		 * @param index the index of the point
		 * @throws GeometryException raised if <code>index</code> is less than
		 * 0 or greater than {@link #num_points num_points}
		 */
		void		set_point_by_index (in Point new_point,
			in long index)
			raises (GeometryException);

		/**
		 * Sets the <code>index</code>th point of the line string to
		 * to the point defined by the {@link WKSPoint} Well-known Structure
		 * <code>new_point</code>.
		 * @param new_point new point of the line string as WKS
		 * @param index the index of the point
		 * @throws GeometryException raised if <code>index</code> is less than
		 * 0 or greater than {@link #num_points num_points}
		 */
		void		set_point_by_index_with_WKS (in WKSPoint new_point,
			in long index)
			raises (GeometryException);


		/**
		 * Inserts <code>new_point</code>  into the line string before the
		 * <code>index</code>th point.
		 * @param new_point new point of the line string
		 * @param index the index of the point
		 * @throws GeometryException raised if <code>index</code> is less than
		 * 0 or greater than or equal to {@link #num_points num_points}
		 */
		void		insert_point_by_index (in Point new_point,
			in long index) 
			raises (GeometryException);

		/**
		 * Inserts the point defined by the {@link WKSPoint} Well-known
		 * Structure <code>new_point</code> into the line string before the
		 * <code>index</code>th point.
		 * @param new_point new point of the line string as WKS
		 * @param index the index of the point
		 * @throws GeometryException raised if <code>index</code> is less than
		 * 0 or greater than or equal to {@link #num_points num_points}
		 */
		void		insert_point_by_index_with_WKS (in WKSPoint new_point,
			in long index) 
			raises (GeometryException);


		/**
		 * Appends <code>new_point</code> to the end of the line string.
		 * @param new_point new point of the line string
		 * @throws GeometryException
		 */
		void		append_point (in Point new_point)
			raises (GeometryException);

		/**
		 * Appends the point defined by the {@link WKSPoint} Well-known
		 * Structure <code>new_point</code> to the end of the line string.
		 * @param new_point new point of the line string as WKS
		 * @throws GeometryException
		 */
		void		append_point_with_WKS (in WKSPoint new_point)
			raises (GeometryException);


		/**
		 * Deletes the <code>index</code>th point from the line string. A line
		 * string will typically not be permitted to have less than two points.
		 * @param index the index of the point
		 * @throws GeometryException raised if <code>index</code> is less than
		 * 0 or greater than or equal to {@link #num_points num_points}, if
		 * string has less than 3 points
		 */
		void		delete_point_by_index (in long index) 
			raises (GeometryException);
	};

//----------------------------------------------------------------------
// LineStringFactory interface
//----------------------------------------------------------------------

	/**
	 * This interface provides support for creating new LineString objects. It
	 * enforces the geometric policies that a LineString geometry must adhere
	 * to, given as input a Well-known Structure, a Well-known Binary
	 * representation, etc.
	 */
	interface LineStringFactory : GeometryFactory {

		/**
		 * Creates an new {@link LineString} instance that is a deep-copy of
		 * <code>existing</code>.
		 * @param existing an existing line string instance
		 * @return a new line string instance
		 * @throws GeometryException
		 */
		LineString	create_from_LineString(in LineString existing)
			raises (GeometryException);
 

		/**
		 * Creates a new {@link LineString} instance given an spatial
		 * referencing system and a coordinate geometry encoded in the
		 * well-known structure (WKS).
		 * @param srs a spatial referencing system
		 * @param geo coordinate geometry as WKS
		 * @return a new line string instance
		 * @throws GeometryException
		 */
 		LineString	create_from_WKSLineString (in SpatialReferenceSystem srs, 
			in WKSLineString geo) 
			raises (GeometryException);
	 

		/**
		 * Creates a new {@link LineString} instance given an spatial
		 * referencing system and a coordinate geometry encoded in the
		 * well-known binary (WKB) representation format.
		 * @param srs a spatial referencing system
		 * @param geo coordinate geometry as WKB
		 * @return a new line string instance
		 * @throws GeometryException
		 * @throws NotImplementedException
		 */
 		LineString	create_from_WKBLineString(in SpatialReferenceSystem srs, 
			in OctetSeq geo) 
 			raises (NotImplementedException, GeometryException);
	};

//----------------------------------------------------------------------
// Ring interface
//----------------------------------------------------------------------

	/**
	 * Rings are planar, simple, closed curves i.e. they are
	 * non-self-intersecting, curves where start_point and end_point are
	 * coincident.
	 */
	interface Ring : Curve  {
	};

//----------------------------------------------------------------------
// LinearRing interface
//----------------------------------------------------------------------

	/**
	 * The LinearRing interface exposes closed, linear geometries: rings
	 * defined by a series of points with linear interpolation between points.
	 * It inherits from Ring and LineString.
	 */
	interface LinearRing : Ring, LineString  {
	};

//----------------------------------------------------------------------
// MultiCurve interface
//----------------------------------------------------------------------

	/**
	 * The MultiCurve interface exposes a collection of one-dimensional
	 * geometries (curves). It inherits from {@link GeometryCollection}.
	 * The boundary of a MultiCurve is the modulo 2 union of all start and end
	 * points. A MultiCurve is simple if all its components are simple and the
	 * interiors of no two components intersect.
	 */
	interface MultiCurve : GeometryCollection  {

		/**
		 * returns the sum of the lengths of all constituent curves (in
		 * coordinate units).
		 * @return the lengths of all constituent curves
		 */
		readonly attribute double  length; 

	};

//----------------------------------------------------------------------
// MultiLineString interface
//----------------------------------------------------------------------

	/**
	 * The MultiLineString interface exposes a collection of {@link LineString}
	 * . It inherits from {@link MultiCurve}.
	 */
	interface MultiLineString : MultiCurve {
	};


//----------------------------------------------------------------------
// MultiLineStringFactory interface
//----------------------------------------------------------------------

	/**
	 * This interface provides support for creating new {@link MultiLineString}
	 * objects. It enforces the geometric policies that a MultiLineString
	 * geometry must adhere to, given as input a Well-known Structure, a
	 * Well-known Binary representation, etc.
	 */
	interface MultiLineStringFactory : GeometryFactory {
 
		/**
		 * Creates an new {@link MultiLineString} instance that is a deep-copy
		 * of <code>existing</code>.
		 * @param existing an existing multi line string instance
		 * @return a new multi line string instance
		 * @throws GeometryCollectionException
		 */
 		MultiLineString	create_from_MultiLineString(
			in MultiLineString existing)
			raises (GeometryCollectionException);
 
		/**
		 * Creates a new {@link MultiLineString} instance given an spatial
		 * referencing system and a coordinate geometry encoded in the
		 * well-known structure (WKS).
		 * @param srs a spatial referencing system
		 * @param geo coordinate geometry as WKS
		 * @return a new multi line string instance
		 * @throws GeometryCollectionException
		 */
 		MultiLineString	create_from_WKSMultiLineString(
			in SpatialReferenceSystem srs, in WKSLineStringSeq geo) 
			raises (GeometryCollectionException);
	 
		/**
		 * Creates a new {@link MultiLineString} instance given an spatial
		 * referencing system and a coordinate geometry encoded in the
		 * well-known binary (WKB) representation format.
		 * @param srs a spatial referencing system
		 * @param geo coordinate geometry as WKB
		 * @return a new multi line string instance
		 * @throws GeometryCollectionException
		 * @throws NotImplementedException
		 */
 		MultiLineString	create_from_WKBMultiLineString(
			in SpatialReferenceSystem srs, in OctetSeq geo) 
 			raises (NotImplementedException, GeometryCollectionException);
	};


//----------------------------------------------------------------------
// Surface interface
//----------------------------------------------------------------------

	/**
	 * The Surface interface is supported by all two-dimensional continuous
	 * geometries.  It inherits from {@link Geometry}.  The boundary of a
	 * Surface is the collection of curves constituting its exterior boundary
	 * and any interior boundaries.
	 */
	interface Surface : Geometry {
   
		/**
		 * Returns the area of the surface (in coordinate units).
		 * @return the area of the surface
		 */
		readonly attribute  double  		area;
   
		/**
		 * Returns the centroid of the surface (assuming all points on the
		 * surface are equally weighted).
		 * @return the centroid of the surface
		 */
		readonly attribute  Point		centroid;
   
		/**
		 * Returns the centroid of the surface (assuming all points on the
		 * surface are equally weighted) as a Well-known Structure.
		 * @return the centroid of the surface as WKS
		 */
		readonly attribute  WKSPoint		centroid_as_WKS;
   
		/**
		 * Returns a point on the surface (i.e. a point within the external
		 * boundary and outside all interior boundaries).
		 * @return point on the surface
		 */
		readonly attribute  Point		point_on_surface;
   
		/**
		 * Returns a point on the surface (i.e. a point within the external
		 * boundary and outside all interior boundaries) as a Well-known
		 * Structure.
		 * @return point on the surface as WKS
		 */
		readonly attribute  WKSPoint		point_on_surface_as_WKS;

   
		/**
		 * Returns <code>true</code> if the entire surface lies within a plane.
		 * @return <code>true</code> if the entire surface lies within a plane
		 * @throws GeometryException
		 */
		boolean	is_planar()
			raises (GeometryException);
	};

//----------------------------------------------------------------------
// Polygon interface
//----------------------------------------------------------------------

	/**
	 * The Polygon interface exposes planar surfaces defined by one exterior
	 * ring and a series of internal rings.  It inherits from {@link Surface}.
	 */
	interface Polygon : Surface {
   
		/**
		 * Returns the ring defining the external boundary of the polygon.
		 * @return ring defining the external boundary of the polygon
		 */
		readonly	attribute		Ring			exterior_ring;
   
		/**
		 * Returns the ring defining the external boundary of the polygon as a
		 * Well-known Structure.
		 * <br><b>Note:</b> method currently not implemented.
		 * @return ring defining the external boundary of the polygon as WKS
		 */
		readonly	attribute		WKSGeometry	exterior_ring_as_WKS;


		/**
		 * Returns the collection of rings defining the interior rings (holes)
		 * within the polygon.
		 * @return collection of interior rings
		 */
		readonly	attribute		MultiCurve	interior_rings;

		/**
		 * Returns the collection of rings defining the interior rings (holes)
		 * within the polygon as a Well-known Structure.
		 * <br><b>Note:</b> method currently not implemented.
		 * @return collection of interior rings as WKS
		 */
		readonly	attribute		WKSGeometry	interior_rings_as_WKS;
	};


//----------------------------------------------------------------------
// LinearPolygon interface
//----------------------------------------------------------------------

	/**
	 * The LinearPolygon interface inherits from {@link Polygon} and restricts
	 * the polygon geometry to be linear.
	 */
	interface LinearPolygon : Polygon {
   
	};


//----------------------------------------------------------------------
// LinearPolygonFactory interface
//----------------------------------------------------------------------

	/**
	 * This interface provides support for creating new {@link LinearPolygon}
	 * objects. It enforces the geometric policies that a LinearPolygon
	 * geometry must adhere to, given as input a Well-known Structure, a
	 * Well-known Binary representation, etc.
	 */
	interface LinearPolygonFactory : GeometryFactory {

		/**
		 * Creates an new {@link LinearPolygon} instance that is a deep-copy of
		 * <code>existing</code>.
		 * @param existing an existing linear polygon instance
		 * @return a new linear polygon instance
		 * @throws GeometryException
		 */
		LinearPolygon	create_from_LinearPolygon(in LinearPolygon existing)
			raises (GeometryException);

		/**
		 * Creates a new {@link LinearPolygon} instance given an spatial
		 * referencing system and a coordinate geometry encoded in the
		 * well-known structure (WKS).
		 * @param srs a spatial referencing system
		 * @param geo coordinate geometry as WKS
		 * @return a new linear polygon instance
		 * @throws GeometryException
		 */
		LinearPolygon	create_from_WKSLinearPolygon(
			in SpatialReferenceSystem srs, in WKSLinearPolygon geo) 
			raises (GeometryException);
	
		/**
		 * Creates a new {@link LinearPolygon} instance given an spatial
		 * referencing system and a coordinate geometry encoded in the
		 * well-known binary (WKB) representation format.
		 * @param srs a spatial referencing system
		 * @param geo coordinate geometry as WKB
		 * @return a new linear polygon instance
		 * @throws GeometryException
		 * @throws NotImplementedException
		 */
		LinearPolygon 	create_from_WKBLinearPolygon(
			in SpatialReferenceSystem srs, in OctetSeq geo) 
 			raises (NotImplementedException, GeometryException);
	};


//----------------------------------------------------------------------
// MultiSurface interface
//----------------------------------------------------------------------

	/**
	 * The MultiSurface interface exposes a collection of two-dimensional
	 * geometries (surfaces).  It inherits from {@link GeometryCollection}.
	 */
	interface MultiSurface : GeometryCollection  {

		/**
		 * Returns the sum of the areas of all constituent surfaces.
		 * @return sum of the areas
		 */
		readonly	attribute		double	area; 

	};

//----------------------------------------------------------------------
// MultiPolygon interface
//----------------------------------------------------------------------

	/**
	 * The MultiPolygon interface inherits from {@link MultiSurface}.
	 */
	interface MultiPolygon : MultiSurface {
	};

//----------------------------------------------------------------------
// MultiLinearPolygon interface
//----------------------------------------------------------------------
	/**
	 * The MultiLinearPolygon interface inherits from {@link MultiPolygon} and
	 * restricts the polygon geometries to be linear.
	 */
	interface MultiLinearPolygon : MultiPolygon {
	};

//----------------------------------------------------------------------
// MultiLinearPolygonFactory interface
//----------------------------------------------------------------------

	/**
	 * This interface provides support for creating new {@link
	 * MultiLinearPolygon} objects. It enforces the geometric policies that a
	 * MultiLinearPolygon geometry must adhere to, given as input a Well-known
	 * Structure, a Well-known Binary representation, etc.
	 */
	interface MultiLinearPolygonFactory : GeometryFactory {

		/**
		 * Creates an new {@link MultiLinearPolygon} instance that is a
		 * deep-copy of <code>existing</code>.
		 * @param existing an existing multi linear polygon instance
		 * @return a new multi linear polygon instance
		 * @throws GeometryCollectionException
		 */
		MultiLinearPolygon	create_from_MultiLinearPolygon(
			in MultiLinearPolygon existing)
 			raises (GeometryCollectionException);

		/**
		 * Creates a new {@link MultiLinearPolygon} instance given an spatial
		 * referencing system and a coordinate geometry encoded in the
		 * well-known structure (WKS).
		 * @param srs a spatial referencing system
		 * @param geo coordinate geometry as WKS
		 * @return a new multi linear polygon instance
		 * @throws GeometryCollectionException
		 */
		MultiLinearPolygon	create_from_WKSMultiLinearPolygon(
			in SpatialReferenceSystem srs, in WKSLinearPolygonSeq geo) 
 			raises (GeometryCollectionException);
	
		/**
		 * Creates a new {@link MultiLinearPolygon} instance given an spatial
		 * referencing system and a coordinate geometry encoded in the
		 * well-known binary (WKB) representation format.
		 * @param srs a spatial referencing system
		 * @param geo coordinate geometry as WKB
		 * @return a new multi linear polygon instance
		 * @throws GeometryCollectionException
		 * @throws NotImplementedException
		 */
		MultiLinearPolygon	create_from_WKBMultiLinearPolygon(
			in SpatialReferenceSystem srs, in OctetSeq geo) 
 			raises (NotImplementedException, GeometryCollectionException);
	};

};

#endif



