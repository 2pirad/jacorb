<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 99.1 release (March 30, 1999)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Implementation Repository</TITLE>
<META NAME="description" CONTENT="Implementation Repository">
<META NAME="keywords" CONTENT="ProgrammingGuide">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.1 release">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ProgrammingGuide.css">

<LINK REL="next" HREF="node8.html">
<LINK REL="previous" HREF="node6.html">
<LINK REL="up" HREF="ProgrammingGuide.html">
<LINK REL="next" HREF="node8.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html242"
 HREF="node8.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/usr/lib/latex2html/icons.gif/next_motif.gif"></A> 
<A NAME="tex2html238"
 HREF="ProgrammingGuide.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/lib/latex2html/icons.gif/up_motif.gif"></A> 
<A NAME="tex2html232"
 HREF="node6.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/lib/latex2html/icons.gif/previous_motif.gif"></A> 
<A NAME="tex2html240"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="/usr/lib/latex2html/icons.gif/contents_motif.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html243"
 HREF="node8.html">Interface Repository</A>
<B> Up:</B> <A NAME="tex2html239"
 HREF="ProgrammingGuide.html">JacORB 1.3 Programming Guide</A>
<B> Previous:</B> <A NAME="tex2html233"
 HREF="node6.html">The server side: POA,</A>
 &nbsp <B>  <A NAME="tex2html241"
 HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html244"
 HREF="node7.html#SECTION00710000000000000000">Overview</A>
<LI><A NAME="tex2html245"
 HREF="node7.html#SECTION00720000000000000000">Using the JacORB Implementation Repository</A>
<LI><A NAME="tex2html246"
 HREF="node7.html#SECTION00730000000000000000">Server migration</A>
<LI><A NAME="tex2html247"
 HREF="node7.html#SECTION00740000000000000000">A Note About Security</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00700000000000000000"></A>
<A NAME="Ch_Imr"></A>
<BR>
Implementation Repository
</H1><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<BLOCKQUOTE><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1">
``...  it is  very easy to be blinded to  the essential uselessness of
them by  the sense of achievement you  get from getting it  to work at
all.  In other  words -- and that is a  rock-solid principle on which
the whole of the Corporation's Galaxywide success is founded -- their
fundamental design  flaws are  completely hidden by  their superficial
design flaws.''
</FONT></FONT></FONT></FONT></FONT></FONT></B></I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
D. Adams: So Long and Thanks for all the Fish
</FONT></FONT></FONT></FONT></FONT></FONT></B></I></BLOCKQUOTE><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
The Implementation Repository is not, as its name suggests, a database
of  implementations.   Rather,  it  contains information  about  where
requests  to specific  CORBA objects  have  to be  redirected and  how
implementations  can be  transparently  instantiated if,  for a  given
request  to   an  object,  none  is   reachable.   ``Instantiating  an
implementation'' means starting a server program that hosts the target
object.  In  this  chapter  we  give  a brief  overview  and  a  short
introduction  on how to  use the  Implementation Repository.  For more
details please see [<A
 HREF="node14.html#Henning1999">HV99</A>].
</FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></B></I>
<H1><A NAME="SECTION00710000000000000000">
Overview</A>
</H1><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
Basically, the  Implementation Repository (ImR) is  an indirection for
requests  using  persistent  object  references. A  persistent  object
reference is one that was created  by a POA with a PERSISTENT lifespan
policy. This means that the lifetime of the object is longer than that
of its creating POA.   Using the Implementation Repository for objects
the lifetime  of which does not exceed  the life time of  its POA does
not make sense  as the main function of  the Implementation Repository
is to take care that such  a process exists when requests are made --
and to start one if necessary.
</FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
To fulfill this function, the ImR  has to be involved in every request
to ``persistent  objects''.  This is achieved  by rewriting persistent
object  references to  contain <EM> not</EM>  the address  of its  server
process but  the address  of the ImR.   Thus, requests  will initially
reach the ImR and not the actual server -- which may not exist at the
time of the request. If such a request arrives at the ImR, it looks up
the  server information  in its  internal tables  to determine  if the
target object is reachable or not.  In the latter case, the ImR has to
have  information  about how  an  appropriate  server  process can  be
started.   After   starting  this   server,  the  client   receives  a
LOCATION_FORWARD  exception  from  the  ImR.  This  exception,  which
contains a new  object reference to the actual  server process now, is
handled by its runtime system  transparently.  As a result, the client
will automatically  reissue its request  using the new  reference, now
addressing the target directly.
</FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></B></I>
<H1><A NAME="SECTION00720000000000000000">
Using the JacORB Implementation Repository</A>
</H1><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
The  JacORB   Implementation  Repository  consists   of  two  separate
components:  a repository  process which  need  only exist  once in  a
domain, and  process startup daemons,  which must be present  on every
host that is  to start processes. Note that none  of this machinery is
necessary for processes that host  objects with a TRANSIENT life time,
such as used by the RootPOA.
</FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
First of all, the central repository process (which we will call ImR
in the following) must be started:
</FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></FONT></FONT></B></I><I><B><FONT SIZE="-1"><TT>$ imr [-n] [-p &lt;port&gt;] [-i &lt;ior_file&gt;][-f &lt;file&gt;][-b &lt;file&gt;]</TT><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
The   ImR   is  located   using   the   configuration  property   <TT> 
jacorb.ImplementationRepositoryURL</TT>.  This property  must be  set such
that  a  http  connection  can  be  made and  the  ImR's  IOR  can  be
read. Next, startup  daemons must be created on  selected hosts. To do
this, the following command must is issued on each host:
</FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></FONT></FONT></B></I><I><B><FONT SIZE="-1"><TT>$ imr_ssd</TT><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
When a startup  daemon is created, it contacts  the central ImR.
</FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
To register  a program such that  the ImR can start  it, the following
command is used (on any machine that can reach the ImR):
</FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></FONT></FONT></B></I><I><B><FONT SIZE="-1"><TT>$ imr_mg add "AServerName" -c "jaco MyServer"</TT><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
The <TT> imr_mg</TT> command is the  generic way of telling the ImR to do
something. It  needs another command  parameter, such as <TT> add</TT> in
this case. To add a server to the ImR, an <EM> implementation name</EM> is
needed. Here, it is <TT> "AServerName"</TT>.  If the host were the server
should be  restarted is not the  local one, use the  <TT> -h hostname</TT>
option.  Finally, the  ImR needs to know how to  start the server. The
string <TT> "jaco  MyServer"</TT> tells it how. The  format of this string
is simply such  that the server daemon can execute  it (using the Java
API call  <TT> exec()</TT>), i.e.  it  must be intelligible  to the target
host's operating system.   For a Windows machine, this  could, e.g. be
<TT> "start jaco MyServer"</TT> to have the server run in its own terminal
window, under Unix  the same can be achieved with  <TT> "xterm -e jaco
MyServer"</TT>.
</FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
For a client program to be  able to issue requests, it needs an object
reference.  Up to  this  point,  we haven't  said  anything about  how
persistent object  references come into  existence. Reference creation
happens as usual, i.e. in the server application one of the respective
operations  on a  POA is  called.  For a  reference to  be created  as
``persistent'',  the POA  must  have been  created  with a  PERSISTENT
lifespan policy. This is done as in the following code snippet:
</FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
<FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I><PRE>

    /* init ORB and root POA */
    orb = org.omg.CORBA.ORB.init(args, props);
    org.omg.PortableServer.POA rootPOA = 
        org.omg.PortableServer.POAHelper.narrow(
                        orb.resolve_initial_references("RootPOA"));

    /* create policies  */

    org.omg.CORBA.Policy [] policies = new org.omg.CORBA.Policy[2];
    policies[0] = rootPOA.create_id_assignment_policy(
                                IdAssignmentPolicyValue.USER_ID);
    policies[1] = rootPOA.create_lifespan_policy(
                                LifespanPolicyValue.PERSISTENT);

    /* create POA */

    POA myPOA = rootPOA.create_POA("XYZPOA", 
                                rootPOA.the_POAManager(), policies);

    /* activate POAs */                              
    poa.the_POAManager().activate();
</PRE><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
(Note that in general the  id assignment policy will be <TT> USER_ID</TT>
for a POA with persistent object references because this id will often
be a key into  a database where the object state is  stored). If a POA
is created with this lifespan policy and the ORB property ``use_imr''
is set, the ORB will try to  notify the ImR about this fact so the ImR
knows it doesn't need to start  a new process for requests that target
objects on this  POA.  To set the ORB policy,  simply set the property
<TT> jacorb.use_imr=on</TT>.   The   ORB  uses  another  property,  <TT> 
jacorb.implname</TT>, as  a parameter for the  notification, i.e.&nbsp;it tells
the  ImR  that a  process  using this  property's  value  as its  <EM> 
implementation name</EM> is present. If  the server is registered with the
ImR, this property value has  to match the implementation name that is
used when registering.
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
The application  can set  these properties on  the command  line using
<TT> java -Djacorb.implname=MyName</TT>, or in the code like this:
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
<FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I><PRE>

    /* create and set properties */
    java.util.Properties props = new java.util.Properties();
    props.setProperty("jacorb.use_imr","on");
    props.setProperty("jacorb.implname","MyName");

    /* init ORB  */
    orb = org.omg.CORBA.ORB.init(args, props);
</PRE><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
There are a few things  you have to consider especially when restoring
object state  at startup time or  saving the state of  your objects on
shutdown. It is important that, at startup time, object initialization
is complete when the object  is activated because from this instant on
operation calls  may come  in. The repository  knows about  the server
when the  first POA with  a PERSISTENT lifespan policy  registers, but
does not  forward object  references to clients  before the  object is
actually reachable. (Another, unreliable way to handle this problem is
to  increase the <TT> jacorb.imr.object_activation_sleep</TT> property,
so the repository waits longer for the object to become ready again.)
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
When the server shuts down,  it is equally important that object state
is saved by the time the last POA in the server goes down because from
this moment  the Implementation Repository regards the  server as down
and will start a new one upon requests.  Thus, a server implementor is
responsible for avoiding reader/writer problems between servers trying
to store and  restore the object state.  (One way of  doing this is to
use POA  managers to set  a POA to  holding while saving state  and to
inactive when done.)
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
Please keep in mind  that even if you don't have to  save the state of
your objects  on server shutdown  you <EM> must</EM> deactivate  your POAs
prior   to   exiting   your    process   (or   at   least   use   <TT> 
orb.shutdown(...)</TT> which  includes POA deactivation).  Otherwise the
ImR keeps the  server as active and will return  invalid IORs. In case
of  a  server crash  you  can use  the  command  <TT> imr_mg  setdown
AServerName</TT> to notify the ImR of the server termination.
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<H1><A NAME="SECTION00730000000000000000">
Server migration</A>
</H1><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
The  implementation  repository  offers  another  useful  possibility:
server migration.   Imagine the  following scenario: You  have written
your  server with  persistent  POAs,  but after  a  certain time  your
machine  seems   to  be   too  slow  to   serve  all   those  incoming
requests.  Migrating your  server to  a more  powerful machine  is the
obvious  solution.    Using  the  implementation   repository,  client
references do not contain addressing information for the slow machine,
so server migration can be done transparently to client.
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
Assuming  that you  added your  server to  the repository,  and  it is
running  correctly.  
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I><I><B><FONT SIZE="-1"><TT>$ imr_mg add AServerName -h a_slow_machine -c "jaco MyServer"</TT><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
The first step is to <EM> hold</EM> the server, that means the repository
delays all requests for that server until it is released again.
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I><I><B><FONT SIZE="-1"><TT>$ imr_mg hold AServerName</TT><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
Now  your server  will not  receive  any requests  for its  registered
POAs. If you can't shut your server down such that it sets itself down
at  the repository,  i.e.&nbsp;your POAs  are  set to  inactive prior  to
terminating the process, you can use
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I><I><B><FONT SIZE="-1"><TT>$ imr_mg setdown AServerName</TT><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
to  do  that.   Otherwise  your  POAs  can't  be  reactivated  at  the
repository because they are still logged as active.
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
If you  want your  server to be  restarted automatically, you  have to
tell the repository the new host and maybe a new startup command.
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I><I><B><FONT SIZE="-1"><TT>$ imr_mg edit AServerName -h the_fastest_available_machine
<BR>
-c "jaco MyServer"</TT><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
If your server can be restarted automatically, you now don't even have
to start it manually, but it is instead restarted by the next incoming
request.  Otherwise start it manually on the desired machine now.
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
The last step is to release  the server, i.e.&nbsp;let all delayed requests
continue.
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I><I><B><FONT SIZE="-1"><TT>$ imr_mg release AServerName</TT><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
By now your  server should be running on  another machine, without the
clients noticing.
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<H1><A NAME="SECTION00740000000000000000">
A Note About Security</A>
</H1><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1">
Using the imr can pose a major security threat to your system. Imagine
the following standard setup: an imr  is running on a machine, its IOR
file is placed in a directory where  it can be read by the web server,
and several  imr_ssds are running  on other machines. An  attacker can
now  execute processes  on the  machines the  ssds are  running  on by
taking the following steps:
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<OL>
<LI>Setting  the  <TT> jacorb.ImplementationRepositoryURL</TT>
         property to the IOR file on your server.</LI>
<LI>Creating a new logical server with the desired command
           to execute as startup command on the desired host (where a
           ssd is running). This is the crucial point. The ssd calls
           <TT> Runtime.exec()</TT> with the supplied string, and there
           is no way to check if the command does what it is supposed
           to do, i.e.&nbsp;start a server.</LI>
<LI>Start the server with the imr_mg. The startup command
           of the server will b exec'd on the specified host.</LI>
</OL><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
Now this should  not generally discourage you to use  the imr but show
you  that   there  are  risks,  which  can   be  reduced  significantly
nonetheless. There  are several ways  to encounter this threat  and we
don't consider this list to be complete:
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I>
<OL>
<LI>Try to control the distribution of the IOR file. Hiding
          it should not be considered here, because <I> security by
            obscurity</I> is generally a bad approach. Try to make use of
          file system mechanisms like groups and ACLs.</LI>
<LI>Use a firewall which blocks of incoming traffic. Keep
            in mind that if the attacker is inside of your protection
            domain, the firewall won't help. It is also not that hard
            to write a Trojan that can tunnel those firewalls that
            block incoming traffic.</LI>
<LI>Enforce SSL connections to the imr. This blocks all
            client connections that don't have a certificate signed by
            a CA of your choice. See chapter <A HREF="node10.html#SSL">9</A> for more
            information.</LI>
</OL><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></FONT></FONT></FONT></FONT></B></I><HR>
<!--Navigation Panel-->
<A NAME="tex2html242"
 HREF="node8.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/usr/lib/latex2html/icons.gif/next_motif.gif"></A> 
<A NAME="tex2html238"
 HREF="ProgrammingGuide.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/lib/latex2html/icons.gif/up_motif.gif"></A> 
<A NAME="tex2html232"
 HREF="node6.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/lib/latex2html/icons.gif/previous_motif.gif"></A> 
<A NAME="tex2html240"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="/usr/lib/latex2html/icons.gif/contents_motif.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html243"
 HREF="node8.html">Interface Repository</A>
<B> Up:</B> <A NAME="tex2html239"
 HREF="ProgrammingGuide.html">JacORB 1.3 Programming Guide</A>
<B> Previous:</B> <A NAME="tex2html233"
 HREF="node6.html">The server side: POA,</A>
 &nbsp <B>  <A NAME="tex2html241"
 HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Gerald Brose</I>
<BR><I>2001-02-09</I>
</ADDRESS>
</BODY>
</HTML>
