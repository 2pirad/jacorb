
In this chapter, we will briefly explain the executables that come
with JacORB. These include the IDL--compiler, the JacORB name server.


\section{idl}

The IDL compiler parses IDL specifications  and maps these to a set of
Java classes. IDL interfaces  are translated into Java interfaces, and
typedefs,   structs,   const  declarations   etc.   are  mapped   onto
corresponding Java  classes.  Using {\tt idl},  stubs and
skeletons  for  all interface  types  in  the  IDL specification  will
automatically be generated.

\subsection*{Usage}

\noindent{\tt idl
  [-h|-help] [-v|-version] [-Dsymbol[=value]] [-Idir] [-U <symbol>]
  [-W debug\_level] [-all] [-ami\_callback] [-ami\_polling] [-jdk14]
  [-d <Output Dir>] [-i2jpackage x:y][-i2jpackagefile <filename>]
  [-ir] [-nofinal] [-noskel] [-nostub] [-p <package\_prefix>]
  [-sloppy\_forward] [-sloppy\_names] [-syntax]
  <filelist>}

The option {\tt -v} prints out a short version  string while {\tt -h}
or {\tt -help} displays brief usage information.

With the  {\tt -D} option you can  define symbols that can  be used by
the  preprocessor while  processing  the  IDL file.   If  no value  is
specified, the  symbol will be  defined with a  value of 1. The {\tt
  -U} option lets you undefine symbols again.

The {\tt -I} options allows you to specify one or more search paths for
IDL files included from within  {\tt <filelist>}. If no path is given,
only the  current directory will  be considered.

The {\tt -W} option specifies the amount of debug information the IDL
 compiler will output.

The  compiler  does  not,  by  default,  generate  code  for  included
files. If that is desired, you have to use the {\tt -all} option which
causes code to be generated  for every IDL file directly or indirectly
included from within  {\tt <filelist>}. If you want  to make sure that
for a given IDL no code will  be generated even if this option is set,
you  can use  the  (proprietary) preprocessor  directive {\tt \#pragma
inhibit\_code\_generation}.

The {\tt -ami\_callback} flag allows you to use the callback model of
Asynchronous Method Invocation. See chapter \ref{ch:AMI}.

The {\tt -ami\_polling} flag allows you to use the polling model of
Asynchronous Method Invocation. See chapter \ref{ch:AMI}.

Compiling a  file with  a module {\tt  ModuleX} and
an interface {\tt InterfaceY} in it  will result in a subdirectory
 {\tt ModuleX} with {\tt InterfaceY.java} in it (and possibly more
 {\tt .java}--files). By default, the root directory for all of the
 files created during  the process is the current directory. You can,
 however, provide a  different directory in which these  files are to
 be placed by  using the -d option. Using the -d  option when you are
 only checking the syntax of an IDL file has no effect.

The {\tt -jdk14} option makes the IDL compiler do extra checks to ensure
JDK1.4 compatible code is generated.

To be able to flexibly redirect generated Java classes into packages,
the {\tt -i2jpackage} switch can be used. Using this option, any IDL
scope x can be replaced by one (or more) Java packages y. Specifying
{\tt -i2jpackage X:a.b.c} will thus cause code generated for IDL
definitions within a scope x to end up in a Java package {\tt a.b.c},
e.g. an IDL identifier {\tt X::Y::ident} will be mapped to {\tt
  a.b.c.y.ident} in Java. It is also possible to specify a file
containing these mappings using the {\tt -i2jpackagefile} switch.

The  {\tt -ir} option  instructs the  compiler to  generate additional
files   that    contain   information   needed    by   the   Interface
Repository. Basically, there  is one (very small) extra  file for each
IDL module, and another additional file per IDL interface.

By using the {\tt -nofinal} option the compiler can be made to generate
class definitions that are not final. This will override the default
behaviour, which is to generate final class definitions in certain
circumstances to allow for their optimisation during compilation.

The {\tt -noskel} option suppresses the generation of skeleton files,
which may be unnecessary if you only want to {\em use} a reference and
thus need client--side code.

The {\tt -nostub} option suppresses the generation of client stubs.

The {\tt -sloppy\_forward} option allows forward declarations without
later definitions.

The {\tt -sloppy\_name} option allows less strict checking of module
name scoping.

Invoking {\tt idl}  with the {\tt -syntax} option  allows you to check
your IDL  specification for  syntactic errors without  producing code.
Without {\tt  -syntax}, the compiler creates  directories according to
the Java package structure.

(The  IDL  parser  was   generated  with  Scott  Hudson's  CUP  parser
generator.  The  LALR grammar for  the CORBA IDL  is in the  file {\tt
jacorb/Idl/parser.cup}.)

\section{ns}

JacORB provides a service for mapping names to network references. The
name server itself is written in Java like the rest of the package and
is a  straightforward implementation  of the CORBA  ``Naming Service''
from  Common  Object Services  Spec.,  Vol.1  \cite{OMG1997}. The  IDL
interfaces are mapped to Java according to our Java mapping.

\subsection*{Usage}

\cmdline{ns <filename>  [<timeout>]}

or

\cmdline{jaco jacorb.Naming.NameServer <filename>  [<timeout>]}

\subsection*{Example}

\cmdline{ns \~/public\_html/NS\_Ref}

The name server does {\it not}  use a well known port for its service.
Since clients  cannot (and  need not) know  in advance where  the name
service will  be provided, we use  a bootstrap file in  which the name
server records  an object reference to itself  (its {\it Interoperable
Object Reference} or  IOR). The name of this bootstrap  file has to be
given as an argument to the  {\tt ns} command. This bootstrap file has
to  be available  to clients  network-wide, so  we demand  that  it be
reachable  via a  URL  --- that  is,  there must  be an  appropriately
configured HTTP server in your network domain which allows read access
to the bootstrap  file over a HTTP connection.  (This implies that the
file must have its read  permissions set appropriately. If the binding
to the name service fails, please  check that this is the case.) After
locating the name service through this mechanism, clients will connect
to the name server directly, so the only HTTP overhead is in the first
lookup of the server.

The name bindings in the server's database are stored in and retrieved
from a file that is found in the current directory unless the property
{\tt jacorb.naming.db\_dir} is set to a different directory name. When
the server  starts up, it tries  to read this file's  contents. If the
file  is  empty or  corrupt,  it will  be  ignored  (but overridden  on
exit). The name server can only save its state when it goes down after
a specified timeout. If the server is interrupted (with {\tt CTRL-C}),
state information  is lost  and the file  will not contain  any usable
data.

If no timeout is specified, the name server will simply stay up until
it is killed. Timeouts are specified in milliseconds.

\section{nmg}

The JacORB  NameManager, a  GUI for the  name service, can  be started
using the {\tt nmg} command.  The NameManager then tries to connect to
an existing name service.

\subsection*{Usage}

\cmdline{nmg}

\section{lsns}

This utility  lists the contents  of the default naming  context. Only
currently active servers that have registered are listed. The {\tt -r}
option recursively lists the  contents of naming contexts contained in
the root  context. If  the graph of  naming contexts  contains cycles,
trying to list the entire contents recursively will not return...

\subsection*{Usage}


\cmdline{lsns [-r] }

\subsection*{Example}

\cmdline{lsns \\
\ /grid.service}

when only the server for the grid example is running and registered
with the name server.


\section{dior}

JacORB comes with a simple utility to decode an interoperable object reference
(IOR) in string form into a more readable representation.

\subsection*{Usage}

\cmdline{dior <IOR-string> | -f <filename>}

\subsection*{Example}

In the following example we use it to print out the contents of the
IOR that the JacORB name server writes to its file:

\cmdline{dior -f \~/public\_html/NS\_Ref}
\small{\begin{verbatim}
------IOR components-----
TypeId  :       IDL:omg.org/CosNaming/NamingContextExt:1.0
Profile Id   :  TAG_INTERNET_IOP
IIOP Version :  1.0
Host    :       160.45.110.41
Port    :       49435
Object key :    0x52 6F 6F 74 50 4F 41 3A 3A 30 D7 D1 91 E1 70 95 04
\end{verbatim}
}

\section{pingo}

``Ping'' an object using its stringified IOR. Pingo will call {\tt
  \_non\_existent()} on the object's reference to determine whether
  the object is alive or not.

\subsection*{Usage}

\cmdline{pingo <IOR-string> | -f <filename> }

\section{ir}

This command starts the JacORB Interface Repository, which is explained in
chapter \ref{ch:interface_repository}.

\subsection*{Usage}

\cmdline{ir <reppository class path> <IOR filename> }

\section{qir}

This command queries the JacORB Interface Repository and prints out
re--generated IDL for the repository item denoted by the argument
repository ID.

\subsection*{Usage}

\cmdline{qir <reppository Id> }

\section{ks}

This command starts the JacORB KeyStoreManager, which is explained in
chapter \ref{ch:SSL}

\subsection*{Usage}

\cmdline{ks}

\section{fixior}

This command patches host and port information into an IOR file.

\subsection*{Usage}

\cmdline{fixior <host> <port> <ior\_file> }


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../ProgrammingGuide"
%%% End: 
