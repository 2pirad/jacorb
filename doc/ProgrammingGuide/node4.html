<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 99.1 release (March 30, 1999)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Getting Started</TITLE>
<META NAME="description" CONTENT="Getting Started">
<META NAME="keywords" CONTENT="ProgrammingGuide">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.1 release">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ProgrammingGuide.css">

<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="up" HREF="ProgrammingGuide.html">
<LINK REL="next" HREF="node5.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html192"
 HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/usr/lib/latex2html/icons.gif/next_motif.gif"></A> 
<A NAME="tex2html188"
 HREF="ProgrammingGuide.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/lib/latex2html/icons.gif/up_motif.gif"></A> 
<A NAME="tex2html182"
 HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/lib/latex2html/icons.gif/previous_motif.gif"></A> 
<A NAME="tex2html190"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="/usr/lib/latex2html/icons.gif/contents_motif.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html193"
 HREF="node5.html">The JacORB Name Service</A>
<B> Up:</B> <A NAME="tex2html189"
 HREF="ProgrammingGuide.html">JacORB 1.3 Programming Guide</A>
<B> Previous:</B> <A NAME="tex2html183"
 HREF="node3.html">Installing JacORB</A>
 &nbsp <B>  <A NAME="tex2html191"
 HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html194"
 HREF="node4.html#SECTION00410000000000000000">JacORB development: an overview</A>
<LI><A NAME="tex2html195"
 HREF="node4.html#SECTION00420000000000000000">IDL specifications</A>
<LI><A NAME="tex2html196"
 HREF="node4.html#SECTION00430000000000000000">Generating Java classes</A>
<LI><A NAME="tex2html197"
 HREF="node4.html#SECTION00440000000000000000">Implementing the interface</A>
<LI><A NAME="tex2html198"
 HREF="node4.html#SECTION00450000000000000000">Writing the Server</A>
<LI><A NAME="tex2html199"
 HREF="node4.html#SECTION00460000000000000000">Writing a client</A>
<UL>
<LI><A NAME="tex2html200"
 HREF="node4.html#SECTION00461000000000000000">The Tie Approach</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00400000000000000000"></A>
<A NAME="start"></A>
<BR>
Getting Started
</H1>
<P>
<I><B> 
Before we  explain an example  in detail, we  will have a look  at the
general process  of developing  CORBA applications with  JacORB. We'll
follow this roadmap when working through the example.  The example can
be found in  <TT> demo/grid</TT> which also contains a  build file so that
the development  steps do  not have to  be carried out  manually every
time.  Still, you should know what is going on.
</B></I>
<P>
<I><B> 
As this document gives only a short introduction to JacORB programming
and does not cover all the details of CORBA IDL, we recommend that you
also look at  the other examples in the  <TT> demo/</TT> directory.  These
are organized so as to show how the different aspects of CORBA IDL can
be used with JacORB.
</B></I>
<P>
<H1><A NAME="SECTION00410000000000000000">
JacORB development: an overview</A>
</H1>
<P>
<I><B> 
The steps we will generally have to take are:
</B></I>
<P>
<OL>
<LI>write an IDL specification.</LI>
<LI>compile this specification with the IDL compiler to generate Java classes.</LI>
<LI>write an implementation for the interface generated in step
      2</LI>
<LI>write a ``Main'' class that instantiates the server implementation
        and registers it with the ORB</LI>
<LI>write a client class that retrieves a reference to the server object.</LI>
</OL>
<P>
<H1><A NAME="SECTION00420000000000000000">
IDL specifications</A>
</H1>
<P>
<I><B> 
Our example uses a simple server the definition of which should be
clear if you know IDL. Its interface is given in <TT> server.idl</TT>. All
the source code for this example can be found in <TT> 
  JacORB1_3/demo/grid</TT>.
</B></I>
<P>
<I><B> 
<FONT SIZE="-1"> 
</FONT></B></I><PRE>

// server.idl
// IDL definition of a 2-D grid:
module demo
{
  module grid 
  { 
    interface MyServer
    {
        typedef fixed &lt;5,2&gt; fixedT;

        readonly attribute short height;  // height of the grid
        readonly attribute short width;   // width of the grid

        // set the element [n,m] of the grid, to value:
        void set(in short n, in short m, in fixedT value);

        // return element [n,m] of the grid:
        fixedT get(in short n, in short m);
        
        exception MyException
        {
            string why;
        };

        short opWithException() raises( MyException );
    };
  };
};
</PRE><I><B></B></I>
<P>
<I><B></B></I>
<H1><A NAME="SECTION00430000000000000000">
Generating Java classes</A>
</H1><I><B></B></I>
<P>
<I><B><FONT SIZE="-1"> 
Feeding this file into the IDL compiler 
</FONT></B></I>
<P>
<I><B><FONT SIZE="-1"> 
</FONT></B></I><I><B><FONT SIZE="-1"><TT>$ idl -d ../..  server.idl</TT>
</FONT></B></I>
<P>
<I><B><FONT SIZE="-1"> 
produces a number of Java  classes that represent the IDL definitions.
This is  done according to a  set of rules known  as the IDL-to-Java
language mapping as standardized by  the OMG. If you are interested in
the details of the language mapping, i.e. which IDL language construct
is  mapped  to  which  Java  language construct,  please  consult  the
specifications available from  <TT> www.omg.org</TT>. The language mapping
used by the JacORB IDL compiler is the one defined in CORBA 2.3 and is
explained in detail in  [<A
 HREF="node14.html#Brose2001a">BVD01</A>]. For practical usage, please
consult the examples in the <TT> demo</TT> directory.
</FONT></B></I>
<P>
<I><B><FONT SIZE="-1"> 
The most important Java classes  generated by the IDL compiler are the
interfaces <TT> MyServer</TT> and <TT> MyServerOperations</TT>  plus the stub
and  skeleton   files  <TT> _MyServerStub,   MyServerPOA</TT>  and  <TT> 
MyServerPOATie</TT>.  We will  use these classes in the  client and server
as  well as  in the  implementation  of the  grid's functionality  and
explain each in turn.
</FONT></B></I>
<P>
<I><B><FONT SIZE="-1"> 
Note that the IDL compiler  will produce a directory structure for the
generated code  that corresponds  to the module  structure in  the IDL
file, so it would have  produced a subdirectory <TT> demo/grid</TT> in the
current  directory  had we  not  directed  it  to put  this  directory
structure  to <TT> ../..</TT> by  using the  compiler's <TT> -d</TT> switch.
Where to  put the source  files for generated  classes is a  matter of
taste.  Some people  prefer to have everything in  one place (as using
the <TT> -d</TT> option in  this way achieves),  others like to  have one
subdirectory for the generated source  code and another for the output
of the Java compiler, i.e. for the <TT> .class</TT> files.
</FONT></B></I>
<P>
<I><B></B></I>
<H1><A NAME="SECTION00440000000000000000">
Implementing the interface</A>
</H1><I><B></B></I>
<P>
<I><B><FONT SIZE="-1"> 
Let's try  to actually provide an implementation  of the functionality
promised by  the interface. The class which  implements that interface
is called <TT> gridImpl</TT>.   Apart from providing a Java implementation
for the operations listed in the IDL interface, it has to inherit from
a generated class that both  defines the Java type that represents the
IDL type <TT> MyServer</TT> and contains the code needed to receive remote
invocations and return results to  remote callers.  This class is <TT> 
MyServerPOA</TT>.
</FONT></B></I>
<P>
<I><B><FONT SIZE="-1"> 
You might have noticed that this approach is impractical in situations
where your  implementation class needs to inherit  from other classes.
As  Java only has  single inheritance  for implementations,  you would
have  to use  an alternative  approach --  the  ``tie''-approach --
here. The tie approach will be explained later.
</FONT></B></I>
<P>
<I><B><FONT SIZE="-1"> 
Here is  the Java code for  the grid implementation. It  uses the Java
library  class  <TT> java.math.BigDecimal</TT>  for  values  of  the  IDL
fixed-point type <TT> fixedT</TT>:
</FONT></B></I>
<P>
<I><B><FONT SIZE="-1"> 
<FONT SIZE="-1"> 
</FONT></FONT></B></I><PRE>

package demo.grid;

/**
 * A very simple implementation of a 2-D grid
 */

import demo.grid.MyServerPackage.MyException;

public class gridImpl  
    extends MyServerPOA
{
    protected short height = 31;
    protected short width = 14;
    protected java.math.BigDecimal[][] mygrid;
 
    public gridImpl()
    {
        mygrid = new java.math.BigDecimal[height][width];
        for( short h = 0; h &lt; height; h++ )
        {
            for( short w = 0; w &lt; width; w++ )
            {
                mygrid[h][w] = new java.math.BigDecimal("0.21");
            }
        }
    }

    public java.math.BigDecimal get(short n, short m)
    {
        if( ( n &lt;= height ) &amp;&amp; ( m &lt;= width ) )
            return mygrid[n][m];
        else
            return new java.math.BigDecimal("0.01");
    }

    public short height()
    {
        return height;
    }

    public void set(short n, short m, java.math.BigDecimal value)
    {
        if( ( n &lt;= height ) &amp;&amp; ( m &lt;= width ) )
            mygrid[n][m] = value;
    }

    public short width()
    {
        return width;
    }

    public short opWithException()
        throws demo.grid.MyServerPackage.MyException
    {
        throw new demo.grid.MyServerPackage.MyException("This is only a test exception, no harm done :-)");
    }
}
</PRE><I><B><FONT SIZE="-1"></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"></FONT></B></I>
<H1><A NAME="SECTION00450000000000000000">
Writing the Server</A>
</H1><I><B><FONT SIZE="-1"></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"> 
To actually instantiate a <TT> gridImpl</TT> object which can be accessed
remotely  as  a CORBA  object  of type  <TT> MyServer</TT>,  you have  to
instantiate it  in a main method  of some other class  and register it
with a  component of the CORBA  architecture known as  the <I> Object
Adapter</I>. Here is  the class <TT> Server</TT> which  does all that is
necessary to  activate a  CORBA object of  type <TT> MyServer</TT>  from a
Java <TT> gridImpl</TT> object:
</FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"> 
<FONT SIZE="-1"> 
</FONT></FONT></FONT></B></I><PRE>

package demo.grid;

import java.io.*;
import org.omg.CosNaming.*;

public class Server
{
    public static void main( String[] args )
    {
        org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init(args, null);
        try
        {
            org.omg.PortableServer.POA poa = 
                org.omg.PortableServer.POAHelper.narrow(
                     orb.resolve_initial_references("RootPOA"));
            
            poa.the_POAManager().activate();

            org.omg.CORBA.Object o = poa.servant_to_reference(new gridImpl());

            if( args.length == 1 ) 
            {
                // write the object reference to args[0]

                PrintWriter ps = new PrintWriter(
                                    new FileOutputStream(
                                       new File( args[0] )));
                ps.println( orb.object_to_string( o ) );
                ps.close();
            } 
            else
            {
                // register with the naming service             

                NamingContextExt nc = 
                     NamingContextExtHelper.narrow(
                        orb.resolve_initial_references("NameService"));
                nc.bind( nc.to_name("grid.example"), o);        
            }
        } 
        catch ( Exception e )
        {
            e.printStackTrace();
        }
        orb.run();
    }
}
</PRE><I><B><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
After initializing the ORB we need to obtain a reference to the object
adapter -- the POA -- by asking  the ORB for it. The ORB knows about
a few initial references that can be retrieved using simple names like
``RootPOA''. The returned object is  an untyped reference of type <TT> 
CORBA.Object</TT> and thus needs to  be narrowed to the correct type using
a static  method <TT> narrow()</TT>  in the helper  class for the  type in
question. We now  have to activate the POA because  any POA is created
in  ``holding''   state  in  which   it  does  not   process  incoming
requests.  After  calling <TT> activate()</TT>  on  the POA's  POAManager
object, the POA is in an active state and can now be asked to create a
CORBA  object  reference  from a  Java  object  also  know as  a  <TT> 
Servant</TT>.
</FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
In order to make the newly created CORBA object accessible, we have to
make its  object reference  available. This is  done using  a publicly
accessible directory  service, the naming  server. A reference  to the
naming      service     is      obtained      by     calling      <TT> 
orb.resolve_initial_references("NameService")</TT>   on   the  ORB   and
narrowing the reference using the <TT> narrow()</TT> method found in class
<TT> org.omg.CosNaming.NamingContextExtHelper</TT>.  Having done this, you
should call the  <TT> bind()</TT> operation on the  name server.  The name
for the object which has to be supplied as an argument to <TT> bind()</TT>
is not simply a string. Rather, you need to provide a sequence of <TT> 
CosNaming.NameComponent</TT>s that represent the  name. In the example, we
chose to use an extended Name Server interface that provides us with a
more convenient conversion operation from strings to Names.
</FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></B></I>
<H1><A NAME="SECTION00460000000000000000">
Writing a client</A>
</H1><I><B><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
Finally, let's have a look at the client class which invokes the
server operations:
</FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
<FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></B></I><PRE>

package demo.grid;

import org.omg.CosNaming.*;

public class Client
{
   public static void main(String args[]) 
   { 
       try
       {
           MyServer grid;
           org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init(args,null);

           if(args.length==1 )
           {
               // args[0] is an IOR-string 
               grid = MyServerHelper.narrow(orb.string_to_object(args[0]));
           }
           else
           {
               NamingContextExt nc =
                   NamingContextExtHelper.narrow(
                      orb.resolve_initial_references("NameService"));

               grid = MyServerHelper.narrow(
                         nc.resolve(nc.to_name("grid.example")));
            }

            short x = grid.height();
            System.out.println("Height = " + x);

            short y = grid.width();
            System.out.println("Width = " + y);

            x -= 1;
            y -= 1;

            System.out.println("Old value at (" + x + "," + y +"): " + 
                               grid.get( x,y));

            System.out.println("Setting (" + x + "," + y +") to 470.11");
                
            grid.set( x, y, new java.math.BigDecimal("470.11"));

            System.out.println("New value at (" + x + "," + y +"): " + 
                               grid.get( x,y));

           try 
           {
               grid.opWithException();
           }
           catch (jacorb.demo.grid.MyServerPackage.MyException ex) 
           {
               System.out.println("MyException, reason: " + ex.why);
           }
       }
       catch (Exception e) 
       {
           e.printStackTrace();
       }
   }
}
</PRE><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
After  initializing the  ORB, the  client obtains  a reference  to the
``grid''  service by locating  the reference  using the  name service.
Again, resolving the name is done by getting a reference to the naming
service                 by                 calling                <TT> 
orb.resolve_initial_references("NameService")</TT> and querying the name
server for  the <TT> "grid"</TT>  object by calling <TT> resolve()</TT>.  The
argument  to  the  resolve  operation  is, again,  a  string  that  is
converted to  a Name. The result  is an object reference  of type <TT> 
org.omg.CORBA.Object</TT>  which has  to be  narrowed to  the type  we are
expecting, i.e. <TT> MyServer</TT>.
</FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
After compiling everything we're now  ready to actually run the server
and the  client on  different (virtual) machines.  Make sure  the name
server is running before starting  either the server or the client. If
it isn't, type something like:
</FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></B></I><I><B><FONT SIZE="-1"><TT>$ ns /home/me/public_html/NS_Ref</TT><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
where  <TT> /home/me/public_html/NS_Ref</TT>  is the  name of  a locally
writable file  which can be  read by using  the URL given in  both the
remote client and  server code. (This is to  avoid using a well-known
address for  the name server,  so both client  and server look  up the
location of the  name server via the URL and  later communicate with it
directly.)
</FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
You can now launch the server:
</FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></B></I><I><B><FONT SIZE="-1"><TT>$ jaco demo.grid.Server</TT><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
The client can be invoked on any machine you like:
</FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></B></I><I><B><FONT SIZE="-1"><TT>$ jaco demo.grid.Client</TT><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
Running the  client after starting  the server produces  the following
output on your terminal:
</FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></B></I><PRE>

Height = 31
Width = 14
Old value at (30,13): 0.21
Setting (30,13) to 470.11
New value at (30,13): 470.11
MyException, reason: This is only a test exception, no harm done :-)
done.
</PRE><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></B></I>
<H2><A NAME="SECTION00461000000000000000">
The Tie Approach</A>
</H2><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
If your implementation class cannot inherit from the generated servant
class  <TT> MyServerPOA</TT> because,  e.g.,  you  need  to inherit  from
another  base class,  you can  use the  tie approach.  Put  simply, it
replaces  inheritance by  delegation. Instead  of inheriting  from the
generated  base  class, your  implementation  needs  to implement  the
generated <EM> operations interface</EM> <TT> MyServerOperations</TT>:
</FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></B></I><PRE>

package demo.grid;

import demo.grid.MyServerPackage.MyException;

public class gridOperationsImpl  
    implements MyServerOperations
{
...
}
</PRE><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
Your server is then written as follows:
</FONT></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"> 
</FONT></FONT></FONT></FONT></B></I><PRE>

package demo.grid;

import java.io.*;
import org.omg.CosNaming.*;

public class TieServer
{
    public static void main( String[] args )
    {
        org.omg.CORBA.ORB orb = 
            org.omg.CORBA.ORB.init(args, null);
        try
        {
            org.omg.PortableServer.POA poa = 
                org.omg.PortableServer.POAHelper.narrow(
                     orb.resolve_initial_references("RootPOA"));

            // use the operations implementation and wrap it in
            // a tie object

            org.omg.CORBA.Object o = 
                poa.servant_to_reference( 
                     new MyServerPOATie( new gridOperationsImpl()) );

            poa.the_POAManager().activate();

            if( args.length == 1 ) 
            {
                // write the object reference to args[0]

                PrintWriter ps = new PrintWriter(
                    new FileOutputStream(new File( args[0] )));
                ps.println( orb.object_to_string( o ) );
                ps.close();
            } 
            else
            {
                NamingContextExt nc = 
                     NamingContextExtHelper.narrow(
                        orb.resolve_initial_references("NameService"));
                NameComponent [] name = new NameComponent[1];
                name[0] = new NameComponent("grid", "whatever");
                nc.bind( name, o );
            }
        } 
        catch ( Exception e )
        {
            e.printStackTrace();
        }
        orb.run();
    }
}
</PRE><I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></B></I>
<P>
<I><B><FONT SIZE="-1"><FONT SIZE="-1"><FONT SIZE="-1"></FONT></FONT></FONT></B></I><HR>
<!--Navigation Panel-->
<A NAME="tex2html192"
 HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/usr/lib/latex2html/icons.gif/next_motif.gif"></A> 
<A NAME="tex2html188"
 HREF="ProgrammingGuide.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/lib/latex2html/icons.gif/up_motif.gif"></A> 
<A NAME="tex2html182"
 HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/lib/latex2html/icons.gif/previous_motif.gif"></A> 
<A NAME="tex2html190"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="/usr/lib/latex2html/icons.gif/contents_motif.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html193"
 HREF="node5.html">The JacORB Name Service</A>
<B> Up:</B> <A NAME="tex2html189"
 HREF="ProgrammingGuide.html">JacORB 1.3 Programming Guide</A>
<B> Previous:</B> <A NAME="tex2html183"
 HREF="node3.html">Installing JacORB</A>
 &nbsp <B>  <A NAME="tex2html191"
 HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<I>Gerald Brose</I>
<BR><I>2001-02-09</I>
</ADDRESS>
</BODY>
</HTML>
